# Introduction

So far in this course and its predecessor CPSC 128 we have been confined
to producing text output to a terminal. That would have been fine in the
days when all we had were text terminals, but in the age of windowing
operating systems using bitmapped graphics it has looked a little
primitive and unpolished.

The reason we haven’t dealt with bit-mapped graphics until now is that
it involves details and busywork which would have detracted from the
main thrust of algorithmic development, and that all the bitmapped
graphics libraries are object oriented so we needed to get some
experience with OOP first.

I’m hoping that we’ve done enough programming now that the details
won’t confuse you, and that we’ve seen enough OOP to be able to read
and use an OO library. At any rate we are about to find out!

The following pages should lead you through the installation of PyGame
and up to drawing simple diagrams with it. In later weeks we will look
at using PyGame to make things move on-screen (or at least seem to move,
animation is all a con). We will continue to use the pygame library both
to produce static graphical output, and to produce dynamic or animated
output as the course proceeds.

**You should enter and run each program!**

The code is all in the form of images, so I’m afraid you can’t cut and
paste it, but there is very little new code from one sample to the next,
so if you just edit each file to create the next one in the sequence you
won’t have to do much typing, and doing so should be instructive.

As you work your way through the examples look for the bright red
comments each time you get to a new program. I have tried to make the
code self-explanatory, and have commented each significant addition.
Comments are not repeated to keep the code spare, so a feature is only
described the first time it is added to the code. You will have to pay a
bit more attention to notice what has been removed from one version to
the next, but the comments often refer to the deletions.

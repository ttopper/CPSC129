{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CPSC 129: Object-oriented Programming 2 Week 1 Course Information Course Description Schedule Addendum: Marking Scheme Algorithm Development Case Study: Life 1: Conway's Game of Life (aka CGoL) Introduction Algorithm Overview and Pseudocode Create and Initialize the Universe Display the Universe Age the Universe conway_v0.py.png Assignment 1 Week 2 Searching Introduction Linear search, unordered list Linear search, ordered list Binary search Interpolative search Algorithm Analysis Introduction Big O Notation What order is linear search? What order is binary search? O(log n) vs O(n) Common Algorithm Orders [11:22] MISSING Algorithm Development Case Study: Animation (Bouncing Balls using PyGame) Introduction Getting started with Pygame It's installed, but is Pygame actually working? Exiting Pygame more gracefully Drawing something Drawing lots of a thing Drawing lots of things Resource: The ball image Assignment 2 Week 3 Recursion Recursion by example Recursion Through a List Calculating Factorials Recursve Binary Search Recursive Data Structure recursion.py: Recursion examples Summary Notes Working with Text Files Context: Persistence Text versus binary files Reading from text files Example: Searching log files N.B. Files are sequential Is there more? Writing to text files Appending to files Reading numeric data Life 2: Persistence Introduction The Goal Option 1: Store a screenshot of the universe Option 2: Store the universe array using str(u) Option 3: Store only the coordinates of live cells Option 4: Use only 1 bit per cell Python helps out: Pickling Assignment 3 Week 4 Review: From Pickles on Shelves to CRUD Context: Persistence Python helps out: Pickling Python helps out more: Shelves Gotcha! Shelves update on assignment not mutation (?!) CRUD = A controller for our database The Main Event Loop MVC Architecture (Model, View, Controller) Introduction Step 1: Separating the Model from the Controller Step 2: The Model Step 3: The Quote Class UIDs Step 4: The Model Revisited (for testing) Step 5: Controller revisited Support file: Quote_0.py Support file: MVC_Model_0.py Support file: MVC_Controller_0.py PyGame 2: Animation Introduction Making something move 1 Making something move 2 Making something move 3 Making something move 4 Making something move 5 Resource: The ball image Assignment 4 Week 5 Sorting 1 Video(s): Sorting out sorting Straight insertion sort Straight selection sort Straight exchange sort Shell sort Life 3: More speed! Where to begin? Measure, don't guess Reworking Aging The new aging scheme Is it better? Measure again Assignment 5 Week 6 MVC 2: Even more separation The Issue The Payoff Separating Controller and Quote A Quote Factory Adding More Object Types Your Turn MVC_controller.py MVC_model.py quote.py Creating Mazes: A case study in OOP and algorithm development The Problem Approaches From English to Pseudocode Testing our Pseudocode Revising our pseudocode Data Structures (OOP) Initializing the Maze Add some debugging output Sharing walls Put the pieces together A starting point: maze_3.py Assignment 6 Week 7 Sorting and Algorithm Analysis 2 Introduction Quicksort A more Pythonic Quicksort Representing a tree using a list Heapsort Life 4: Renovations A graphical interface to go with our graphical display Step 1: Make a plan Step 2: Review existing code Step 3: Test existing code Step 4: Make room for the menu Step 5: Refactoring interlude Step 6: Display the menu icons Step 7: Map mouse clicks to actions Step 8: Merge the UI and the simulation life_gui_6.py: Ending point of the presentation; starting point for the assignment Assignment 7 Week 8 CGI: Give your Python application a web interface Introduction Software Distribution Web-based Computing Introduction to CGI Your first web server Testing static serving Testing CGI serving Toward a real CGI program The input form The processing script Unifying the form input file and the script file Support file: mi2km_input_v3/ Support file: mi2km_output_v3/ Fancier input HTML form controls demoform.py Fancier output Interactive Maze Interactive Maze Assignment 8 Week 9 Two Approaches to Median Finding: An Algorithm Development Case Study Introduction Median by Partitioning v0 Median by Partitioning v1 Median by Partitioning v2 Median by Partitioning v3 Median by Bounding v0 [5:35] Median by Bounding v1 [5:00] Median by Bounding v2 [3:50] Median by Bounding v3 [6:25] Data Processing Introduction Case Study: Spelling Bee Administration Data Processing View Potential Problems Python Exceptions EasyGUI Assignment 09 Week 10 HTTP + OOP: Building an Object Server Introduction The problem with CGI How the web works: The World Wide Web The inner nature of HTTP HTTP \"on the wire\" Browsing without a browser CRUD = HTTP? Creating a specialized webserver: A minimal HTTP server in Python An ugly truth about browsers Translating MVC + CRUD to HTTP Our HTTP request-response cycles Interaction storyboard Code reuse Mapping to HTTP + URL pairs Actual Code ( Source files: quote_server.py , quote.py ) Towards an Object Server: 1. Identify couplings to quote.py 2. Object creation menu requirements 3. Object creation menu Python code 4. Final steps (A thing we're not doing.) Summary Image Processing 1 Introduction PIL: The Python Imaging Library Test Images IPO Programming Point vs Neighbourhood Processes Edge Detection Assignment 10 Week 11 Pitcher Problems: A Case Study in Using Search Trees The problem First: Do it by hand Second: Notice what you did Third: Identify the problem type Formalize the Algorithm Pseudocode An edge case leads to a refinement Towards Python: A little OOP Further towards Python: Pseudocode translation Debugging is_goal() Interlude: Bitwise operations (really just & ) Back to our program: is_goal() Final program Data Processing: Reporting A report generation problem Assignment 11 Week 12 Image Enhancement Lab Introduction Dynamic Range Noise Filtering Sharpening DP: Names and Addresses Algorithms and Heuristics Introduction The Goal Complications activedirectory.txt peoplesoft.txt Assignment 12 Week 13 Exam Preparation Examinable topics Exam Study Guide Redacted final exam + Q&A","title":"CPSC 129: Object-oriented Programming 2"},{"location":"#cpsc-129-object-oriented-programming-2","text":"","title":"CPSC 129: Object-oriented Programming 2"},{"location":"#week-1","text":"","title":"Week 1"},{"location":"#course-information","text":"Course Description Schedule Addendum: Marking Scheme","title":"Course Information"},{"location":"#algorithm-development-case-study-life-1-conways-game-of-life-aka-cgol","text":"Introduction Algorithm Overview and Pseudocode Create and Initialize the Universe Display the Universe Age the Universe conway_v0.py.png","title":"Algorithm Development Case Study: Life 1: Conway's Game of Life (aka CGoL)"},{"location":"#assignment-1","text":"","title":"Assignment 1"},{"location":"#week-2","text":"","title":"Week 2"},{"location":"#searching","text":"Introduction Linear search, unordered list Linear search, ordered list Binary search Interpolative search","title":"Searching"},{"location":"#algorithm-analysis","text":"Introduction Big O Notation What order is linear search? What order is binary search? O(log n) vs O(n) Common Algorithm Orders [11:22] MISSING","title":"Algorithm Analysis"},{"location":"#algorithm-development-case-study-animation-bouncing-balls-using-pygame","text":"Introduction Getting started with Pygame It's installed, but is Pygame actually working? Exiting Pygame more gracefully Drawing something Drawing lots of a thing Drawing lots of things Resource: The ball image","title":"Algorithm Development Case Study: Animation (Bouncing Balls using PyGame)"},{"location":"#assignment-2","text":"","title":"Assignment 2"},{"location":"#week-3","text":"","title":"Week 3"},{"location":"#recursion","text":"Recursion by example Recursion Through a List Calculating Factorials Recursve Binary Search Recursive Data Structure recursion.py: Recursion examples Summary Notes","title":"Recursion"},{"location":"#working-with-text-files","text":"Context: Persistence Text versus binary files Reading from text files Example: Searching log files N.B. Files are sequential Is there more? Writing to text files Appending to files Reading numeric data","title":"Working with Text Files"},{"location":"#life-2-persistence","text":"Introduction The Goal Option 1: Store a screenshot of the universe Option 2: Store the universe array using str(u) Option 3: Store only the coordinates of live cells Option 4: Use only 1 bit per cell Python helps out: Pickling","title":"Life 2: Persistence"},{"location":"#assignment-3","text":"","title":"Assignment 3"},{"location":"#week-4","text":"","title":"Week 4"},{"location":"#review-from-pickles-on-shelves-to-crud","text":"Context: Persistence Python helps out: Pickling Python helps out more: Shelves Gotcha! Shelves update on assignment not mutation (?!) CRUD = A controller for our database The Main Event Loop","title":"Review: From Pickles on Shelves to CRUD"},{"location":"#mvc-architecture-model-view-controller","text":"Introduction Step 1: Separating the Model from the Controller Step 2: The Model Step 3: The Quote Class UIDs Step 4: The Model Revisited (for testing) Step 5: Controller revisited Support file: Quote_0.py Support file: MVC_Model_0.py Support file: MVC_Controller_0.py","title":"MVC Architecture (Model, View, Controller)"},{"location":"#pygame-2-animation","text":"Introduction Making something move 1 Making something move 2 Making something move 3 Making something move 4 Making something move 5 Resource: The ball image","title":"PyGame 2: Animation"},{"location":"#assignment-4","text":"","title":"Assignment 4"},{"location":"#week-5","text":"","title":"Week 5"},{"location":"#sorting-1","text":"Video(s): Sorting out sorting Straight insertion sort Straight selection sort Straight exchange sort Shell sort","title":"Sorting 1"},{"location":"#life-3-more-speed","text":"Where to begin? Measure, don't guess Reworking Aging The new aging scheme Is it better? Measure again","title":"Life 3: More speed!"},{"location":"#assignment-5","text":"","title":"Assignment 5"},{"location":"#week-6","text":"","title":"Week 6"},{"location":"#mvc-2-even-more-separation","text":"The Issue The Payoff Separating Controller and Quote A Quote Factory Adding More Object Types Your Turn MVC_controller.py MVC_model.py quote.py","title":"MVC 2: Even more separation"},{"location":"#creating-mazes-a-case-study-in-oop-and-algorithm-development","text":"The Problem Approaches From English to Pseudocode Testing our Pseudocode Revising our pseudocode Data Structures (OOP) Initializing the Maze Add some debugging output Sharing walls Put the pieces together A starting point: maze_3.py","title":"Creating Mazes: A case study in OOP and algorithm development"},{"location":"#assignment-6","text":"","title":"Assignment 6"},{"location":"#week-7","text":"","title":"Week 7"},{"location":"#sorting-and-algorithm-analysis-2","text":"Introduction Quicksort A more Pythonic Quicksort Representing a tree using a list Heapsort","title":"Sorting and Algorithm Analysis 2"},{"location":"#life-4-renovations","text":"A graphical interface to go with our graphical display Step 1: Make a plan Step 2: Review existing code Step 3: Test existing code Step 4: Make room for the menu Step 5: Refactoring interlude Step 6: Display the menu icons Step 7: Map mouse clicks to actions Step 8: Merge the UI and the simulation life_gui_6.py: Ending point of the presentation; starting point for the assignment","title":"Life 4: Renovations"},{"location":"#assignment-7","text":"","title":"Assignment 7"},{"location":"#week-8","text":"","title":"Week 8"},{"location":"#cgi-give-your-python-application-a-web-interface","text":"Introduction Software Distribution Web-based Computing Introduction to CGI Your first web server Testing static serving Testing CGI serving Toward a real CGI program The input form The processing script Unifying the form input file and the script file Support file: mi2km_input_v3/ Support file: mi2km_output_v3/ Fancier input HTML form controls demoform.py Fancier output","title":"CGI: Give your Python application a web interface"},{"location":"#interactive-maze","text":"Interactive Maze","title":"Interactive Maze"},{"location":"#assignment-8","text":"","title":"Assignment 8"},{"location":"#week-9","text":"","title":"Week 9"},{"location":"#two-approaches-to-median-finding-an-algorithm-development-case-study","text":"Introduction Median by Partitioning v0 Median by Partitioning v1 Median by Partitioning v2 Median by Partitioning v3 Median by Bounding v0 [5:35] Median by Bounding v1 [5:00] Median by Bounding v2 [3:50] Median by Bounding v3 [6:25]","title":"Two Approaches to Median Finding: An Algorithm Development Case Study"},{"location":"#data-processing","text":"Introduction Case Study: Spelling Bee Administration Data Processing View Potential Problems Python Exceptions EasyGUI","title":"Data Processing"},{"location":"#assignment-09","text":"","title":"Assignment 09"},{"location":"#week-10","text":"","title":"Week 10"},{"location":"#http-oop-building-an-object-server","text":"Introduction The problem with CGI How the web works: The World Wide Web The inner nature of HTTP HTTP \"on the wire\" Browsing without a browser CRUD = HTTP? Creating a specialized webserver: A minimal HTTP server in Python An ugly truth about browsers Translating MVC + CRUD to HTTP Our HTTP request-response cycles Interaction storyboard Code reuse Mapping to HTTP + URL pairs Actual Code ( Source files: quote_server.py , quote.py ) Towards an Object Server: 1. Identify couplings to quote.py 2. Object creation menu requirements 3. Object creation menu Python code 4. Final steps (A thing we're not doing.) Summary","title":"HTTP + OOP: Building an Object Server"},{"location":"#image-processing-1","text":"Introduction PIL: The Python Imaging Library Test Images IPO Programming Point vs Neighbourhood Processes Edge Detection","title":"Image Processing 1"},{"location":"#assignment-10","text":"","title":"Assignment 10"},{"location":"#week-11","text":"","title":"Week 11"},{"location":"#pitcher-problems-a-case-study-in-using-search-trees","text":"The problem First: Do it by hand Second: Notice what you did Third: Identify the problem type Formalize the Algorithm Pseudocode An edge case leads to a refinement Towards Python: A little OOP Further towards Python: Pseudocode translation Debugging is_goal() Interlude: Bitwise operations (really just & ) Back to our program: is_goal() Final program","title":"Pitcher Problems: A Case Study in Using Search Trees"},{"location":"#data-processing-reporting","text":"A report generation problem","title":"Data Processing: Reporting"},{"location":"#assignment-11","text":"","title":"Assignment 11"},{"location":"#week-12","text":"","title":"Week 12"},{"location":"#image-enhancement-lab","text":"Introduction Dynamic Range Noise Filtering Sharpening","title":"Image Enhancement Lab"},{"location":"#dp-names-and-addresses","text":"Algorithms and Heuristics Introduction The Goal Complications activedirectory.txt peoplesoft.txt","title":"DP: Names and Addresses"},{"location":"#assignment-12","text":"","title":"Assignment 12"},{"location":"#week-13","text":"","title":"Week 13"},{"location":"#exam-preparation","text":"Examinable topics Exam Study Guide Redacted final exam + Q&A","title":"Exam Preparation"},{"location":"01.1_Course_Information/00_index/","text":"Course Information Course Description Schedule Addendum: Marking Scheme","title":"Contents"},{"location":"01.1_Course_Information/00_index/#course-information","text":"Course Description Schedule Addendum: Marking Scheme","title":"Course Information"},{"location":"01.1_Course_Information/01_Course_schedule/","text":"Course Schedule Week Topic Assignment Sep 2 1. Conway's Game of Life 1 1 Sep 9 2. Searching, Algorithm Analysis, & PyGame 1: Drawing on a the Screen 2 Sep 16 3. Recursion, File Review, & Game of Life 2: Persistence 3 Sep 23 4. CRUD controller, MVC Architecture, & PyGame 2: Animation 4 Sep 30 5. Sorting 1 & Game of Life 3: More Speed 5 Oct 7 6. MVC Architecture 2: Even More Separation & Creating Mazes 6 Oct 14 7. Sorting and Algorithm Analysis 2 & Game of Life 4: Renovations 7 Oct 22 7. continued 7 Oct 28 8. CGI: Give your Program a Web Interface & Interactive Maze 8 Nov 4 9. Median Finding & Data Processing 9 Nov 4 Last day to withdraw without academic penalty. Nov 11 Reading Week Nov 18 10. HTTP + OOP & Image Processing 1 10 Nov 25 11. Pitcher Problems (Search Trees) & DP: Reporting 11 Dec 2 12. Image Processing Lab & DP: Names and Addresses 12 Dec 9 Final Exam Preparation","title":"Course Schedule"},{"location":"01.1_Course_Information/01_Course_schedule/#course-schedule","text":"Week Topic Assignment Sep 2 1. Conway's Game of Life 1 1 Sep 9 2. Searching, Algorithm Analysis, & PyGame 1: Drawing on a the Screen 2 Sep 16 3. Recursion, File Review, & Game of Life 2: Persistence 3 Sep 23 4. CRUD controller, MVC Architecture, & PyGame 2: Animation 4 Sep 30 5. Sorting 1 & Game of Life 3: More Speed 5 Oct 7 6. MVC Architecture 2: Even More Separation & Creating Mazes 6 Oct 14 7. Sorting and Algorithm Analysis 2 & Game of Life 4: Renovations 7 Oct 22 7. continued 7 Oct 28 8. CGI: Give your Program a Web Interface & Interactive Maze 8 Nov 4 9. Median Finding & Data Processing 9 Nov 4 Last day to withdraw without academic penalty. Nov 11 Reading Week Nov 18 10. HTTP + OOP & Image Processing 1 10 Nov 25 11. Pitcher Problems (Search Trees) & DP: Reporting 11 Dec 2 12. Image Processing Lab & DP: Names and Addresses 12 Dec 9 Final Exam Preparation","title":"Course Schedule"},{"location":"01.1_Course_Information/02_Marking_scheme/","text":"Assignment Marking Scheme Programming problems will be marked out of 10 according to the following scheme. 9 , 10 \u2192 Excellent work. Does (or exceeds!) what the assignment requested exceptionally well. The final product is simple, yet elegant. 7 , 8 \u2192 Good work. Does what the assignment requested, and does it well: thought has been given to the design, attention has been paid to details, and care taken in the implementation. 5 , 6 \u2192 Acceptable work. Does what the assignment requested, but no more, and without elegance or craft, i.e. your program works correctly, can be read, is not horribly inefficient. 0 - 4 \u2192 Unacceptable work. Does not do the minimum specified by the assignment. Sometimes it is helpful to remind ourselves what key words mean: ex\u00b7cel\u00b7lent ---adj. 1. Of the highest or finest quality; exceptionally good of its kind. good ---adj. 1. Having positive or desirable qualities; not bad or poor. ac\u00b7cept\u00b7a\u00b7ble ---adj. 1. Worthy of being accepted. 2. Adequate enough to satisfy a need, requirement, or standard; satisfactory. 3. Designating an amount or level that can be endured or allowed. Source: The American Heritage Dictionary and Electronic Thesaurus are licensed from Houghton Mifflin Company. Copyright \u00a9 1986, 1987 by Houghton Mifflin Company. All rights reserved. Based upon The American Heritage Dictionary.","title":"Marking Scheme"},{"location":"01.1_Course_Information/02_Marking_scheme/#assignment-marking-scheme","text":"Programming problems will be marked out of 10 according to the following scheme. 9 , 10 \u2192 Excellent work. Does (or exceeds!) what the assignment requested exceptionally well. The final product is simple, yet elegant. 7 , 8 \u2192 Good work. Does what the assignment requested, and does it well: thought has been given to the design, attention has been paid to details, and care taken in the implementation. 5 , 6 \u2192 Acceptable work. Does what the assignment requested, but no more, and without elegance or craft, i.e. your program works correctly, can be read, is not horribly inefficient. 0 - 4 \u2192 Unacceptable work. Does not do the minimum specified by the assignment. Sometimes it is helpful to remind ourselves what key words mean: ex\u00b7cel\u00b7lent ---adj. 1. Of the highest or finest quality; exceptionally good of its kind. good ---adj. 1. Having positive or desirable qualities; not bad or poor. ac\u00b7cept\u00b7a\u00b7ble ---adj. 1. Worthy of being accepted. 2. Adequate enough to satisfy a need, requirement, or standard; satisfactory. 3. Designating an amount or level that can be endured or allowed. Source: The American Heritage Dictionary and Electronic Thesaurus are licensed from Houghton Mifflin Company. Copyright \u00a9 1986, 1987 by Houghton Mifflin Company. All rights reserved. Based upon The American Heritage Dictionary.","title":"Assignment Marking Scheme"},{"location":"01.2_CGoL_1_Introduction/00_index/","text":"Algorithm Development Case Study: Life 1: Conway\u2019s Game of Life Introduction Algorithm Overview and Pseudocode Create and Initialize the Universe Display the Universe Age the Universe conway_v0.py.png","title":"Contents"},{"location":"01.2_CGoL_1_Introduction/00_index/#algorithm-development-case-study-life-1-conways-game-of-life","text":"Introduction Algorithm Overview and Pseudocode Create and Initialize the Universe Display the Universe Age the Universe conway_v0.py.png","title":"Algorithm Development Case Study: Life 1: Conway\u2019s Game of Life"},{"location":"01.2_CGoL_1_Introduction/01_Introduction/","text":"Introduction First up this semester is a simulation of Conway\u2019s Game of Life (CGoL). It will remind us how to work with lists of lists, a very common data structure, and give us a base for algorithm refinements in the coming weeks. Conway's Game of Life occurs on a grid with live and dead cells. Each generation simple rules determine whether a each cell survives, dies, or is born. The rules for Conway's Game of Life were described by Martin Gardner in Scientific American (1970) Issue 223: pp 120-123 \"Conways genetic laws are delightfully simple. First note that each cell of the checkerboard (assumed to be an infinite plane) has eight neighboring cells, four adjacent orthogonally, four adjacent diagonally. The rules are: Survivals. Every counter with two or three neighboring counters survives for the next generation. Deaths. Each counter with four or more neighbors dies (is removed) from overpopulation. Every counter with one neighbor or none dies from isolation. Births. Each empty cell adjacent to exactly three neighbors--no more, no fewer--is a birth cell. A counter is placed on it at the next move.\" The amazing thing about these simple rules is that they create seemingly complex behaviours. I enocourage you to play with Conway's Game of Life to get a better understanding of how it works. Game of Life online Try each of these classic shapes to see what happens. Note the start button will run the generations continuously while the next button will only step through one generation. You can also read more about Conway's Game of Life on the Wikipedia page.","title":"Introduction"},{"location":"01.2_CGoL_1_Introduction/01_Introduction/#introduction","text":"First up this semester is a simulation of Conway\u2019s Game of Life (CGoL). It will remind us how to work with lists of lists, a very common data structure, and give us a base for algorithm refinements in the coming weeks. Conway's Game of Life occurs on a grid with live and dead cells. Each generation simple rules determine whether a each cell survives, dies, or is born. The rules for Conway's Game of Life were described by Martin Gardner in Scientific American (1970) Issue 223: pp 120-123 \"Conways genetic laws are delightfully simple. First note that each cell of the checkerboard (assumed to be an infinite plane) has eight neighboring cells, four adjacent orthogonally, four adjacent diagonally. The rules are: Survivals. Every counter with two or three neighboring counters survives for the next generation. Deaths. Each counter with four or more neighbors dies (is removed) from overpopulation. Every counter with one neighbor or none dies from isolation. Births. Each empty cell adjacent to exactly three neighbors--no more, no fewer--is a birth cell. A counter is placed on it at the next move.\" The amazing thing about these simple rules is that they create seemingly complex behaviours. I enocourage you to play with Conway's Game of Life to get a better understanding of how it works. Game of Life online Try each of these classic shapes to see what happens. Note the start button will run the generations continuously while the next button will only step through one generation. You can also read more about Conway's Game of Life on the Wikipedia page.","title":"Introduction"},{"location":"01.2_CGoL_1_Introduction/02_Algorithm_overview/","text":"Algorithm Overview and Pseudocode Look over the Wikipedia page\u2019s section on algorithms for simulating Conway's Game of Live. This will give you an idea about the basic algorithm. As well as some variations that we will implement in the assignment (like the toroidal universe). Running the game of life is computationally expensize with the simple algorithm we are going to implement this week. Later on in the course we will have the opportunity to make our implementation more visually snazzy and computaionally efficient. The basic steps for creating the Game of Life are the following: Create the universe Initialize the universe Forever: Display the universe Age the universe This algorithm is a very general description of what we need to do. Before I start translating this to python I want to provide a bit more detail about how I will age the universe. Create the universe Initialize the universe Forever: Display the universe Age the universe: Consider every cell in the universe Counts its live neighbours Based on its current state and its number of live neighbours Decide if it lives, dies, or is born Record the result in next universe Replace universe with next universe Now we are ready to start implemeting the code in python.","title":"Algorithm Overview"},{"location":"01.2_CGoL_1_Introduction/02_Algorithm_overview/#algorithm-overview-and-pseudocode","text":"Look over the Wikipedia page\u2019s section on algorithms for simulating Conway's Game of Live. This will give you an idea about the basic algorithm. As well as some variations that we will implement in the assignment (like the toroidal universe). Running the game of life is computationally expensize with the simple algorithm we are going to implement this week. Later on in the course we will have the opportunity to make our implementation more visually snazzy and computaionally efficient. The basic steps for creating the Game of Life are the following: Create the universe Initialize the universe Forever: Display the universe Age the universe This algorithm is a very general description of what we need to do. Before I start translating this to python I want to provide a bit more detail about how I will age the universe. Create the universe Initialize the universe Forever: Display the universe Age the universe: Consider every cell in the universe Counts its live neighbours Based on its current state and its number of live neighbours Decide if it lives, dies, or is born Record the result in next universe Replace universe with next universe Now we are ready to start implemeting the code in python.","title":"Algorithm Overview and Pseudocode"},{"location":"01.2_CGoL_1_Introduction/03_Create_and_initialize_U/","text":"Create and Initialize the Universe The first step is to initialize the universe. The universe will be represented as a list of lists (an easy way to represent a board). This is very similar to the representation we used for tic-tac-toe and the Wumpus adjacency matrix. We also need to decide what we will use to indicate that a cell at a specific position is either alive or dead. One good option would be to use a Boolean operator. This can intuitively mapped so that alive cells are True and dead cells are False . Another good option would be to use 0 and 1 . We are going to use this second option because later it will be useful when we age the universe and want to count the neighbours. We are going to break creating the universe into two steps. Create an empty univers (all 0's) Randomly set a subset of the cells to be alive Here is what that looks like as python code. Note the U_SIZE is the size of the universe. So this code will create a 15x15 universe. The LIVE_PCT describes the percentage of live cells in the universe, so with this value approximately 20% of the cells should be alive. Also remember you will have to import random .","title":"Create and Initialize the Universe"},{"location":"01.2_CGoL_1_Introduction/03_Create_and_initialize_U/#create-and-initialize-the-universe","text":"The first step is to initialize the universe. The universe will be represented as a list of lists (an easy way to represent a board). This is very similar to the representation we used for tic-tac-toe and the Wumpus adjacency matrix. We also need to decide what we will use to indicate that a cell at a specific position is either alive or dead. One good option would be to use a Boolean operator. This can intuitively mapped so that alive cells are True and dead cells are False . Another good option would be to use 0 and 1 . We are going to use this second option because later it will be useful when we age the universe and want to count the neighbours. We are going to break creating the universe into two steps. Create an empty univers (all 0's) Randomly set a subset of the cells to be alive Here is what that looks like as python code. Note the U_SIZE is the size of the universe. So this code will create a 15x15 universe. The LIVE_PCT describes the percentage of live cells in the universe, so with this value approximately 20% of the cells should be alive. Also remember you will have to import random .","title":"Create and Initialize the Universe"},{"location":"01.2_CGoL_1_Introduction/04_Display/","text":"Display the Universe Displaying the universe is very similar to displaying a tic-tac-toe board. We need to loop through each row and each column and print either a live cell or a dead cell. To make the board look a little bit more snazzy we are going to represent live cells as the @ symbol and deal cells as the - symbol. The global variable LIVE_CELL and DEAD_CELL will make that easy to edit if we decide to use different symbols later. Here is what that looks like as python code. Remember using end='' changes the default behaviour of our print statement. Normally print automatically adds a newline, but we can change this so that the separator is an empty string, so that all the cells from the same row of our list of lists will correctly print on the same row in our display.","title":"Display the Universe"},{"location":"01.2_CGoL_1_Introduction/04_Display/#display-the-universe","text":"Displaying the universe is very similar to displaying a tic-tac-toe board. We need to loop through each row and each column and print either a live cell or a dead cell. To make the board look a little bit more snazzy we are going to represent live cells as the @ symbol and deal cells as the - symbol. The global variable LIVE_CELL and DEAD_CELL will make that easy to edit if we decide to use different symbols later. Here is what that looks like as python code. Remember using end='' changes the default behaviour of our print statement. Normally print automatically adds a newline, but we can change this so that the separator is an empty string, so that all the cells from the same row of our list of lists will correctly print on the same row in our display.","title":"Display the Universe"},{"location":"01.2_CGoL_1_Introduction/05_Age/","text":"Age the Universe The most complicated step in Conway's game of life is aging the universe. Recall that the pseudocode broke that into multiple steps. Here is the pseudocode describing the main loop of the game. This is similar to the main game loop we used in our Hunt the Wumpus game last semester in that it displays the game state and processes a single turn each time through the loop. Forever: Display the universe Create an empty next universe Age the universe: Consider every cell in the universe Counts its live neighbours Based on its current state and its number of live neighbours Decide if it lives, dies, or is born Record the result in next universe Replace universe with next universe The loop starts by displaying the universe and creating a new empty 'next universe'. Then it goes through each cell and considers each of its eight neighbours. Once it has a count of the neighbours it decides based on that count (and its current state) whether it is alive or dead in the next generation. The final step is to replace the current universe with the next universe. Here is that algorithm in python. Note that we are not aging the borders of our universe... for row in range(1,U_SIZE-1): The reason for this is that checking for neighbours at the borders is a bit messy. At the beginning of the list the index -1 considers the neighbour to be the end of the list. That is because negative numbers are used to index from the end of a list. We get an even less desirable behaviour at the end of the list because we end up with an index out of range error. It is part of your assignment to implement a toroidal universe, where the neighbours wrap to the opposite end of the list. This will be easy on one end of the list and more complicated at the other. Here is the code developed so far (as an image, so you\u2019ll need to type it in). This is the starting point for Assignment 1.","title":"Age the Universe"},{"location":"01.2_CGoL_1_Introduction/05_Age/#age-the-universe","text":"The most complicated step in Conway's game of life is aging the universe. Recall that the pseudocode broke that into multiple steps. Here is the pseudocode describing the main loop of the game. This is similar to the main game loop we used in our Hunt the Wumpus game last semester in that it displays the game state and processes a single turn each time through the loop. Forever: Display the universe Create an empty next universe Age the universe: Consider every cell in the universe Counts its live neighbours Based on its current state and its number of live neighbours Decide if it lives, dies, or is born Record the result in next universe Replace universe with next universe The loop starts by displaying the universe and creating a new empty 'next universe'. Then it goes through each cell and considers each of its eight neighbours. Once it has a count of the neighbours it decides based on that count (and its current state) whether it is alive or dead in the next generation. The final step is to replace the current universe with the next universe. Here is that algorithm in python. Note that we are not aging the borders of our universe... for row in range(1,U_SIZE-1): The reason for this is that checking for neighbours at the borders is a bit messy. At the beginning of the list the index -1 considers the neighbour to be the end of the list. That is because negative numbers are used to index from the end of a list. We get an even less desirable behaviour at the end of the list because we end up with an index out of range error. It is part of your assignment to implement a toroidal universe, where the neighbours wrap to the opposite end of the list. This will be easy on one end of the list and more complicated at the other. Here is the code developed so far (as an image, so you\u2019ll need to type it in). This is the starting point for Assignment 1.","title":"Age the Universe"},{"location":"02.1_Searching/00_index/","text":"Searching Introduction Linear search, unordered list Linear search, ordered list Binary search Interpolative search","title":"Contents"},{"location":"02.1_Searching/00_index/#searching","text":"Introduction Linear search, unordered list Linear search, ordered list Binary search Interpolative search","title":"Searching"},{"location":"02.1_Searching/01_Introduction/","text":"Introduction One of the most common operations software has to perform is to search for something in a list. It may be a phone number, a userid, the definition of a word, an IP address, a credit card number, the amount of an invoice, a search term (e.g. in Google), or, even more commonly but less visibly, it may be searching internal data structures within the software. Because of its ubiquity, and because it is slow when done poorly, search algorithms have received a lot of attention from computer scientists, with the result that the best algorithms can, on large data sets, be thousands to millions of times faster than poor (but still correct) ones. There are many kinds of search problems. The one we will deal with in this unit is that of searching a list of items for one matching a key, or target, value. We will work with lists of integers because they are simple and thus won\u2019t distract us from the algorithm itself, but the techniques generalize trivially to support any object type that supports the ==, < and > operators [^*]. We will see four search algorithms of increasing efficiency, and complexity. The increase in efficiency is realized by using more and more information about the values in the list. While the complexity does increase even the longest algorithm is only a dozen or so lines of Python. Although they are not long they have subtle aspects and require precision in their construction. Think of them as miniature clockworks in which the gears have to mesh just so . The first method is a linear search of an unordered list. This the simplest to write, but also the least efficient. The second is a linear search of an ordered list[^***]. This is faster than the first because it can make use of the fact that the list is sorted. The third is a binary search of an ordered list. This uses the fact that list is sorted, and that we can tell if one value is greater than another. The fourth, an interpolative search of an ordered list. This uses the relative magnitude of values to interpolate between them to find the likely location of the key. One important lesson to take away is that the more information about your data you can leverage, the better the algorithm you can develop. [^ ] What other kinds of search are there? Well one common is searching for one string within another, e.g. searching for all occurrences of the word \u201call\u201d on this web page. In that case we do not begin with a list of items[^ *], but with an extended string of characters. Another type of search problem arises when we search a problem space for the solution to a problem. For example we may search for the solution to an equation, or search a game-space for the next move in tic-tac-toe or chess. In these cases we are not usually searching for a fixed key, but for something that evaluates better than the alternatives, and the search space may be infinite, or, if not infinite, still too large to allow for an exhaustive search that considers all possibilities. We will look at a problem of this type near the end of the term. [^**] Though now that we have mastered split we could use it to divide the page into a list of words and then search that list using the techniques we are about to see. So many ways to solve any problem! [^***] Note that ordering a list can lead to such an improvement in search speed that if a list has to be searched more than a few times it is often worth taking the time to sort it just to improve the search speeds. Of course it is only worth doing so if one uses a very fast sorting algorithms, so search and sorting are often taught hand in hand. We will do pretty much that in the coming weeks.","title":"Introduction"},{"location":"02.1_Searching/01_Introduction/#introduction","text":"One of the most common operations software has to perform is to search for something in a list. It may be a phone number, a userid, the definition of a word, an IP address, a credit card number, the amount of an invoice, a search term (e.g. in Google), or, even more commonly but less visibly, it may be searching internal data structures within the software. Because of its ubiquity, and because it is slow when done poorly, search algorithms have received a lot of attention from computer scientists, with the result that the best algorithms can, on large data sets, be thousands to millions of times faster than poor (but still correct) ones. There are many kinds of search problems. The one we will deal with in this unit is that of searching a list of items for one matching a key, or target, value. We will work with lists of integers because they are simple and thus won\u2019t distract us from the algorithm itself, but the techniques generalize trivially to support any object type that supports the ==, < and > operators [^*]. We will see four search algorithms of increasing efficiency, and complexity. The increase in efficiency is realized by using more and more information about the values in the list. While the complexity does increase even the longest algorithm is only a dozen or so lines of Python. Although they are not long they have subtle aspects and require precision in their construction. Think of them as miniature clockworks in which the gears have to mesh just so . The first method is a linear search of an unordered list. This the simplest to write, but also the least efficient. The second is a linear search of an ordered list[^***]. This is faster than the first because it can make use of the fact that the list is sorted. The third is a binary search of an ordered list. This uses the fact that list is sorted, and that we can tell if one value is greater than another. The fourth, an interpolative search of an ordered list. This uses the relative magnitude of values to interpolate between them to find the likely location of the key. One important lesson to take away is that the more information about your data you can leverage, the better the algorithm you can develop. [^ ] What other kinds of search are there? Well one common is searching for one string within another, e.g. searching for all occurrences of the word \u201call\u201d on this web page. In that case we do not begin with a list of items[^ *], but with an extended string of characters. Another type of search problem arises when we search a problem space for the solution to a problem. For example we may search for the solution to an equation, or search a game-space for the next move in tic-tac-toe or chess. In these cases we are not usually searching for a fixed key, but for something that evaluates better than the alternatives, and the search space may be infinite, or, if not infinite, still too large to allow for an exhaustive search that considers all possibilities. We will look at a problem of this type near the end of the term. [^**] Though now that we have mastered split we could use it to divide the page into a list of words and then search that list using the techniques we are about to see. So many ways to solve any problem! [^***] Note that ordering a list can lead to such an improvement in search speed that if a list has to be searched more than a few times it is often worth taking the time to sort it just to improve the search speeds. Of course it is only worth doing so if one uses a very fast sorting algorithms, so search and sorting are often taught hand in hand. We will do pretty much that in the coming weeks.","title":"Introduction"},{"location":"02.1_Searching/02_Linear_Search_Unordered_List/","text":"Linear Search: Unordered list The first method is a linear search of an unordered list. This the simplest to write, but also the least efficient. We don't know anything about the list, so our only option is to search through each element in the list to see if it matches. If it does match we will want to indicate that we found it, or more specifically the index where we found it. Here are two functions that implement a linear search of an unordered list. For simplicity we will search a list of integers. The function search returns a Boolean: True for present and False for absent. The function search_i returns an integer indicating the index of the number in the list (with -1 indicating it was not in the list). Note that with the algorithm we can only definitively say that we did not find the target after we have searched the entire list.","title":"Linear Search, Unordered list"},{"location":"02.1_Searching/02_Linear_Search_Unordered_List/#linear-search-unordered-list","text":"The first method is a linear search of an unordered list. This the simplest to write, but also the least efficient. We don't know anything about the list, so our only option is to search through each element in the list to see if it matches. If it does match we will want to indicate that we found it, or more specifically the index where we found it. Here are two functions that implement a linear search of an unordered list. For simplicity we will search a list of integers. The function search returns a Boolean: True for present and False for absent. The function search_i returns an integer indicating the index of the number in the list (with -1 indicating it was not in the list). Note that with the algorithm we can only definitively say that we did not find the target after we have searched the entire list.","title":"Linear Search: Unordered list"},{"location":"02.1_Searching/03_Linear_Search_Ordered_List/","text":"Linear Search: Ordered list The second method is a linear search of an ordered list. This is faster than the first because it can make use of the fact that the list is sorted. We still search through the list from the beginning to the end, but we can stop looking once we 'pass' the target. This doesn't save us any time if we what we are looking for is the last element of the list, but it does let us stop searching sooner in many cases. In this solution we make use of the python keyword continue . This tells the program to continue with the next iteration of the loop immediately. If there was additional code inside the loop, but after the if-elif block, it would not run because of the continue .","title":"Linear Search, Ordered List"},{"location":"02.1_Searching/03_Linear_Search_Ordered_List/#linear-search-ordered-list","text":"The second method is a linear search of an ordered list. This is faster than the first because it can make use of the fact that the list is sorted. We still search through the list from the beginning to the end, but we can stop looking once we 'pass' the target. This doesn't save us any time if we what we are looking for is the last element of the list, but it does let us stop searching sooner in many cases. In this solution we make use of the python keyword continue . This tells the program to continue with the next iteration of the loop immediately. If there was additional code inside the loop, but after the if-elif block, it would not run because of the continue .","title":"Linear Search: Ordered list"},{"location":"02.1_Searching/04_Binary_Search/","text":"Binary search techniques generalize trivially to support any object type that supports The third method is a binary search of an ordered list. This uses the fact that list is sorted, and that we can tell if one value is greater than another. Imagine a game where someone asks you to guess a number between 1 and 100. After each guess your friend will tell you if you are too high, too low, or correct. The best strategy is to make your first guess 50, this cuts the number of possible correct answers in half. If the say that 50 is too high, then the next guess should be 25. This cuts the number of possibilities in half again. If 25 is too low then you could guess 37. If that were too low you could guess 43, too high guess 40, too low guess 41, and finally if that were too low you would guess 42 and get the right answer. With only 7 guesses we correctly picked one number out of 100. This is the same strategy used by binary search! Here is the pseuodocode for a binary search. Find the low, high, and middle indices of the list While we haven't found the element (and still have indices to search) If the target is at the middle index Return True we've found it Otherwise if the target is greater than the value at the middle index Set the high index to the middle index Otherwise if the target is smaller than the value at the middle index Set the low index to the middle index Update the middle index based on the new high and low indexes Return False we didn't find it When we translate this pseudocode to python this is what it looks like. Remember that // performs floor division. So that it will always give an integer number (the number of times the whole numerator fits into the divisor). The while loop ends either when we return the value True or when lo is equal to mid. Unlike our guessing game, sometimes our target will not be in the list. When we reach the point where there is nowhere to look between lo and mid we know we have exhausted our search and the element is not in the list. We look at lo and mid instead of mid and hi because we are using floor division (meaning mid is always rounded down). I've included some more exhaustive tests at the bottom. Notice that I've put the tests inside an if statement to make sure the tests are not run when the code is imported as a module. The test are designed to look for all the values in the list and values that were not included in the list. If you run the tests you will notice that the code is not perfect. There are some values where it fails in these tests. There is also another common case that it fails on that is not included in my tests. You will want to fix all of these bugs in the assignment! We noted in the guessing game that it only took 7 guesses when our search space had 100 elements. How well would a binary search work if we were looking in longer and longer lists? Below is a bit of code that calculates how many guesses are required in the worst case for lists of different lengths. And here is the output of that code. Notice that it doesn't go up that quickly even as the list gets bigger. The number of guesses stays small even when we look at much bigger lists. And here is the output of that code. Even when the list is 9000 elements (900x more than our original list) the number of guesses is only 14. The number of guesses isn't increasing linearly with the length of the list. The number of guesses is actually growing logarithmically. We will talk more about the number of operations (guesses) required as our list length changes later in the module.","title":"Binary Search"},{"location":"02.1_Searching/04_Binary_Search/#binary-search","text":"techniques generalize trivially to support any object type that supports The third method is a binary search of an ordered list. This uses the fact that list is sorted, and that we can tell if one value is greater than another. Imagine a game where someone asks you to guess a number between 1 and 100. After each guess your friend will tell you if you are too high, too low, or correct. The best strategy is to make your first guess 50, this cuts the number of possible correct answers in half. If the say that 50 is too high, then the next guess should be 25. This cuts the number of possibilities in half again. If 25 is too low then you could guess 37. If that were too low you could guess 43, too high guess 40, too low guess 41, and finally if that were too low you would guess 42 and get the right answer. With only 7 guesses we correctly picked one number out of 100. This is the same strategy used by binary search! Here is the pseuodocode for a binary search. Find the low, high, and middle indices of the list While we haven't found the element (and still have indices to search) If the target is at the middle index Return True we've found it Otherwise if the target is greater than the value at the middle index Set the high index to the middle index Otherwise if the target is smaller than the value at the middle index Set the low index to the middle index Update the middle index based on the new high and low indexes Return False we didn't find it When we translate this pseudocode to python this is what it looks like. Remember that // performs floor division. So that it will always give an integer number (the number of times the whole numerator fits into the divisor). The while loop ends either when we return the value True or when lo is equal to mid. Unlike our guessing game, sometimes our target will not be in the list. When we reach the point where there is nowhere to look between lo and mid we know we have exhausted our search and the element is not in the list. We look at lo and mid instead of mid and hi because we are using floor division (meaning mid is always rounded down). I've included some more exhaustive tests at the bottom. Notice that I've put the tests inside an if statement to make sure the tests are not run when the code is imported as a module. The test are designed to look for all the values in the list and values that were not included in the list. If you run the tests you will notice that the code is not perfect. There are some values where it fails in these tests. There is also another common case that it fails on that is not included in my tests. You will want to fix all of these bugs in the assignment! We noted in the guessing game that it only took 7 guesses when our search space had 100 elements. How well would a binary search work if we were looking in longer and longer lists? Below is a bit of code that calculates how many guesses are required in the worst case for lists of different lengths. And here is the output of that code. Notice that it doesn't go up that quickly even as the list gets bigger. The number of guesses stays small even when we look at much bigger lists. And here is the output of that code. Even when the list is 9000 elements (900x more than our original list) the number of guesses is only 14. The number of guesses isn't increasing linearly with the length of the list. The number of guesses is actually growing logarithmically. We will talk more about the number of operations (guesses) required as our list length changes later in the module.","title":"Binary search"},{"location":"02.1_Searching/05_Interpolative_Search/","text":"Interpolative search The fourth method is an interpolative search of an ordered list. This uses the relative magnitude of values to interpolate between them to find the likely location of the key. If we have a list of 100 numbers and we know that the first number in the list is one and the last number in the list is 100. If we were looking for the number 20 we could guess that our target number is probably closer to the front of the list. In fact the most likely position is probably 20% of the way through the list. We have interpolated the likely location of the number. If we are wrong we can see if we are too high or too low and adjust our range and recalculate the most likely position of the number based on the new range. The equation for interpolating the likely position of the target is The overall algorithm for interpolative search is very similar to binary search. Here is the pseuodocode for a binary search. Find the low, high indices of the list Find the interpolated index (make sure you don't divide by 0) While we haven't found the element (and still have indices to search) If the target is at the interpolated index Return True we've found it Otherwise if the target is greater than the value at the middle index Set the high index to the interpolated index **minus 1** Otherwise if the target is smaller than the value at the middle index Set the low index to the interpolated index **plus 1** Update the interpolated index (make sure you don't divide by 0) Return False we didn't find it There are a couple of differences between binary search and interpolated search that we should highlight. The first is that there is the possibility that our equation for calculating the position could include a division by 0 if the lst[lo] == lst[hi] . It is important that you handle this case smoothly. Another difference is that we are not setting hi or lo to the interpolated index, but are instead subtracting or adding one so that we make sure that we alter our range each time through the loop. The final difference will be in when to end the while loop. The loop will end when the lo is no longer less than hi and while the value of the target is still between the values at indices lo and hi. You will complete this search in python as part of assignment 2.","title":"Interpolative Search"},{"location":"02.1_Searching/05_Interpolative_Search/#interpolative-search","text":"The fourth method is an interpolative search of an ordered list. This uses the relative magnitude of values to interpolate between them to find the likely location of the key. If we have a list of 100 numbers and we know that the first number in the list is one and the last number in the list is 100. If we were looking for the number 20 we could guess that our target number is probably closer to the front of the list. In fact the most likely position is probably 20% of the way through the list. We have interpolated the likely location of the number. If we are wrong we can see if we are too high or too low and adjust our range and recalculate the most likely position of the number based on the new range. The equation for interpolating the likely position of the target is The overall algorithm for interpolative search is very similar to binary search. Here is the pseuodocode for a binary search. Find the low, high indices of the list Find the interpolated index (make sure you don't divide by 0) While we haven't found the element (and still have indices to search) If the target is at the interpolated index Return True we've found it Otherwise if the target is greater than the value at the middle index Set the high index to the interpolated index **minus 1** Otherwise if the target is smaller than the value at the middle index Set the low index to the interpolated index **plus 1** Update the interpolated index (make sure you don't divide by 0) Return False we didn't find it There are a couple of differences between binary search and interpolated search that we should highlight. The first is that there is the possibility that our equation for calculating the position could include a division by 0 if the lst[lo] == lst[hi] . It is important that you handle this case smoothly. Another difference is that we are not setting hi or lo to the interpolated index, but are instead subtracting or adding one so that we make sure that we alter our range each time through the loop. The final difference will be in when to end the while loop. The loop will end when the lo is no longer less than hi and while the value of the target is still between the values at indices lo and hi. You will complete this search in python as part of assignment 2.","title":"Interpolative search"},{"location":"02.2_Algorithm_Analysis/00_index/","text":"Algorithm Analysis Introduction Big O Notation What order is linear search? What order is binary search? O(log n) vs O(n) Common Algorithm Orders [11:22]","title":"Contents"},{"location":"02.2_Algorithm_Analysis/00_index/#algorithm-analysis","text":"Introduction Big O Notation What order is linear search? What order is binary search? O(log n) vs O(n) Common Algorithm Orders [11:22]","title":"Algorithm Analysis"},{"location":"02.2_Algorithm_Analysis/01_Introduction/","text":"Introduction The goal of algorithm analysis is to understand the performance of a particular algorithm. If you think back to the very beginning of CPSC 128 you may recall that the best algorithm is the one that makes most efficient use of the computational resources at hand, and that those computational resources are processor time and storage space. Algorithm analysis tries to characterize the performance of a particular algorithm in terms of its usage of those two resources. Furthermore it aims to describe not just the typical performance, but also to establish the best-case and worst-case performances. That performance can be estimated through theoretical analyses, i.e. calculations based on the source code, or, empirical evidence of actual timings of program execution. Each method has strengths and weaknesses. Theoretical analysis is more prone to human error in performing the analysis, whereas the empirical approach produces reproducible numbers for the run time and memory utilization. On the other hand the theoretical analysis often leads to a more general description of the behaviour than we can arrive at through timings because the timings can depend on the particular data used in the run. We will make use of both approaches during this course.","title":"Introduction"},{"location":"02.2_Algorithm_Analysis/01_Introduction/#introduction","text":"The goal of algorithm analysis is to understand the performance of a particular algorithm. If you think back to the very beginning of CPSC 128 you may recall that the best algorithm is the one that makes most efficient use of the computational resources at hand, and that those computational resources are processor time and storage space. Algorithm analysis tries to characterize the performance of a particular algorithm in terms of its usage of those two resources. Furthermore it aims to describe not just the typical performance, but also to establish the best-case and worst-case performances. That performance can be estimated through theoretical analyses, i.e. calculations based on the source code, or, empirical evidence of actual timings of program execution. Each method has strengths and weaknesses. Theoretical analysis is more prone to human error in performing the analysis, whereas the empirical approach produces reproducible numbers for the run time and memory utilization. On the other hand the theoretical analysis often leads to a more general description of the behaviour than we can arrive at through timings because the timings can depend on the particular data used in the run. We will make use of both approaches during this course.","title":"Introduction"},{"location":"02.2_Algorithm_Analysis/02_Big_O_notation/","text":"Big O Notation Regardless of the method of analysis, the most common way to summarize the performance of an algorithm is through Big O notation. Big O notation describes the growth rate of the time or space an algorithm requires as the problem increases in size. What do we mean by the size of the problem? Intuitively we mean the number of things it involves. In a payroll system the size might be the number of employees, in a general database system, the number of records in the system, for Google the number of web pages in the world. More concretely, for our current problem, searching a list, it is best measured by the number of items in the list, n .","title":"Big O Notation"},{"location":"02.2_Algorithm_Analysis/02_Big_O_notation/#big-o-notation","text":"Regardless of the method of analysis, the most common way to summarize the performance of an algorithm is through Big O notation. Big O notation describes the growth rate of the time or space an algorithm requires as the problem increases in size. What do we mean by the size of the problem? Intuitively we mean the number of things it involves. In a payroll system the size might be the number of employees, in a general database system, the number of records in the system, for Google the number of web pages in the world. More concretely, for our current problem, searching a list, it is best measured by the number of items in the list, n .","title":"Big O Notation"},{"location":"02.2_Algorithm_Analysis/03_Linear_search/","text":"What Order is Linear Search? Let\u2019s try assessing the order or growth rate of our search algorithms. First consider our algorithm for the linear search of an unordered list, def lu_search(lst, target): for entry in lst: if entry == target: return True return False When the target isn\u2019t in the list it has to search the whole list before it finds out. If we double the length of the list, we double the number of entries it has to check, and therefore we double the time it will take. Similarly if we triple or quadruple the length of the list, we triple or quadruple the time it will take to discover that an item is not in the list. Because the time it takes is directly proportional to the length of the list ( n ) we say that this algorithm is \u201c order n \u201d, for which we write O( n ) . (There\u2019s the Big O.) What about an item that is in the list? Assuming the items we look for are randomly distributed in the list then we will find some near the beginning of the list, others in the middle section, and still others toward the end. The early matches and late matches should balance out though so that across a group of searches we will on average have to check half the list. This means that on average we find out if an item is in the list in around half the time it takes to find out that one isn\u2019t in the list, so hits are twice as fast as misses. When it comes to characterizing our algorithm\u2019s performance on hits it is O( n /2). Notice that even though it is twice as fast as for misses, it is still directly proportional to the length of the list, double the list and we will have to check twice as many entries (on average). Without knowing the relative frequency of hits and misses likely to occur we would probably say that overall this algorithm is O(n). One of the beauties of big O notation is that it allows for quick mental estimates. For example if linear searches of a 20,000 item dataset takes 3.6 seconds on average, you would estimate that searches of a 100,000 item database would average 5 x 3.6 = 18 seconds. Nifty eh? What about our algorithm for searching ordered lists? It takes the same time searching for targets that are present since on average it will find it after scanning half the list. But because the list is sorted it also detects absences, on average, after checking half the list. In absolute terms then it takes the same time to find things, but detects absences twice as fast. What about the order of this algorithm? Since it scans half the list (on average) for both hits and misses, the time it will take depends on the length of the list, and in fact varies directly as the length of the list. Thus this algorithm is also O( n ). To show its improved absolute performance we will write this as O( n /2) that way we are reminded that it is roughly twice as fast.","title":"What Order is Linear Search?"},{"location":"02.2_Algorithm_Analysis/03_Linear_search/#what-order-is-linear-search","text":"Let\u2019s try assessing the order or growth rate of our search algorithms. First consider our algorithm for the linear search of an unordered list, def lu_search(lst, target): for entry in lst: if entry == target: return True return False When the target isn\u2019t in the list it has to search the whole list before it finds out. If we double the length of the list, we double the number of entries it has to check, and therefore we double the time it will take. Similarly if we triple or quadruple the length of the list, we triple or quadruple the time it will take to discover that an item is not in the list. Because the time it takes is directly proportional to the length of the list ( n ) we say that this algorithm is \u201c order n \u201d, for which we write O( n ) . (There\u2019s the Big O.) What about an item that is in the list? Assuming the items we look for are randomly distributed in the list then we will find some near the beginning of the list, others in the middle section, and still others toward the end. The early matches and late matches should balance out though so that across a group of searches we will on average have to check half the list. This means that on average we find out if an item is in the list in around half the time it takes to find out that one isn\u2019t in the list, so hits are twice as fast as misses. When it comes to characterizing our algorithm\u2019s performance on hits it is O( n /2). Notice that even though it is twice as fast as for misses, it is still directly proportional to the length of the list, double the list and we will have to check twice as many entries (on average). Without knowing the relative frequency of hits and misses likely to occur we would probably say that overall this algorithm is O(n). One of the beauties of big O notation is that it allows for quick mental estimates. For example if linear searches of a 20,000 item dataset takes 3.6 seconds on average, you would estimate that searches of a 100,000 item database would average 5 x 3.6 = 18 seconds. Nifty eh? What about our algorithm for searching ordered lists? It takes the same time searching for targets that are present since on average it will find it after scanning half the list. But because the list is sorted it also detects absences, on average, after checking half the list. In absolute terms then it takes the same time to find things, but detects absences twice as fast. What about the order of this algorithm? Since it scans half the list (on average) for both hits and misses, the time it will take depends on the length of the list, and in fact varies directly as the length of the list. Thus this algorithm is also O( n ). To show its improved absolute performance we will write this as O( n /2) that way we are reminded that it is roughly twice as fast.","title":"What Order is Linear Search?"},{"location":"02.2_Algorithm_Analysis/04_Binary_search/","text":"What Order is Binary Search? What about the binary search? It\u2019s harder at first to see what the relationship is between search time and list size here. Remember from the screencast that it seemed linear for a bit when our list lengths were in the low hundreds, but we discovered when we increased the lengths that the increase in time didn\u2019t remain constant. Instead it climbed very slowly as n got larger, because each additional guess doubled the length of the list we could handle. guesses list length 1 2 2 4 3 8 4 16 5 32 6 64 7 128 8 256 9 512 10 1024 11 2048 This pattern of values should be familiar to you. The list length is \u201c2 to the power of\u201d the number of guesses, or mathematically n =2 guesses . How do we describe the number of guesses though? If you think back to Grade 11 math you will recall that the word logarithm is used to describe exactly that, i.e. the power to which one number must be raised to equal another number. In this case then guesses = log 2 n . Since the number of guesses is proportional to the time it takes our code to execute we say in this case that the algorithm is O(log 2 n ) or, because computer scientistis almost always work with logs to the base 2, we will just write O(log n).","title":"What Order is Binary Search?"},{"location":"02.2_Algorithm_Analysis/04_Binary_search/#what-order-is-binary-search","text":"What about the binary search? It\u2019s harder at first to see what the relationship is between search time and list size here. Remember from the screencast that it seemed linear for a bit when our list lengths were in the low hundreds, but we discovered when we increased the lengths that the increase in time didn\u2019t remain constant. Instead it climbed very slowly as n got larger, because each additional guess doubled the length of the list we could handle. guesses list length 1 2 2 4 3 8 4 16 5 32 6 64 7 128 8 256 9 512 10 1024 11 2048 This pattern of values should be familiar to you. The list length is \u201c2 to the power of\u201d the number of guesses, or mathematically n =2 guesses . How do we describe the number of guesses though? If you think back to Grade 11 math you will recall that the word logarithm is used to describe exactly that, i.e. the power to which one number must be raised to equal another number. In this case then guesses = log 2 n . Since the number of guesses is proportional to the time it takes our code to execute we say in this case that the algorithm is O(log 2 n ) or, because computer scientistis almost always work with logs to the base 2, we will just write O(log n).","title":"What Order is Binary Search?"},{"location":"02.2_Algorithm_Analysis/05_O_log_n_vs_O_n/","text":"O(log n ) versus O( n ) To get a sense of how much better this is let\u2019s compare the rate of growth of O( n ) and O(log n ) as n goes from 1 to 1,000,000. I\u2019ll use a logarithmic scale for n so that the table won\u2019t get too long! The ratio in the rightmost column tells us how many times slower O( n ) is than O(log n ). n O(log 2 n ) O( n ) O( n ) / O(log 2 n ) 1 1 2 2 4 2 4 2 8 3 8 2.7 16 4 16 4 32 5 32 6.4 64 6 64 10.7 128 7 128 18 256 8 256 32 512 9 512 57 1,024 10 1,024 102 2,048 11 2,048 186 4,096 12 4.096 341 8,192 13 8,192 630 16,384 14 16,384 1,170 32,768 15 32,768 2,185 65,536 16 65,536 262,144 18 262,144 14,564 524,288 19 524,288 27,594 1,048,576 20 1,048,576 52,429 The striking result is that for moderate sized problems O(log n ) is thousands of times faster than O( n )! Perhaps more surprising to you will be the news that many problems would love to have a O( n ) solution, but don\u2019t because the best known solutions are worse than O( n )! What other orders are there? Order n and order log n are both common algorithmic orders, but others include O(1), O( n 2 ), O( n 3 ), O( n log n ), O(2 n ), and O( n !). This spreadsheet helps illustrate the differences.","title":"O(log n) versus O(n)"},{"location":"02.2_Algorithm_Analysis/05_O_log_n_vs_O_n/#olog-n-versus-on","text":"To get a sense of how much better this is let\u2019s compare the rate of growth of O( n ) and O(log n ) as n goes from 1 to 1,000,000. I\u2019ll use a logarithmic scale for n so that the table won\u2019t get too long! The ratio in the rightmost column tells us how many times slower O( n ) is than O(log n ). n O(log 2 n ) O( n ) O( n ) / O(log 2 n ) 1 1 2 2 4 2 4 2 8 3 8 2.7 16 4 16 4 32 5 32 6.4 64 6 64 10.7 128 7 128 18 256 8 256 32 512 9 512 57 1,024 10 1,024 102 2,048 11 2,048 186 4,096 12 4.096 341 8,192 13 8,192 630 16,384 14 16,384 1,170 32,768 15 32,768 2,185 65,536 16 65,536 262,144 18 262,144 14,564 524,288 19 524,288 27,594 1,048,576 20 1,048,576 52,429 The striking result is that for moderate sized problems O(log n ) is thousands of times faster than O( n )! Perhaps more surprising to you will be the news that many problems would love to have a O( n ) solution, but don\u2019t because the best known solutions are worse than O( n )! What other orders are there? Order n and order log n are both common algorithmic orders, but others include O(1), O( n 2 ), O( n 3 ), O( n log n ), O(2 n ), and O( n !). This spreadsheet helps illustrate the differences.","title":"O(log n) versus O(n)"},{"location":"02.2_Algorithm_Analysis/06_Algorithm_orders/","text":"Algorithm orders Sorry, your browser doesn't support embedded videos. Playback speed: 1.0x 1.5x 2.0x","title":"Algorithm orders"},{"location":"02.2_Algorithm_Analysis/06_Algorithm_orders/#algorithm-orders","text":"Sorry, your browser doesn't support embedded videos. Playback speed: 1.0x 1.5x 2.0x","title":"Algorithm orders"},{"location":"02.3_PyGame_1_Drawing/00_index/","text":"PyGame 1: Drawing on the screen Introduction Getting started with Pygame It\u2019s installed, but is Pygame actually working? Exiting Pygame more gracefully Drawing something Drawing lots of a thing Drawing lots of things Resource: The ball image","title":"Contents"},{"location":"02.3_PyGame_1_Drawing/00_index/#pygame-1-drawing-on-the-screen","text":"Introduction Getting started with Pygame It\u2019s installed, but is Pygame actually working? Exiting Pygame more gracefully Drawing something Drawing lots of a thing Drawing lots of things Resource: The ball image","title":"PyGame 1: Drawing on the screen"},{"location":"02.3_PyGame_1_Drawing/01_Introduction/","text":"Introduction So far in this course and its predecessor CPSC 128 we have been confined to producing text output to a terminal. That would have been fine in the days when all we had were text terminals, but in the age of windowing operating systems using bitmapped graphics it has looked a little primitive and unpolished. The reason we haven\u2019t dealt with bit-mapped graphics until now is that it involves details and busywork which would have detracted from the main thrust of algorithmic development, and that all the bitmapped graphics libraries are object oriented so we needed to get some experience with OOP first. I\u2019m hoping that we\u2019ve done enough programming now that the details won\u2019t confuse you, and that we\u2019ve seen enough OOP to be able to read and use an OO library. At any rate we are about to find out! The following pages should lead you through the installation of PyGame and up to drawing simple diagrams with it. In later weeks we will look at using PyGame to make things move on-screen (or at least seem to move, animation is all a con). We will continue to use the pygame library both to produce static graphical output, and to produce dynamic or animated output as the course proceeds. You should enter and run each program! The code is all in the form of images, so I\u2019m afraid you can\u2019t cut and paste it, but there is very little new code from one sample to the next, so if you just edit each file to create the next one in the sequence you won\u2019t have to do much typing, and doing so should be instructive. As you work your way through the examples look for the bright red comments each time you get to a new program. I have tried to make the code self-explanatory, and have commented each significant addition. Comments are not repeated to keep the code spare, so a feature is only described the first time it is added to the code. You will have to pay a bit more attention to notice what has been removed from one version to the next, but the comments often refer to the deletions.","title":"Introduction"},{"location":"02.3_PyGame_1_Drawing/01_Introduction/#introduction","text":"So far in this course and its predecessor CPSC 128 we have been confined to producing text output to a terminal. That would have been fine in the days when all we had were text terminals, but in the age of windowing operating systems using bitmapped graphics it has looked a little primitive and unpolished. The reason we haven\u2019t dealt with bit-mapped graphics until now is that it involves details and busywork which would have detracted from the main thrust of algorithmic development, and that all the bitmapped graphics libraries are object oriented so we needed to get some experience with OOP first. I\u2019m hoping that we\u2019ve done enough programming now that the details won\u2019t confuse you, and that we\u2019ve seen enough OOP to be able to read and use an OO library. At any rate we are about to find out! The following pages should lead you through the installation of PyGame and up to drawing simple diagrams with it. In later weeks we will look at using PyGame to make things move on-screen (or at least seem to move, animation is all a con). We will continue to use the pygame library both to produce static graphical output, and to produce dynamic or animated output as the course proceeds. You should enter and run each program! The code is all in the form of images, so I\u2019m afraid you can\u2019t cut and paste it, but there is very little new code from one sample to the next, so if you just edit each file to create the next one in the sequence you won\u2019t have to do much typing, and doing so should be instructive. As you work your way through the examples look for the bright red comments each time you get to a new program. I have tried to make the code self-explanatory, and have commented each significant addition. Comments are not repeated to keep the code spare, so a feature is only described the first time it is added to the code. You will have to pay a bit more attention to notice what has been removed from one version to the next, but the comments often refer to the deletions.","title":"Introduction"},{"location":"02.3_PyGame_1_Drawing/02_pygame_test_0/","text":"Getting started with Pygame You only need to install pygame once. It should already be installed on the lab computers. Open the Command Prompt in Windows (or the terminal on Mac and linux). The easiest way to open the Command Prompt is to open the Windows menu and start typing Command Prompt, when it appears as the top option hit enter. We can now install pygame using the p ackage i nstaller for p ython or pip for short. You can do that by typing pip install pygame in the terminal window and hitting enter. You can check that pygame has been properly installed by opening your preferred editor and importing the library with import pygame . This is what my test looked like in IDLE.","title":"Getting started with Pygame"},{"location":"02.3_PyGame_1_Drawing/02_pygame_test_0/#getting-started-with-pygame","text":"You only need to install pygame once. It should already be installed on the lab computers. Open the Command Prompt in Windows (or the terminal on Mac and linux). The easiest way to open the Command Prompt is to open the Windows menu and start typing Command Prompt, when it appears as the top option hit enter. We can now install pygame using the p ackage i nstaller for p ython or pip for short. You can do that by typing pip install pygame in the terminal window and hitting enter. You can check that pygame has been properly installed by opening your preferred editor and importing the library with import pygame . This is what my test looked like in IDLE.","title":"Getting started with Pygame"},{"location":"02.3_PyGame_1_Drawing/03_pygame_test_1/","text":"It\u2019s installed but is Pygame actually working? Run this to find out: Sample output: Not much to look at, but it\u2019s good news all the same.","title":"It\u2019s installed but is Pygame actually working?"},{"location":"02.3_PyGame_1_Drawing/03_pygame_test_1/#its-installed-but-is-pygame-actually-working","text":"Run this to find out:","title":"It\u2019s installed but is Pygame actually working?"},{"location":"02.3_PyGame_1_Drawing/03_pygame_test_1/#sample-output","text":"Not much to look at, but it\u2019s good news all the same.","title":"Sample output:"},{"location":"02.3_PyGame_1_Drawing/04_pygame_test_2/","text":"Exiting Pygame more gracefully","title":"Exiting Pygame more gracefully"},{"location":"02.3_PyGame_1_Drawing/04_pygame_test_2/#exiting-pygame-more-gracefully","text":"","title":"Exiting Pygame more gracefully"},{"location":"02.3_PyGame_1_Drawing/05_pygame_test_3/","text":"Drawing something Sample output: Note Note that the pygame coordinate system (and most other graphics libraries too) places the origin in the upper left corner, has an x-axis that runs horizontally to the right, and a y-axis that runs vertically downward. This means that a pygame coordinate (x,y) refers to column x and row y which is the opposite of the way lists of lists are addressed which is (row, column) and yes this irritating and leads to bugs, so be aware!","title":"Drawing something"},{"location":"02.3_PyGame_1_Drawing/05_pygame_test_3/#drawing-something","text":"","title":"Drawing something"},{"location":"02.3_PyGame_1_Drawing/05_pygame_test_3/#sample-output","text":"","title":"Sample output:"},{"location":"02.3_PyGame_1_Drawing/05_pygame_test_3/#note","text":"Note that the pygame coordinate system (and most other graphics libraries too) places the origin in the upper left corner, has an x-axis that runs horizontally to the right, and a y-axis that runs vertically downward. This means that a pygame coordinate (x,y) refers to column x and row y which is the opposite of the way lists of lists are addressed which is (row, column) and yes this irritating and leads to bugs, so be aware!","title":"Note"},{"location":"02.3_PyGame_1_Drawing/06_pygame_test_4/","text":"Drawing lots of a thing The nice about using a programming language to do your drawing is that if you want to draw a lot of something you can have the program do it rather than manually doing a lot of clicking and dragging. (This is the point of Problem 3 on the assignment). Be sure to try the change suggested in the comment. Try some others of your own too. Sample output:","title":"Drawing lots of a thing"},{"location":"02.3_PyGame_1_Drawing/06_pygame_test_4/#drawing-lots-of-a-thing","text":"The nice about using a programming language to do your drawing is that if you want to draw a lot of something you can have the program do it rather than manually doing a lot of clicking and dragging. (This is the point of Problem 3 on the assignment). Be sure to try the change suggested in the comment. Try some others of your own too.","title":"Drawing lots of a thing"},{"location":"02.3_PyGame_1_Drawing/06_pygame_test_4/#sample-output","text":"","title":"Sample output:"},{"location":"02.3_PyGame_1_Drawing/07_pygame_test_5/","text":"Drawing lots of things There\u2019s more to graphics than circles, and pygame provides a full suite of image creation commands. Sample output:","title":"Drawing lots of things"},{"location":"02.3_PyGame_1_Drawing/07_pygame_test_5/#drawing-lots-of-things","text":"There\u2019s more to graphics than circles, and pygame provides a full suite of image creation commands.","title":"Drawing lots of things"},{"location":"02.3_PyGame_1_Drawing/07_pygame_test_5/#sample-output","text":"","title":"Sample output:"},{"location":"03.1_Recursion/00_index/","text":"Recursion Recursion by example Recursion Through a List Calculating Factorials Recursve Binary Search Recursive Data Structure recursion.py: Recursion examples Summary Notes","title":"Contents"},{"location":"03.1_Recursion/00_index/#recursion","text":"Recursion by example Recursion Through a List Calculating Factorials Recursve Binary Search Recursive Data Structure recursion.py: Recursion examples Summary Notes","title":"Recursion"},{"location":"03.1_Recursion/01_Recursion_by_example/","text":"Recursion by Example Recursion is the repeated application of some procedure. This is a form of iteration (like our while and for loops), it is something that our programs repeat multiple times. Recursion occurs when a function calls itself, which causes the function to run repeatedly. Below is a very simple application of recursion. WARNING - this code fragment causes an infinite loop, so if you run it be ready to hit ctrl-C to cancel the program. # Be ready with Ctrl-C as soon as you press F5! def printer(): print('Hi') printer() printer() This function will start running, print 'Hi' , and then calls itself. Then that will start running, print 'Hi' , then calls itself, which will start running... You get the idea. The call to itself inside of the function is what makes this a recursive function. The result of this function is that will it keeps printing 'Hi' forever (or until you cancel it). That is because there is no reason for this program to ever end. We've found an infinite loop! If you run and cancel this program you'll notice something interesting about the Traceback (angry red text). This tells us what was running when the program was cancelled. You will notice that the message is very long, and lists the same file, line, and function repeatedly. You may also get the message 'RecursionError: maximum recursion depth exceeded'. The reason for this is that each time we call the function we are pausing the current function and beginnng a new version of the function. The state information of the current call (i.e. the values of the local variables) is pushed onto a stack (like appending to the end of a list). In essence this results in many copies of the function stored on the stack that all needed to be cancelled. There was one copy of printer running for every 'Hi' that was printed. Some programming languages only use resursion for iteration, and don't have anything like a while loop or a for loop defined. Recursion can be a very powerful and very simple way of expressing some algorithms. To use recursion effectively we need to define functions that exit elegantly and don't cause infinite loops.","title":"Recursion by Example"},{"location":"03.1_Recursion/01_Recursion_by_example/#recursion-by-example","text":"Recursion is the repeated application of some procedure. This is a form of iteration (like our while and for loops), it is something that our programs repeat multiple times. Recursion occurs when a function calls itself, which causes the function to run repeatedly. Below is a very simple application of recursion. WARNING - this code fragment causes an infinite loop, so if you run it be ready to hit ctrl-C to cancel the program. # Be ready with Ctrl-C as soon as you press F5! def printer(): print('Hi') printer() printer() This function will start running, print 'Hi' , and then calls itself. Then that will start running, print 'Hi' , then calls itself, which will start running... You get the idea. The call to itself inside of the function is what makes this a recursive function. The result of this function is that will it keeps printing 'Hi' forever (or until you cancel it). That is because there is no reason for this program to ever end. We've found an infinite loop! If you run and cancel this program you'll notice something interesting about the Traceback (angry red text). This tells us what was running when the program was cancelled. You will notice that the message is very long, and lists the same file, line, and function repeatedly. You may also get the message 'RecursionError: maximum recursion depth exceeded'. The reason for this is that each time we call the function we are pausing the current function and beginnng a new version of the function. The state information of the current call (i.e. the values of the local variables) is pushed onto a stack (like appending to the end of a list). In essence this results in many copies of the function stored on the stack that all needed to be cancelled. There was one copy of printer running for every 'Hi' that was printed. Some programming languages only use resursion for iteration, and don't have anything like a while loop or a for loop defined. Recursion can be a very powerful and very simple way of expressing some algorithms. To use recursion effectively we need to define functions that exit elegantly and don't cause infinite loops.","title":"Recursion by Example"},{"location":"03.1_Recursion/02_Recursion_through_a_list/","text":"Recursion Through a List This time we are going to write a function that prints the contents of a list. The trick with recursion is to take the next step that would take you closer to the solution. Then you just call the function again and let the next instance of the function take the next step. The first step of printing a list is to print the first item, then we can use recursion to print the rest. We do this by printing the first item and then calling the function again with the rest of the list (using slicing). def printer(lst): print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() If you run the code above you will get an 'IndexError: list index out of range'. This occurs at the end of the list when we call printer with an empty list. On the next line it tries to print(lst[0]) , and cannot because there is nothing at index 0. So the last thing we need to consider is our graceful from the recursive loop. We need to consider when we want to stop printing, which is when there is nothing left in the rest of the list to print. We can do that by double checking that we have a none empty list. def printer(lst): if lst: print(lst[0]) printer(lst[1:]) else: pass print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() The list will evaluate as False if it is an empty list. If the list is empty we don't want to do anything, so we pass . Since pass doesn't actually do anything we can take that out the else statement. def printer(lst): if lst: print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print()","title":"Recursion Through a List"},{"location":"03.1_Recursion/02_Recursion_through_a_list/#recursion-through-a-list","text":"This time we are going to write a function that prints the contents of a list. The trick with recursion is to take the next step that would take you closer to the solution. Then you just call the function again and let the next instance of the function take the next step. The first step of printing a list is to print the first item, then we can use recursion to print the rest. We do this by printing the first item and then calling the function again with the rest of the list (using slicing). def printer(lst): print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() If you run the code above you will get an 'IndexError: list index out of range'. This occurs at the end of the list when we call printer with an empty list. On the next line it tries to print(lst[0]) , and cannot because there is nothing at index 0. So the last thing we need to consider is our graceful from the recursive loop. We need to consider when we want to stop printing, which is when there is nothing left in the rest of the list to print. We can do that by double checking that we have a none empty list. def printer(lst): if lst: print(lst[0]) printer(lst[1:]) else: pass print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() The list will evaluate as False if it is an empty list. If the list is empty we don't want to do anything, so we pass . Since pass doesn't actually do anything we can take that out the else statement. def printer(lst): if lst: print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print()","title":"Recursion Through a List"},{"location":"03.1_Recursion/03_Calculating_factorials/","text":"Caculating Factorials Factorials are a mathematical notation using an exclamation mark (e.g. 4!). We solve 4! by mulitplying 4 x 3 x 2 x 1 = 24. Below are the solutions of some of the lower factorials, as well as the general solution using n. Review: What a factorial is. 1! = 1 = 1 2! = 2 x 1 = 2 3! = 3 x 2 x 1 = 6 4! = 4 x 3 x 2 x 1 = 24 5! = 5 x 4 x 3 x 2 x 1 = 120 n! = n x (n-1) x (n-2) x ... x 1 Let's first write a function using an explicite loop (no recursion) to solve factorial. The easiest way to understand how to do this is to look at the general solution and read it backwards... 1 x 2 x ... x n. We can easily do this in a for loop by looping through all the values 1 to and keeping track of the product as we go. def factorial(n): product = 1 for value in range(1, n+1): product = product * value return product print('factorial() implemented using explicit iteration:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() Let's try writing this again with a recursive approach. How could we define this function recursively? It is important to notice that 5! is equal to 5 x 4! (a recursive definition). That means that in general n! = n * (n-1)!. This provides the recursive element of our function, but we also need to consider when to stop. Looking at our table the recursion naturally stops when n == 1 , so we will use an if-else statement to make sure our function exits smoothly. def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) print('factorial() implemented using recursion:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() This solution is a good example of recursion, but it is actually inefficient because it is O(n) in calls to itself, so it uses a lot of space on the call stack.","title":"Caculating Factorials"},{"location":"03.1_Recursion/03_Calculating_factorials/#caculating-factorials","text":"Factorials are a mathematical notation using an exclamation mark (e.g. 4!). We solve 4! by mulitplying 4 x 3 x 2 x 1 = 24. Below are the solutions of some of the lower factorials, as well as the general solution using n. Review: What a factorial is. 1! = 1 = 1 2! = 2 x 1 = 2 3! = 3 x 2 x 1 = 6 4! = 4 x 3 x 2 x 1 = 24 5! = 5 x 4 x 3 x 2 x 1 = 120 n! = n x (n-1) x (n-2) x ... x 1 Let's first write a function using an explicite loop (no recursion) to solve factorial. The easiest way to understand how to do this is to look at the general solution and read it backwards... 1 x 2 x ... x n. We can easily do this in a for loop by looping through all the values 1 to and keeping track of the product as we go. def factorial(n): product = 1 for value in range(1, n+1): product = product * value return product print('factorial() implemented using explicit iteration:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() Let's try writing this again with a recursive approach. How could we define this function recursively? It is important to notice that 5! is equal to 5 x 4! (a recursive definition). That means that in general n! = n * (n-1)!. This provides the recursive element of our function, but we also need to consider when to stop. Looking at our table the recursion naturally stops when n == 1 , so we will use an if-else statement to make sure our function exits smoothly. def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) print('factorial() implemented using recursion:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() This solution is a good example of recursion, but it is actually inefficient because it is O(n) in calls to itself, so it uses a lot of space on the call stack.","title":"Caculating Factorials"},{"location":"03.1_Recursion/04_Recursive_binary_search/","text":"Recursive Binary Search Binary search is the first example that is often implemented with recursion. Remember binary search works by continually dividing the list in half and looking at only the first or second half of the list, depending on whether or not the target is higher or lower than the mid point of the current list or sublist. Each time the list is divided in half and the function repeats the steps. This sounds very recursive. The algorithm will divide the list in half and call itself recursively, either with the first half of the list or the second half of the list. The last thing we need to consider is when to stop. There are actually two stop conditions: 1. When we've found the target. 2. When we are considering an empty list. Let's look at what the algorithm looks like in python. def bin_search(lst, target): if not lst: return False elif lst[len(lst)//2] == target: return True elif lst[len(lst)//2] > target: return bin_search(lst[0:len(lst)//2], target) else: return bin_search(lst[len(lst)//2+1:], target) print('bin_search():') print('3 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 3)) print('5 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 5)) print('1 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 1)) print('15 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 15)) print('2 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 2)) print('6 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 6)) print('4 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 4)) print('0 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 0)) print('20 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 20)) print() The recursive solution to this problem is in some ways simpler than what we did with explicit loops. The only tricky bits are whether the edge of the sublist should include the midpoint or not. You'll notice that we added 1 when we were looking at the second half of the list. This solution is a good example of recursion, and it is efficient because it is O(log(n)) in calls to itself. This doesn't grow quickly even when the lists get really long.","title":"Recursive Binary Search"},{"location":"03.1_Recursion/04_Recursive_binary_search/#recursive-binary-search","text":"Binary search is the first example that is often implemented with recursion. Remember binary search works by continually dividing the list in half and looking at only the first or second half of the list, depending on whether or not the target is higher or lower than the mid point of the current list or sublist. Each time the list is divided in half and the function repeats the steps. This sounds very recursive. The algorithm will divide the list in half and call itself recursively, either with the first half of the list or the second half of the list. The last thing we need to consider is when to stop. There are actually two stop conditions: 1. When we've found the target. 2. When we are considering an empty list. Let's look at what the algorithm looks like in python. def bin_search(lst, target): if not lst: return False elif lst[len(lst)//2] == target: return True elif lst[len(lst)//2] > target: return bin_search(lst[0:len(lst)//2], target) else: return bin_search(lst[len(lst)//2+1:], target) print('bin_search():') print('3 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 3)) print('5 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 5)) print('1 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 1)) print('15 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 15)) print('2 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 2)) print('6 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 6)) print('4 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 4)) print('0 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 0)) print('20 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 20)) print() The recursive solution to this problem is in some ways simpler than what we did with explicit loops. The only tricky bits are whether the edge of the sublist should include the midpoint or not. You'll notice that we added 1 when we were looking at the second half of the list. This solution is a good example of recursion, and it is efficient because it is O(log(n)) in calls to itself. This doesn't grow quickly even when the lists get really long.","title":"Recursive Binary Search"},{"location":"03.1_Recursion/05_Recursive_data_structures/","text":"Recursive Data Structures A recursive data structure is a structure that contains itself inside itself. An easy example is a list which may contain sublists (that may contain sublists etc. ). lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4]] Resursive data structures are hard to traverse with explicit loops. Imagine we wanted to navigate through the above list to find the largest number. Normally we look at the first number and say it is the largest, before looking at each item in term to see if it is larger than our current largest. If the new number is largest we say it is the largest, otherwise we do nothing and keep going. A recursive data structure interupts this search because each element could be a number or it could be a list. There is no easy way to go into a list without recursion, but with recursion it is quite straightforward. def largest(lst): While there is more list If the item is a number If it is bigger than the largest number Set it to the new largest Otherwise Call largest on the sublist Return the largest number This algorithm isn't perfect. It does not cleanly handle an empty list, but I will leave you to work on it for the next assignment. We will instead try to get the sum of all the numbers in the list and its sublists. def r_sum(lst): ''' returns the sum of all the numbers in lst and its sublists. N.B. This is quite difficult to do without recursion.''' sum = 0 for item in lst: if type(item) == type([]): sum = sum + r_sum(item) else: sum = sum + item return sum print('r_sum():') lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4]] print('The sum of [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4],[]] is', r_sum(lst)) print('The sum of [2, [[100, 7], 90], [1, 13], 8, 6] is', r_sum([2, [[100, 7], 90], [1, 13], 8, 6])) print('The sum of [2, [[13, 7], 90], [1, 100], 8, 6] is', r_sum([2, [[13, 7], 90], [1, 100], 8, 6])) print('The sum of [[[13, 7], 90], 2, [1, 100], 8, 6] is', r_sum([[[13, 7], 90], 2, [1, 100], 8, 6])) print() This solution uses a combination of an explicit loop and recursive iteration. If the next element in the list is a number we add it to our sum, and we only call the function recursively if we bump into a sublist.","title":"Recursive Data Structures"},{"location":"03.1_Recursion/05_Recursive_data_structures/#recursive-data-structures","text":"A recursive data structure is a structure that contains itself inside itself. An easy example is a list which may contain sublists (that may contain sublists etc. ). lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4]] Resursive data structures are hard to traverse with explicit loops. Imagine we wanted to navigate through the above list to find the largest number. Normally we look at the first number and say it is the largest, before looking at each item in term to see if it is larger than our current largest. If the new number is largest we say it is the largest, otherwise we do nothing and keep going. A recursive data structure interupts this search because each element could be a number or it could be a list. There is no easy way to go into a list without recursion, but with recursion it is quite straightforward. def largest(lst): While there is more list If the item is a number If it is bigger than the largest number Set it to the new largest Otherwise Call largest on the sublist Return the largest number This algorithm isn't perfect. It does not cleanly handle an empty list, but I will leave you to work on it for the next assignment. We will instead try to get the sum of all the numbers in the list and its sublists. def r_sum(lst): ''' returns the sum of all the numbers in lst and its sublists. N.B. This is quite difficult to do without recursion.''' sum = 0 for item in lst: if type(item) == type([]): sum = sum + r_sum(item) else: sum = sum + item return sum print('r_sum():') lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4]] print('The sum of [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4],[]] is', r_sum(lst)) print('The sum of [2, [[100, 7], 90], [1, 13], 8, 6] is', r_sum([2, [[100, 7], 90], [1, 13], 8, 6])) print('The sum of [2, [[13, 7], 90], [1, 100], 8, 6] is', r_sum([2, [[13, 7], 90], [1, 100], 8, 6])) print('The sum of [[[13, 7], 90], 2, [1, 100], 8, 6] is', r_sum([[[13, 7], 90], 2, [1, 100], 8, 6])) print() This solution uses a combination of an explicit loop and recursive iteration. If the next element in the list is a number we add it to our sum, and we only call the function recursively if we bump into a sublist.","title":"Recursive Data Structures"},{"location":"03.1_Recursion/06_recursion/","text":"recursion.py: Examples of recursive functions ###################### # Recursion by Example ###################### # # Here is the sample code developed during the screencast. # # I've added some more comments at few points so it comes closer to # standing on its own. # # The file is runnable. # print(78*'=','\\n', 'Recursion by Example', '\\n', 78*'-') print() ##################################### # Artificial example of infinite loop ##################################### # Be ready with Ctrl-C as soon as you press F5! ##def printer(): ## print('Hi') ## printer() ## ##printer() ####################################### # Print the items in a list recursively ####################################### def printer(lst): if lst: print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() ######################## # Calculating factorials ######################## # Review: What a factorial is. # 4! = 4 x 3 x 2 x 1 = 24 # 5! = 5 x 4 x 3 x 2 x 1 = 120 # n! = n x (n-1) x (n-2) x ... 1 # Explicit implementation of factorial # based on observation that n! = 1 x 2 x 3 x ... x n def factorial(n): product = 1 for value in range(1, n+1): product = product * value return product print('factorial() implemented using explicit iteration:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() # Recursive implementation of factorial # based on observation that n! = n x (n-1)! def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) print('factorial() implemented using recursion:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() # N.B. Space inefficient because it is O(n) in calls to itself, # so it uses a lot of space on the call stack. ############################### # Binary search using recursion ############################### def bin_search(lst, target): if not lst: return False elif lst[len(lst)//2] == target: return True elif lst[len(lst)//2] > target: return bin_search(lst[0:len(lst)//2], target) else: return bin_search(lst[len(lst)//2+1:], target) print('bin_search():') print('3 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 3)) print('5 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 5)) print('1 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 1)) print('15 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 15)) print('2 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 2)) print('6 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 6)) print('4 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 4)) print('0 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 0)) print('20 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 20)) print() # N.B. Fairly space efficient, because it is O(log n) in calls to itself, # so e.g. to search a list of 1,000,000 elements will only take 20 calls. ########################### # Recursive data structures ########################### # lst is a list that could contain other lists which could contain # other lists which could contain... def r_sum(lst): ''' returns the sum of all the numbers in lst and its sublists. N.B. This is quite difficult to do without recursion.''' sum = 0 for item in lst: if type(item) == type([]): sum = sum + r_sum(item) else: sum = sum + item return sum print('r_sum():') lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4] ] print('The sum of [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4] ] is', r_sum(lst)) print('The sum of [2, [[100, 7], 90], [1, 13], 8, 6] is', r_sum([2, [[100, 7], 90], [1, 13], 8, 6])) print('The sum of [2, [[13, 7], 90], [1, 100], 8, 6] is', r_sum([2, [[13, 7], 90], [1, 100], 8, 6])) print('The sum of [[[13, 7], 90], 2, [1, 100], 8, 6] is', r_sum([[[13, 7], 90], 2, [1, 100], 8, 6])) print() ######### # Summary ######### print(78*'-','\\n', 'S U M M A R Y', '\\n', 78*'-') print(''' Recursion SYNTAX = a function calls itself. Recursion FUNCTIONALITY = another way of iterating. TWO PARTS of a recursive function definition: BASE CASE or stopping condition (without this you have an infinite loop) how to move one STEP CLOSER to solution ''') # META: Recording dimensions = 685px x 528px","title":"recursion.py: Examples of recursive functions"},{"location":"03.1_Recursion/06_recursion/#recursionpy-examples-of-recursive-functions","text":"###################### # Recursion by Example ###################### # # Here is the sample code developed during the screencast. # # I've added some more comments at few points so it comes closer to # standing on its own. # # The file is runnable. # print(78*'=','\\n', 'Recursion by Example', '\\n', 78*'-') print() ##################################### # Artificial example of infinite loop ##################################### # Be ready with Ctrl-C as soon as you press F5! ##def printer(): ## print('Hi') ## printer() ## ##printer() ####################################### # Print the items in a list recursively ####################################### def printer(lst): if lst: print(lst[0]) printer(lst[1:]) print('printer():') print('The items in [1,2,3,4] are:') printer([1,2,3,4]) print() ######################## # Calculating factorials ######################## # Review: What a factorial is. # 4! = 4 x 3 x 2 x 1 = 24 # 5! = 5 x 4 x 3 x 2 x 1 = 120 # n! = n x (n-1) x (n-2) x ... 1 # Explicit implementation of factorial # based on observation that n! = 1 x 2 x 3 x ... x n def factorial(n): product = 1 for value in range(1, n+1): product = product * value return product print('factorial() implemented using explicit iteration:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() # Recursive implementation of factorial # based on observation that n! = n x (n-1)! def factorial(n): if n == 1: return 1 else: return n * factorial(n-1) print('factorial() implemented using recursion:') print('4! = ', factorial(4)) print('5! = ', factorial(5)) print() # N.B. Space inefficient because it is O(n) in calls to itself, # so it uses a lot of space on the call stack. ############################### # Binary search using recursion ############################### def bin_search(lst, target): if not lst: return False elif lst[len(lst)//2] == target: return True elif lst[len(lst)//2] > target: return bin_search(lst[0:len(lst)//2], target) else: return bin_search(lst[len(lst)//2+1:], target) print('bin_search():') print('3 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 3)) print('5 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 5)) print('1 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 1)) print('15 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 15)) print('2 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 2)) print('6 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 6)) print('4 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 4)) print('0 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 0)) print('20 in [1,3,5,7,9,11,13,15]?', bin_search([1,3,5,7,9,11,13,15], 20)) print() # N.B. Fairly space efficient, because it is O(log n) in calls to itself, # so e.g. to search a list of 1,000,000 elements will only take 20 calls. ########################### # Recursive data structures ########################### # lst is a list that could contain other lists which could contain # other lists which could contain... def r_sum(lst): ''' returns the sum of all the numbers in lst and its sublists. N.B. This is quite difficult to do without recursion.''' sum = 0 for item in lst: if type(item) == type([]): sum = sum + r_sum(item) else: sum = sum + item return sum print('r_sum():') lst = [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4] ] print('The sum of [ 1, 2, 3, [6, 7], 9, [2, [8, 9], 4] ] is', r_sum(lst)) print('The sum of [2, [[100, 7], 90], [1, 13], 8, 6] is', r_sum([2, [[100, 7], 90], [1, 13], 8, 6])) print('The sum of [2, [[13, 7], 90], [1, 100], 8, 6] is', r_sum([2, [[13, 7], 90], [1, 100], 8, 6])) print('The sum of [[[13, 7], 90], 2, [1, 100], 8, 6] is', r_sum([[[13, 7], 90], 2, [1, 100], 8, 6])) print() ######### # Summary ######### print(78*'-','\\n', 'S U M M A R Y', '\\n', 78*'-') print(''' Recursion SYNTAX = a function calls itself. Recursion FUNCTIONALITY = another way of iterating. TWO PARTS of a recursive function definition: BASE CASE or stopping condition (without this you have an infinite loop) how to move one STEP CLOSER to solution ''') # META: Recording dimensions = 685px x 528px","title":"recursion.py: Examples of recursive functions"},{"location":"03.1_Recursion/07_Notes/","text":"Recursion: Notes Recursion offers an alternative mechanism for repetition. Alternative to explicit looping constructs like for and while . The key to desigining a recursive function is to stop thinking about writing a function that does the whole job, and to start thinking about a function that just, a. knows the next specific step to take to move toward the answer, and b. can tell when there\u2019s no point in trying. b. above is the stopping condition and without one you may well create an infinite loop. See e.g. the first example in Recursion by Example . Each recursive call starts a new execution of the function code. The state information of the current call (i.e. the values of the local variables) is pushed onto a stack (like appending to the end of a list). When the called instance terminates, the caller is restarted and its local state is popped off the stack to remember \u201cwhere it was\u201d. If you have started ten instances of a function, then there are 9 packages of state piled on the stack waiting to be popped off as paused invocations are restarted. The recursion call stack is large but not infinite: typically a thousand or so entries. You can make it larger (or smaller), but shouldn\u2019t generally want to. Recursion can be direct in which a function calls itself, or indirect in which one function, say A, calls another, B, which then calls A, which calls B, which calls A,... We are seeing recursion now because it simplifies the implementation of some algorithms we are about to encounter, i.e. quicksort and heapsort. Recursion is most helpful when dealing with recursive data structures. For example in a binary tree each part of the tree is itself a binary tree. .","title":"Recursion: Notes"},{"location":"03.1_Recursion/07_Notes/#recursion-notes","text":"Recursion offers an alternative mechanism for repetition. Alternative to explicit looping constructs like for and while . The key to desigining a recursive function is to stop thinking about writing a function that does the whole job, and to start thinking about a function that just, a. knows the next specific step to take to move toward the answer, and b. can tell when there\u2019s no point in trying. b. above is the stopping condition and without one you may well create an infinite loop. See e.g. the first example in Recursion by Example . Each recursive call starts a new execution of the function code. The state information of the current call (i.e. the values of the local variables) is pushed onto a stack (like appending to the end of a list). When the called instance terminates, the caller is restarted and its local state is popped off the stack to remember \u201cwhere it was\u201d. If you have started ten instances of a function, then there are 9 packages of state piled on the stack waiting to be popped off as paused invocations are restarted. The recursion call stack is large but not infinite: typically a thousand or so entries. You can make it larger (or smaller), but shouldn\u2019t generally want to. Recursion can be direct in which a function calls itself, or indirect in which one function, say A, calls another, B, which then calls A, which calls B, which calls A,... We are seeing recursion now because it simplifies the implementation of some algorithms we are about to encounter, i.e. quicksort and heapsort. Recursion is most helpful when dealing with recursive data structures. For example in a binary tree each part of the tree is itself a binary tree. .","title":"Recursion: Notes"},{"location":"03.2_File_Processing/00_index/","text":"Working with Text Files Context: Persistence Text versus binary files Reading from text files Example: Searching log files N.B. Files are sequential Is there more? Writing to text files Appending to files Reading numeric data","title":"Contents"},{"location":"03.2_File_Processing/00_index/#working-with-text-files","text":"Context: Persistence Text versus binary files Reading from text files Example: Searching log files N.B. Files are sequential Is there more? Writing to text files Appending to files Reading numeric data","title":"Working with Text Files"},{"location":"03.2_File_Processing/01_Persistence/","text":"Persistence So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet In this module we will consider the first two options.","title":"Persistence"},{"location":"03.2_File_Processing/01_Persistence/#persistence","text":"So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet In this module we will consider the first two options.","title":"Persistence"},{"location":"03.2_File_Processing/02_Text_vs_binary_files/","text":"Text versus Binary Files Files on disk are always just sequences of bytes so how can there be two types, text and binary? The difference between text and binary files is not a physical difference on disk, but a difference in the way those bytes are_interpreted_ Consider storing the two dimensional coordinate (12, 31) to disk. Storing it as text would be in essence to print it to a file (instead of the screen). We can visualize the file contents to be, ------------------------- | 1 | 2 | , | 3 | 1 | EOF | ------------------------- where EOF is the character used to mark the end of a file. (The actual character used for the end of file marker is operating system dependent.) Of course what is actually written to disk are the ASCII values of those characters, so what is on disk is, 49 50 44 51 49 26 To be even more precise the values will be stored in binary so the disk contents will be, 00110001 00110010 00101100 00110011 00110001 00011010 Thank goodness the computer can read it! What about storing it in a binary file? In this case we will write the binary representations of the numbers 12 and 31 to disk in sequence. The number of bytes used to do this on disk varies from 1 to 8, but using typical four byte representations we would write the following to disk: 00000000 00000000 00000000 00001100 00000000 00000000 00000000 00011111 00011010 As you can see both files have binary representations on disk so why do we call the first text and only the second binary? Because to be meaningful each should be interpreted differently. We call the first a text file because its bits should be interpreted as giving the ASCII values of text characters. We call the second binary because its bits should be read in four bytes at a time and interpreted as integer values. Notice that it doesn't say this inside the files. That knowledge has to be built into the suite of programs that create and manipulate the files. Note that either representation could be read in as either text, i.e. a sequence of bytes corresponding to ASCII codes of characters, or binary, i.e. a pair of 4-byte wide integers, but that in each case the wrong interpretation produces nonsense. So knowing the correct interpretation is crucial. In everyday computing you can often tell which interpretation is correct by displaying some of the file to a terminal, or opening it in a 'pure' text editor, e.g. the IDLE editor. Here's a dump of a small Python program to a terminal, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat s2bin.py # s2bin.py # Converts from a string to its binary representation. HEXBIN ={\"0\":\"0000\", \"1\":\"0001\", \"2\":\"0010\", \"3\":\"0011\", \"4\":\"0100\", \"5\":\"0101\", \"6\":\"0110\", \"7\":\"0111\", \"8\":\"1000\", \"9\":\"1001\", \"A\":\"1010\", \"B\":\"1011\", \"C\":\"1100\", \"D\":\"1101\", \"E\":\"1110\", \"F\":\"1111\"} s = '112,31' for c in s: n = ord(c) print() \"\".join([HEXBIN[i] for i in '%X'%n]) ) ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ And here's a partial dump of an MS Word document, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat MSWordFile.doc DI\u25c4\u00e0\u00a1\u00b1\u2192\u00e1 > \u2665 _\u00ff \u2660 \u263a * \u25ba , \u263a _\u00ff\u00ff\u00ff ) \u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ec\u00a5A %` \u2666 d\u2195\u00bf \u25ba \u2660 / \u266b bjbjN\u00e0N\u00e0 \u2666 \u25ac .\u25ba ,S\u263a ,S\u263a / \u00ff\u00ff \u00ff\u00ff \u00ff\u00ff \u263c \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00b6 ,\u2665 \u00fc\u2665 \u00fc \u2665 \u00fc\u2665 \u00fc\u2665 \u2640 \u2666 \u2640 ,\u2665 \u2640\u2660 o \u2666 \u2666 \u2666 \u2666 \u2666\u00fb \u2666 \u00fb\u2666 \u00fb\u2666 <\u2663 \u263b ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 $ \u2666 h\u263b l \u00aa \u00b1\u2663 \u00a7 \u263c\u2665 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u263c\u2665 \u263c\u2665 \u2666 \u2666 U \u00c6\u2663 \u25ac #\u2663 #\u2663 #\u2663 \u00fb\u2666 \u263c\u2665 \u2666 \u263c\u2665 \u2666 <\u2663 #\u2663 \u00fb \u2666 <\u2663 #\u2663 #\u2663 \u263c\u2665 \u263c\u2665 # \u2663 \u2666 \u00b6\u2666 \u2640 `l\"._A\u00c9\u263a \u00fc\u2665 \u2663 #\u2663 <\u2663 \u00dc\u2663 0 \u2640\u2660 #\u2663 \u25ac \u2663 \u25ac #\u2663 \u25ac \u263c\u2665 #\u2663 h \u00fb\u2666 \u00fb\u2666 #\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u00b1\u2663 \u2193\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u2640\u2660 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 ,\u2665 ,\u2665 ,\u2665 D \u00fc\u2665 ,\u2665 ,\u2665 ,\u2665 \u00fc \u2665 ,\u2665 ,\u2665 ,\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00ff \u00ff\u00ff\u00ff \u263b \u2640\u263a T his is a very simple one line word document. \u2660 \u266b \u00a7 - . / o\u00e9oYoOo \u00b6 As you can see it is easy to tell which file is a text file and which binary (though if you look toward the bottom of the dump of the word file you can see some text content).","title":"Text versus Binary Files"},{"location":"03.2_File_Processing/02_Text_vs_binary_files/#text-versus-binary-files","text":"Files on disk are always just sequences of bytes so how can there be two types, text and binary? The difference between text and binary files is not a physical difference on disk, but a difference in the way those bytes are_interpreted_ Consider storing the two dimensional coordinate (12, 31) to disk. Storing it as text would be in essence to print it to a file (instead of the screen). We can visualize the file contents to be, ------------------------- | 1 | 2 | , | 3 | 1 | EOF | ------------------------- where EOF is the character used to mark the end of a file. (The actual character used for the end of file marker is operating system dependent.) Of course what is actually written to disk are the ASCII values of those characters, so what is on disk is, 49 50 44 51 49 26 To be even more precise the values will be stored in binary so the disk contents will be, 00110001 00110010 00101100 00110011 00110001 00011010 Thank goodness the computer can read it! What about storing it in a binary file? In this case we will write the binary representations of the numbers 12 and 31 to disk in sequence. The number of bytes used to do this on disk varies from 1 to 8, but using typical four byte representations we would write the following to disk: 00000000 00000000 00000000 00001100 00000000 00000000 00000000 00011111 00011010 As you can see both files have binary representations on disk so why do we call the first text and only the second binary? Because to be meaningful each should be interpreted differently. We call the first a text file because its bits should be interpreted as giving the ASCII values of text characters. We call the second binary because its bits should be read in four bytes at a time and interpreted as integer values. Notice that it doesn't say this inside the files. That knowledge has to be built into the suite of programs that create and manipulate the files. Note that either representation could be read in as either text, i.e. a sequence of bytes corresponding to ASCII codes of characters, or binary, i.e. a pair of 4-byte wide integers, but that in each case the wrong interpretation produces nonsense. So knowing the correct interpretation is crucial. In everyday computing you can often tell which interpretation is correct by displaying some of the file to a terminal, or opening it in a 'pure' text editor, e.g. the IDLE editor. Here's a dump of a small Python program to a terminal, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat s2bin.py # s2bin.py # Converts from a string to its binary representation. HEXBIN ={\"0\":\"0000\", \"1\":\"0001\", \"2\":\"0010\", \"3\":\"0011\", \"4\":\"0100\", \"5\":\"0101\", \"6\":\"0110\", \"7\":\"0111\", \"8\":\"1000\", \"9\":\"1001\", \"A\":\"1010\", \"B\":\"1011\", \"C\":\"1100\", \"D\":\"1101\", \"E\":\"1110\", \"F\":\"1111\"} s = '112,31' for c in s: n = ord(c) print() \"\".join([HEXBIN[i] for i in '%X'%n]) ) ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ And here's a partial dump of an MS Word document, ttopper@D1JWYSB1:~/Present/CPSC128.W13/08_Persistence $ cat MSWordFile.doc DI\u25c4\u00e0\u00a1\u00b1\u2192\u00e1 > \u2665 _\u00ff \u2660 \u263a * \u25ba , \u263a _\u00ff\u00ff\u00ff ) \u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff \u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ff\u00ec\u00a5A %` \u2666 d\u2195\u00bf \u25ba \u2660 / \u266b bjbjN\u00e0N\u00e0 \u2666 \u25ac .\u25ba ,S\u263a ,S\u263a / \u00ff\u00ff \u00ff\u00ff \u00ff\u00ff \u263c \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00b6 ,\u2665 \u00fc\u2665 \u00fc \u2665 \u00fc\u2665 \u00fc\u2665 \u2640 \u2666 \u2640 ,\u2665 \u2640\u2660 o \u2666 \u2666 \u2666 \u2666 \u2666\u00fb \u2666 \u00fb\u2666 \u00fb\u2666 <\u2663 \u263b ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 ?\u2663 $ \u2666 h\u263b l \u00aa \u00b1\u2663 \u00a7 \u263c\u2665 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u263c\u2665 \u263c\u2665 \u2666 \u2666 U \u00c6\u2663 \u25ac #\u2663 #\u2663 #\u2663 \u00fb\u2666 \u263c\u2665 \u2666 \u263c\u2665 \u2666 <\u2663 #\u2663 \u00fb \u2666 <\u2663 #\u2663 #\u2663 \u263c\u2665 \u263c\u2665 # \u2663 \u2666 \u00b6\u2666 \u2640 `l\"._A\u00c9\u263a \u00fc\u2665 \u2663 #\u2663 <\u2663 \u00dc\u2663 0 \u2640\u2660 #\u2663 \u25ac \u2663 \u25ac #\u2663 \u25ac \u263c\u2665 #\u2663 h \u00fb\u2666 \u00fb\u2666 #\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 \u00fb\u2666 \u00b1\u2663 \u00b1\u2663 \u2193\u2663 \u00fb\u2666 \u00fb\u2666 \u00fb\u2666 \u2640\u2660 \u00fb\u2666 \u00fb\u2666 \u00fb \u2666 \u00fb\u2666 ,\u2665 ,\u2665 ,\u2665 D \u00fc\u2665 ,\u2665 ,\u2665 ,\u2665 \u00fc \u2665 ,\u2665 ,\u2665 ,\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u263c\u2665 \u00ff \u00ff\u00ff\u00ff \u263b \u2640\u263a T his is a very simple one line word document. \u2660 \u266b \u00a7 - . / o\u00e9oYoOo \u00b6 As you can see it is easy to tell which file is a text file and which binary (though if you look toward the bottom of the dump of the word file you can see some text content).","title":"Text versus Binary Files"},{"location":"03.2_File_Processing/03_Reading_from_text_files/","text":"Reading from text files Here's how to read data from a text file. To begin with use IDLE to create a small test text file: We can visualize this on disk as, T h e f i r s t l i n e . \\n L i n e 2 . \\n T h e t h i r d a n d l a s t l i n e . \\n EOF The only new item here are the \\n characters These denote newline characters which like EOF characters vary between operating sytems. (Don't worry the Python you installed was compiled to know what they are on your system). There are three common ways of reading a text file like this in: One line at a time, processing lines as we go, The whole file into a string, The whole file into a list of strings, one entry per line. When possible, option 1. is preferred since it is the most memory efficient because it holds only a bit of the file (one line) in memory at any given time. Here's the Python code for each of these options. One line at a time: # file_read_1.py f = open('text_file.txt', 'r') # Open the file. for line in f: # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. f.close() # Close the file. or with a while loop... # file_read_1.py f = open('text_file.txt', 'r') # Open the file. line = f.readline() # Get the first line. while line != \"\": # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. line = f.readline() f.close() # Close the file. Notes: The arguments to the open function are the name of the file to open, and the mode in which to open it. Here the r stands for read . As you can see by the for statement, iteration over file objects is defined just as it is for lists. The default iteration is to grab one line each time. You should always close files when you are finished reading from them. The file object will be garbage collected eventually anyway and the file closed at that time, but closing ASAP reduces memory consumption and allows other processes to access the file sooner. Output: >>> The first line. Line 2. The third and last line. >>> The whole file into a string: # file_read_2.py f = open('text_file.txt', 'r') s = f.read() print('s is', len(s), 'characters long.') print(s) f.close() The read method of the file object f reads the entire file including newline characters into memory. >>> s is 49 characters long. The first line. Line 2. The third and last line. >>> Note that the file looks the same as before when displayed because the IDLE shell interprets the newline characters embedded in it as instructions to start new lines. read() can also take an integer argument specifying how many bytes to read from the file. Its default behaviour is to read all of them. The whole file into a list of strings, # file_read_3.py f = open('text_file.txt', 'r') lines = f.readlines() print(lines) f.close() Output: >>> ['The first line.\\n', 'Line 2.\\n', 'The third and last line.\\n'] >>> Note that the newline character is included. If you don't want it you need to strip it yourself.","title":"Reading from text files"},{"location":"03.2_File_Processing/03_Reading_from_text_files/#reading-from-text-files","text":"Here's how to read data from a text file. To begin with use IDLE to create a small test text file: We can visualize this on disk as, T h e f i r s t l i n e . \\n L i n e 2 . \\n T h e t h i r d a n d l a s t l i n e . \\n EOF The only new item here are the \\n characters These denote newline characters which like EOF characters vary between operating sytems. (Don't worry the Python you installed was compiled to know what they are on your system). There are three common ways of reading a text file like this in: One line at a time, processing lines as we go, The whole file into a string, The whole file into a list of strings, one entry per line. When possible, option 1. is preferred since it is the most memory efficient because it holds only a bit of the file (one line) in memory at any given time. Here's the Python code for each of these options.","title":"Reading from text files"},{"location":"03.2_File_Processing/03_Reading_from_text_files/#one-line-at-a-time","text":"# file_read_1.py f = open('text_file.txt', 'r') # Open the file. for line in f: # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. f.close() # Close the file. or with a while loop... # file_read_1.py f = open('text_file.txt', 'r') # Open the file. line = f.readline() # Get the first line. while line != \"\": # Iterate through the file a line at a time. print(line, end=\"\") # Process the current line. line = f.readline() f.close() # Close the file. Notes: The arguments to the open function are the name of the file to open, and the mode in which to open it. Here the r stands for read . As you can see by the for statement, iteration over file objects is defined just as it is for lists. The default iteration is to grab one line each time. You should always close files when you are finished reading from them. The file object will be garbage collected eventually anyway and the file closed at that time, but closing ASAP reduces memory consumption and allows other processes to access the file sooner. Output: >>> The first line. Line 2. The third and last line. >>>","title":"One line at a time:"},{"location":"03.2_File_Processing/03_Reading_from_text_files/#the-whole-file-into-a-string","text":"# file_read_2.py f = open('text_file.txt', 'r') s = f.read() print('s is', len(s), 'characters long.') print(s) f.close() The read method of the file object f reads the entire file including newline characters into memory. >>> s is 49 characters long. The first line. Line 2. The third and last line. >>> Note that the file looks the same as before when displayed because the IDLE shell interprets the newline characters embedded in it as instructions to start new lines. read() can also take an integer argument specifying how many bytes to read from the file. Its default behaviour is to read all of them.","title":"The whole file into a string:"},{"location":"03.2_File_Processing/03_Reading_from_text_files/#the-whole-file-into-a-list-of-strings","text":"# file_read_3.py f = open('text_file.txt', 'r') lines = f.readlines() print(lines) f.close() Output: >>> ['The first line.\\n', 'Line 2.\\n', 'The third and last line.\\n'] >>> Note that the newline character is included. If you don't want it you need to strip it yourself.","title":"The whole file into a list of strings,"},{"location":"03.2_File_Processing/04_Example_searching_log_files/","text":"Example: Searching log files Suppose as part of a security audit we want to display all the lines from our web server log file containing the IP address 199.247.232.110. The file name is access.log.1 and the first ten lines of the file look like this, 66.235.124.20 - - [12/Apr/2009:07:29:25 -0700] \"GET /Math130.F05/index.html HTTP/1.1\" 200 34928 \"-\" \"Mozilla/5.0 (compatible; Ask Jeeves/Teoma; +http://about.ask.com/en/docs/about/webmasters.shtml)\" 72.30.142.250 - - [12/Apr/2009:07:51:05 -0700] \"GET /Math130.F07/BayesProblems.html HTTP/1.0\" 200 2812 \"-\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 72.30.142.250 - - [12/Apr/2009:07:51:09 -0700] \"GET /Math130.F07/130.css HTTP/1.0\" 304 - \"http://ttopper.yukoncollege.yk.ca/Math130.F07/BayesProblems.html\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 216.126.125.105 - - [12/Apr/2009:08:36:00 -0700] \"GET /NCIT210.W09/05_ListsAndStrings/PlayingCards.html HTTP/1.1\" 200 20753 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 216.126.125.105 - - [12/Apr/2009:08:36:22 -0700] \"GET /NCIT210.W09/07_Dictionaries/07_Assignment.html HTTP/1.1\" 200 5817 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-27.jpg HTTP/1.1\" 200 24136 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-25.jpg HTTP/1.1\" 200 67164 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" The file is quite large, 100s of megabytes in size, so we'd rather not read it all into memory if we can avoid it so we'll use a line at a time approach. Our pseudocode looks like this, Get the name of the log file Get the name of the IP address to scan for Open the file for reading For each line in the file If the line contains the IP address Display the line and in Python we get, # ip_extractor.py fname = input('What file do you want to scan? ') ip = input('What IP address do you want to scan for? ') f = open(fname, 'r') for line in f: if line.find(ip) != -1: print(line) which produces the output, >>> What file do you want to scan? access.log.1 Waht IP address do you want to scan for? 199.247.232.110 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" ...","title":"Example: Searching log files"},{"location":"03.2_File_Processing/04_Example_searching_log_files/#example-searching-log-files","text":"Suppose as part of a security audit we want to display all the lines from our web server log file containing the IP address 199.247.232.110. The file name is access.log.1 and the first ten lines of the file look like this, 66.235.124.20 - - [12/Apr/2009:07:29:25 -0700] \"GET /Math130.F05/index.html HTTP/1.1\" 200 34928 \"-\" \"Mozilla/5.0 (compatible; Ask Jeeves/Teoma; +http://about.ask.com/en/docs/about/webmasters.shtml)\" 72.30.142.250 - - [12/Apr/2009:07:51:05 -0700] \"GET /Math130.F07/BayesProblems.html HTTP/1.0\" 200 2812 \"-\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 72.30.142.250 - - [12/Apr/2009:07:51:09 -0700] \"GET /Math130.F07/130.css HTTP/1.0\" 304 - \"http://ttopper.yukoncollege.yk.ca/Math130.F07/BayesProblems.html\" \"Mozilla/5.0 (compatible; Yahoo! Slurp/3.0; http://help.yahoo.com/help/us/ysearch/slurp)\" 216.126.125.105 - - [12/Apr/2009:08:36:00 -0700] \"GET /NCIT210.W09/05_ListsAndStrings/PlayingCards.html HTTP/1.1\" 200 20753 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 216.126.125.105 - - [12/Apr/2009:08:36:22 -0700] \"GET /NCIT210.W09/07_Dictionaries/07_Assignment.html HTTP/1.1\" 200 5817 \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-27.jpg HTTP/1.1\" 200 24136 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/10-8-25.jpg HTTP/1.1\" 200 67164 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" The file is quite large, 100s of megabytes in size, so we'd rather not read it all into memory if we can avoid it so we'll use a line at a time approach. Our pseudocode looks like this, Get the name of the log file Get the name of the IP address to scan for Open the file for reading For each line in the file If the line contains the IP address Display the line and in Python we get, # ip_extractor.py fname = input('What file do you want to scan? ') ip = input('What IP address do you want to scan for? ') f = open(fname, 'r') for line in f: if line.find(ip) != -1: print(line) which produces the output, >>> What file do you want to scan? access.log.1 Waht IP address do you want to scan for? 199.247.232.110 199.247.232.110 - - [12/Apr/2009:08:52:10 -0700] \"GET /Math101.W09/index.html HTTP/1.1\" 304 - \"-\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:00 -0700] \"GET /Math101.W09/10-8.html HTTP/1.1\" 200 2326 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/index.html\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" 199.247.232.110 - - [12/Apr/2009:08:53:01 -0700] \"GET /Math101.W09/MATH101W08.css HTTP/1.1\" 200 737 \"http://ttopper.yukoncollege.yk.ca/Math101.W09/10-8.html#25\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.19 (KHTML, like Gecko) Chrome/1.0.154.53 Safari/525.19\" ...","title":"Example: Searching log files"},{"location":"03.2_File_Processing/05_Files_are_sequential/","text":"Important note: Files are sequential One thing that is not illustrated by the examples so far is that files are sequential. They evolved from physical tape devices that only went forward, or all the way back to the beginning of the file, so you are always moving forward through a file as you read from it. Thus after doing a .read() from a file you are at the end of it and doing another .read() will not reread it, e.g. >>> f = open('text_file.txt','r') >>> s = f.read() >>> s 'The first line.\\nLine 2.\\nThe third and last line.\\n' >>> p = f.read() >>> p '' >>> f.close() >>> Note that it is not an error to try and read from the end of a file (notice that there's no error message above), you just don't get anything because there is nothing more to get (see how p is a null string above?).","title":"Important note: Files are sequential"},{"location":"03.2_File_Processing/05_Files_are_sequential/#important-note-files-are-sequential","text":"One thing that is not illustrated by the examples so far is that files are sequential. They evolved from physical tape devices that only went forward, or all the way back to the beginning of the file, so you are always moving forward through a file as you read from it. Thus after doing a .read() from a file you are at the end of it and doing another .read() will not reread it, e.g. >>> f = open('text_file.txt','r') >>> s = f.read() >>> s 'The first line.\\nLine 2.\\nThe third and last line.\\n' >>> p = f.read() >>> p '' >>> f.close() >>> Note that it is not an error to try and read from the end of a file (notice that there's no error message above), you just don't get anything because there is nothing more to get (see how p is a null string above?).","title":"Important note: Files are sequential"},{"location":"03.2_File_Processing/06_Is_there_more/","text":"Is there more? Of course there is: you can tell where you are in a text file by using its tell method, i.e. f.tell() , you can seek to a particular location in a file using f.seek( offset ) , tell if a file is open by checking its closed attribute. There is always more...but this is enough for now 1 . >>> dir(f) ['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines'] >>> If it is not enough for you, you can read more online or explore via the Python Shell, e.g. \u21a9","title":"Is there more?"},{"location":"03.2_File_Processing/06_Is_there_more/#is-there-more","text":"Of course there is: you can tell where you are in a text file by using its tell method, i.e. f.tell() , you can seek to a particular location in a file using f.seek( offset ) , tell if a file is open by checking its closed attribute. There is always more...but this is enough for now 1 . >>> dir(f) ['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines'] >>> If it is not enough for you, you can read more online or explore via the Python Shell, e.g. \u21a9","title":"Is there more?"},{"location":"03.2_File_Processing/07_Writing_to_text_files/","text":"Writing to text files The mechanics of writing to text files are very straightforward. Suppose we need to store a list of coordinates to a text file, e.g. coords = [[12, 31], [75, 19], [28, 51]] Writing them to a file could be done by code like this, # write_coords.py coords = [[12, 31], [75, 19], [28, 51]] fname = input('Name of file to create? ') f = open(fname, 'w') for coord in coords: f.write(str(coord[0]) + ' ' + str(coord[1]) + '\\n') f.close() The pattern is similar to reading from a file: We open the file, but with a mode of w for w rite. Note the wording of the prompt 'Name of file to create? ' Opening a file for writing deletes an existing file of the same name if one exists! In production code it is critical to either know you can clobber existing files, or to check whether a file name has already been used, and then prompt the user for another name if existing files shouldn't be clobbered. We direct output to the file using the file object's write method. This method wants a string argument so we need to format our coordinates accordingly ( f.write(coord[0] )) would throw an error). Note that we also have to add the newline character ourselves. When we are done we close the file. The resulting file looks like this if you open it in a text editor, e.g. IDLE, 12 31 75 19 28 51","title":"Writing to text files"},{"location":"03.2_File_Processing/07_Writing_to_text_files/#writing-to-text-files","text":"The mechanics of writing to text files are very straightforward. Suppose we need to store a list of coordinates to a text file, e.g. coords = [[12, 31], [75, 19], [28, 51]] Writing them to a file could be done by code like this, # write_coords.py coords = [[12, 31], [75, 19], [28, 51]] fname = input('Name of file to create? ') f = open(fname, 'w') for coord in coords: f.write(str(coord[0]) + ' ' + str(coord[1]) + '\\n') f.close() The pattern is similar to reading from a file: We open the file, but with a mode of w for w rite. Note the wording of the prompt 'Name of file to create? ' Opening a file for writing deletes an existing file of the same name if one exists! In production code it is critical to either know you can clobber existing files, or to check whether a file name has already been used, and then prompt the user for another name if existing files shouldn't be clobbered. We direct output to the file using the file object's write method. This method wants a string argument so we need to format our coordinates accordingly ( f.write(coord[0] )) would throw an error). Note that we also have to add the newline character ourselves. When we are done we close the file. The resulting file looks like this if you open it in a text editor, e.g. IDLE, 12 31 75 19 28 51","title":"Writing to text files"},{"location":"03.2_File_Processing/08_Appending_to_files/","text":"Appending to files If opening a file to write to it destroys an existing file by that name you might be wondering how log files work. After all they just grow as new events occur and are added to the log of events that have occurred in the past. The answer is that there is one more mode, a for a ppend which allows you to open a file to append things to it, i.e. the existing file data is not destroyed, and the insertion point is placed at the end of the file so further writes add to the existing file content.","title":"Appending to files"},{"location":"03.2_File_Processing/08_Appending_to_files/#appending-to-files","text":"If opening a file to write to it destroys an existing file by that name you might be wondering how log files work. After all they just grow as new events occur and are added to the log of events that have occurred in the past. The answer is that there is one more mode, a for a ppend which allows you to open a file to append things to it, i.e. the existing file data is not destroyed, and the insertion point is placed at the end of the file so further writes add to the existing file content.","title":"Appending to files"},{"location":"03.2_File_Processing/09_Reading_numeric_data/","text":"Reading numeric data In the examples so far we have read string data, but what if we wanted to read numerical data, e.g. to read our coordinates back in and reconstitute the list coords ? Pseudocode, Open the file Initialize coords to an empty list Read it a line at a time Split the line into parts at blanks Convert each part into an integer value Append the integer values to the list coords In Python, # read_coords.py coords = [] fname = input('Name of file to read from? ') f = open(fname, 'r') for line in f: (x_string, y_string) = line.split() coords.append([int(x_string),int(y_string)]) f.close() print('coords =', coords) A sample run: >>> Name of file to read from? test.dat coords = [[12, 31], [75, 19], [28, 51]] >>>","title":"Reading numeric data"},{"location":"03.2_File_Processing/09_Reading_numeric_data/#reading-numeric-data","text":"In the examples so far we have read string data, but what if we wanted to read numerical data, e.g. to read our coordinates back in and reconstitute the list coords ? Pseudocode, Open the file Initialize coords to an empty list Read it a line at a time Split the line into parts at blanks Convert each part into an integer value Append the integer values to the list coords In Python, # read_coords.py coords = [] fname = input('Name of file to read from? ') f = open(fname, 'r') for line in f: (x_string, y_string) = line.split() coords.append([int(x_string),int(y_string)]) f.close() print('coords =', coords) A sample run: >>> Name of file to read from? test.dat coords = [[12, 31], [75, 19], [28, 51]] >>>","title":"Reading numeric data"},{"location":"03.3_CGoL_2_Persistence/00_index/","text":"Life 2: Persistence Introduction The Goal Option 1: Store a screenshot of the universe Option 2: Store the universe array using str(u) Option 3: Store only the coordinates of live cells Option 4: Use only 1 bit per cell Python helps out: Pickling","title":"Contents"},{"location":"03.3_CGoL_2_Persistence/00_index/#life-2-persistence","text":"Introduction The Goal Option 1: Store a screenshot of the universe Option 2: Store the universe array using str(u) Option 3: Store only the coordinates of live cells Option 4: Use only 1 bit per cell Python helps out: Pickling","title":"Life 2: Persistence"},{"location":"03.3_CGoL_2_Persistence/01_Introduction/","text":"Designing file formats So if you\u2019ve got some data you want to store between runs of a program (or a set of programs), you need to write it to disk somewhere. To get it back you need to read it from disk and that means knowing what format it is in, i.e. knowing how it was written to disk. Often you are adding a program to a suite of existing software and the file formats have already been determined. Sometimes though you are in at the beginning of a project and get to decide how to write the data to disk. In this case your task is to design a file format, i.e. to decide how the relevant information should be written to disk. Generally we\u2019d like a way that is easy to code, both for reading and writing, and that is compact and thus efficient in its use of disk space. Perhaps surprisingly quite different approaches can usually be taken to storing data on disk. One accessible problem that affords different alternatives is the problem of storing the state of the universe in Conway\u2019s Game of Life so in this unit we\u2019ll consider alternative ways of storing and restoring a Life universe to and from disk.","title":"Designing file formats"},{"location":"03.3_CGoL_2_Persistence/01_Introduction/#designing-file-formats","text":"So if you\u2019ve got some data you want to store between runs of a program (or a set of programs), you need to write it to disk somewhere. To get it back you need to read it from disk and that means knowing what format it is in, i.e. knowing how it was written to disk. Often you are adding a program to a suite of existing software and the file formats have already been determined. Sometimes though you are in at the beginning of a project and get to decide how to write the data to disk. In this case your task is to design a file format, i.e. to decide how the relevant information should be written to disk. Generally we\u2019d like a way that is easy to code, both for reading and writing, and that is compact and thus efficient in its use of disk space. Perhaps surprisingly quite different approaches can usually be taken to storing data on disk. One accessible problem that affords different alternatives is the problem of storing the state of the universe in Conway\u2019s Game of Life so in this unit we\u2019ll consider alternative ways of storing and restoring a Life universe to and from disk.","title":"Designing file formats"},{"location":"03.3_CGoL_2_Persistence/02_Goal/","text":"The goal If we are running the game of life and an interesting configuration appears on screen we\u2019d like to be able to store it to disk. Later we\u2019d like to be able to restore it from disk and use it to initialize the universe. A run of our program might look like this, ================================ Welcome to Conway's Game of Life -------------------------------- Initialize (r) randomly or (f) from file? r Number of rows in universe? 8 Number of columns in universe? 8 Initial percentage of live cells? 42 @ @ - @ @ @ @ @ - @ @ @ - - - - - - - - @ - @ @ @ @ - @ @ @ @ @ @ @ - - @ @ - @ @ @ - - @ @ @ - - @ - @ @ - @ - - @ - - - @ @ - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): a - - - - - - - - - @ - - - - - - - - - - - - - - - @ @ @ - - - - - - - - - - - - - - - - - - - - - @ - @ - - - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): l Name of file to load from? test.lif - - - - - - - - - - - - - - - - - - @ @ @ - - - - - @ @ @ - - - - - @ - @ @ - - - - - - @ - - - - - - - - @ - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): m How many generations? 2 - - - - - - - - - - - @ - - - - - - @ - @ - - - - @ - - - - - - - - @ - - @ - - - - - @ @ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - @ - - - - - - @ @ - - - - - @ @ @ - - - - - - @ @ @ - - - - - - @ @ - - - - - - - - - - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): s Name of file to save to? test2.lif Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): q >>>","title":"The goal"},{"location":"03.3_CGoL_2_Persistence/02_Goal/#the-goal","text":"If we are running the game of life and an interesting configuration appears on screen we\u2019d like to be able to store it to disk. Later we\u2019d like to be able to restore it from disk and use it to initialize the universe. A run of our program might look like this, ================================ Welcome to Conway's Game of Life -------------------------------- Initialize (r) randomly or (f) from file? r Number of rows in universe? 8 Number of columns in universe? 8 Initial percentage of live cells? 42 @ @ - @ @ @ @ @ - @ @ @ - - - - - - - - @ - @ @ @ @ - @ @ @ @ @ @ @ - - @ @ - @ @ @ - - @ @ @ - - @ - @ @ - @ - - @ - - - @ @ - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): a - - - - - - - - - @ - - - - - - - - - - - - - - - @ @ @ - - - - - - - - - - - - - - - - - - - - - @ - @ - - - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): l Name of file to load from? test.lif - - - - - - - - - - - - - - - - - - @ @ @ - - - - - @ @ @ - - - - - @ - @ @ - - - - - - @ - - - - - - - - @ - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): m How many generations? 2 - - - - - - - - - - - @ - - - - - - @ - @ - - - - @ - - - - - - - - @ - - @ - - - - - @ @ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - @ - - - - - - @ @ - - - - - @ @ @ - - - - - - @ @ @ - - - - - - @ @ - - - - - - - - - - - - - - - - - - - Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): s Name of file to save to? test2.lif Options: a : Age universe one generation m : Age universe multiple generations s : Save universe to disk l : Load universe from disk q : Quit program Command (a|m|s|l|q): q >>>","title":"The goal"},{"location":"03.3_CGoL_2_Persistence/03_Option_1_Screenshot/","text":"Option 1: Store a screenshot of the universe One approach would be to \u201ctake a snapshot\u201d of the universe and store that screenshot to disk. In other words we\u2019d like the disk file to be a picture of the universe. If the universe looks like this onscreen, - - - - - - - @ - - - - - @ - - @ @ @ - - - - - - We\u2019d like to store this in the file, - - - - - \\n- - @ - - \\n- - - @ - \\n- @ @ @ - \\n- - - - - \\nEOF We can do that by copying our original display code and modifying it to open a file and then use write instead of print . One nice thing about this representation is that it could be opened in a text editor and modified to create new starting configurations for the universe. It\u2019s always nice if your file format plays well with the other tools you are using. The resulting code to write the universe to disk in this format looks much like the code to display it onscreen, but has to open the file and then use write instead of print for output. fname = input('Name of file to store universe in: ') outfile = open(fname, 'w') for row in range(U_ROWS): for col in range(U_COLS): if u[row][col] == 1: outfile.write(LIVE_CELL+' ') elif u[row][col] == 0: outfile.write(DEAD_CELL+' ') outfile.write('\\n') outfile.close() Evaluation How is this format? It is easy to write the code to write it to disk. You will have to evaluate how easy it is to write code to read it from disk once you have completed the assignment. How about the size of the representation on disk? For each cell in the universe, it stores two Bytes to disk, one for the cell and one for the space separating it from the next cell. In addition, it stores a newline character to mark the end of each row. So for an r \u00d7 c universe it uses (r \u00d7 c \u00d7 2) + r Bytes. To make this more concrete lets consider a couple of specific universe sizes: Universe size Storage Space 25 x 80 4,025 Bytes 1000 x 1000 2,001,000 Bytes We could cut the storage almost in half just by dropping the spaces we store to disk. Does this make it easier to harder to read the file in from disk? If it makes it harder, is it worth it?","title":"Option 1: Store a screenshot of the universe"},{"location":"03.3_CGoL_2_Persistence/03_Option_1_Screenshot/#option-1-store-a-screenshot-of-the-universe","text":"One approach would be to \u201ctake a snapshot\u201d of the universe and store that screenshot to disk. In other words we\u2019d like the disk file to be a picture of the universe. If the universe looks like this onscreen, - - - - - - - @ - - - - - @ - - @ @ @ - - - - - - We\u2019d like to store this in the file, - - - - - \\n- - @ - - \\n- - - @ - \\n- @ @ @ - \\n- - - - - \\nEOF We can do that by copying our original display code and modifying it to open a file and then use write instead of print . One nice thing about this representation is that it could be opened in a text editor and modified to create new starting configurations for the universe. It\u2019s always nice if your file format plays well with the other tools you are using. The resulting code to write the universe to disk in this format looks much like the code to display it onscreen, but has to open the file and then use write instead of print for output. fname = input('Name of file to store universe in: ') outfile = open(fname, 'w') for row in range(U_ROWS): for col in range(U_COLS): if u[row][col] == 1: outfile.write(LIVE_CELL+' ') elif u[row][col] == 0: outfile.write(DEAD_CELL+' ') outfile.write('\\n') outfile.close()","title":"Option 1: Store a screenshot of the universe"},{"location":"03.3_CGoL_2_Persistence/03_Option_1_Screenshot/#evaluation","text":"How is this format? It is easy to write the code to write it to disk. You will have to evaluate how easy it is to write code to read it from disk once you have completed the assignment. How about the size of the representation on disk? For each cell in the universe, it stores two Bytes to disk, one for the cell and one for the space separating it from the next cell. In addition, it stores a newline character to mark the end of each row. So for an r \u00d7 c universe it uses (r \u00d7 c \u00d7 2) + r Bytes. To make this more concrete lets consider a couple of specific universe sizes: Universe size Storage Space 25 x 80 4,025 Bytes 1000 x 1000 2,001,000 Bytes We could cut the storage almost in half just by dropping the spaces we store to disk. Does this make it easier to harder to read the file in from disk? If it makes it harder, is it worth it?","title":"Evaluation"},{"location":"03.3_CGoL_2_Persistence/04_Option_2_Python_list/","text":"Option 2: Store the universe array using str(u) You will notice when you write the code for reading in the universe in this first format on the assignment that although it is not overly long, it does involve some fussing and converting from string characters to their matching numerical values in the universe array, i.e. 0 or 1. One alternative is to take advantage of Python\u2019s built-in machinery for doing this. Look at the transcript below carefully and note that Python is able to figure out the type of the value entered and translate the input string into an object of the necessary type. >>> x = input('Gimme a value: ') Gimme a value: 4 >>> type(x) <type 'int'> >>> x = input('Gimme a value: ') Gimme a value: '4' >>> type(x) <type 'str'> >>> x = input('Gimme a value: ') Gimme a value: [1, 2, 3] >>> type(x) <type 'list'> >>> How could we leverage this ability to help us? We can store the string representation for the universe to disk by calling the list class\u2019 str method. Then when we read in the string we can trigger the evaluation method ourselves by calling the built-in eval function. Here\u2019s a little test program demonstrating this approach, u = [ [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], ] fname = input('Name of file to store universe in: ') outfile = open(fname, 'w') outfile.write(str(u)) outfile.close() infile = open(fname, 'r') input_line = infile.read() u = eval(input_line) print(u) print(type(u)) which produces this as output when it is run, Name of file to store universe in: list.txt [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]] <type 'list'> Evaluation How is this format? As you can see the code is very brief. It is easy to write if one is used to using str and eval , though hard to think of if one is not. How about the size of the representation on disk? For each cell in the universe it stores roughly three Bytes to disk, one for the cell and one each for the comma and space separating it from the next cell. (I say roughly because the last cell in each row does not have a trailing space and comma). In addition it stores four characters to separate rows: [], . Finally it uses two characters to delimit the entire list: []. So for an r \u00d7 c universe it uses r \u00d7 (c-1) \u00d7 3 + r + 4 \u00d7 (r-1) + 2 + 2 Bytes = (3c-2) \u00d7 r Bytes. To make this more concrete lets again consider a couple of specific universe sizes: Universe size Storage Space 25 x 80 5,950 Bytes 1000 x 1000 2,998,000 Bytes","title":"Option 2: Store the universe array using str(u)"},{"location":"03.3_CGoL_2_Persistence/04_Option_2_Python_list/#option-2-store-the-universe-array-using-stru","text":"You will notice when you write the code for reading in the universe in this first format on the assignment that although it is not overly long, it does involve some fussing and converting from string characters to their matching numerical values in the universe array, i.e. 0 or 1. One alternative is to take advantage of Python\u2019s built-in machinery for doing this. Look at the transcript below carefully and note that Python is able to figure out the type of the value entered and translate the input string into an object of the necessary type. >>> x = input('Gimme a value: ') Gimme a value: 4 >>> type(x) <type 'int'> >>> x = input('Gimme a value: ') Gimme a value: '4' >>> type(x) <type 'str'> >>> x = input('Gimme a value: ') Gimme a value: [1, 2, 3] >>> type(x) <type 'list'> >>> How could we leverage this ability to help us? We can store the string representation for the universe to disk by calling the list class\u2019 str method. Then when we read in the string we can trigger the evaluation method ourselves by calling the built-in eval function. Here\u2019s a little test program demonstrating this approach, u = [ [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], ] fname = input('Name of file to store universe in: ') outfile = open(fname, 'w') outfile.write(str(u)) outfile.close() infile = open(fname, 'r') input_line = infile.read() u = eval(input_line) print(u) print(type(u)) which produces this as output when it is run, Name of file to store universe in: list.txt [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]] <type 'list'>","title":"Option 2: Store the universe array using str(u)"},{"location":"03.3_CGoL_2_Persistence/04_Option_2_Python_list/#evaluation","text":"How is this format? As you can see the code is very brief. It is easy to write if one is used to using str and eval , though hard to think of if one is not. How about the size of the representation on disk? For each cell in the universe it stores roughly three Bytes to disk, one for the cell and one each for the comma and space separating it from the next cell. (I say roughly because the last cell in each row does not have a trailing space and comma). In addition it stores four characters to separate rows: [], . Finally it uses two characters to delimit the entire list: []. So for an r \u00d7 c universe it uses r \u00d7 (c-1) \u00d7 3 + r + 4 \u00d7 (r-1) + 2 + 2 Bytes = (3c-2) \u00d7 r Bytes. To make this more concrete lets again consider a couple of specific universe sizes: Universe size Storage Space 25 x 80 5,950 Bytes 1000 x 1000 2,998,000 Bytes","title":"Evaluation"},{"location":"03.3_CGoL_2_Persistence/05_Option_3_Coordinate_list/","text":"Option 3: Store only the coordinates of live cells You will have noticed when playing the online games of life (you did play them didn\u2019t you?) that the universe is usually \u201csparse\u201d, that is there are usually relatively few live cells among a great many dead ones. This is a consequence of Conway\u2019s rules: cells die easily of overcrowding so if an area becomes densely populated the cells in it quickly die off keeping overall densities low. This suggests that we may be wasting space storing all those dead cells in Options 1 and 2. Instead we should just store the locations of live cells. Our file format for the universe above would then be: 8 8 2 3 3 4 4 2 4 3 4 4 where each row after the first one records the location of a live cell in row col form, i.e.the first number gives the row of the cell and the second gives its column. What about the 8s in the first row? With this representation the file does not directly convey the size of the universe as it did in the first two options so we must explicitly state the size of the universe, it\u2019s the job of the first line of data to give the height and width of the universe. Evaluation How is this format? You will have the chance to evaluate the difficulty of reading and writing this format when you do it for this week\u2019s assignment. Evaluating the size of the representation on disk is interesting because the storage requirement of this option depends not on the size of the universe but on the number of live cells in it. For a universe less than 11 \u00d7 11 in size it uses 4 bytes per live cell (1 for row, 1 for separating space, 1 for col and 1 for line end), plus another 4 for the universe size. Generalizing: 4_n_ + 4 bytes where n gives the number of live cells. (Note that the memory storage is affected by the size of the universe just not solely determined by it. This is because more bytes are required to represent the row and column coordinates the larger the universe is. In a 1,000 \u00d7 1,000 universe most coordinates will be 3 digit numbers, e.g. (148, 763) so most lines will be 8 bytes long and the formula will become 8_n_ + 8 bytes). How does this compare with the first two options? For this specific example it uses 24 bytes. As long as the universe is sparse it will be more efficient, but for a crowded universe it will be less efficient. We can calculate the point at which it ceases to become more efficient by finding the number of live cells at which the storage for two schemes is equal. Assuming a 1,000 \u00d7 1,000 universe Option 1 will require 2,001,000 bytes, Option 2 will require 1,001,000 bytes, and Option 3\u2019s requirements will vary with the percentage of live cells: % live cells 0 5 10 15 20 25 Storage in bytes 8 400,008 800,008 1,200,008 1,600,008 2,000,008 You can see that for this size universe the break even point is around 25% live cells.","title":"Option 3: Store only the coordinates of live cells"},{"location":"03.3_CGoL_2_Persistence/05_Option_3_Coordinate_list/#option-3-store-only-the-coordinates-of-live-cells","text":"You will have noticed when playing the online games of life (you did play them didn\u2019t you?) that the universe is usually \u201csparse\u201d, that is there are usually relatively few live cells among a great many dead ones. This is a consequence of Conway\u2019s rules: cells die easily of overcrowding so if an area becomes densely populated the cells in it quickly die off keeping overall densities low. This suggests that we may be wasting space storing all those dead cells in Options 1 and 2. Instead we should just store the locations of live cells. Our file format for the universe above would then be: 8 8 2 3 3 4 4 2 4 3 4 4 where each row after the first one records the location of a live cell in row col form, i.e.the first number gives the row of the cell and the second gives its column. What about the 8s in the first row? With this representation the file does not directly convey the size of the universe as it did in the first two options so we must explicitly state the size of the universe, it\u2019s the job of the first line of data to give the height and width of the universe.","title":"Option 3: Store only the coordinates of live cells"},{"location":"03.3_CGoL_2_Persistence/05_Option_3_Coordinate_list/#evaluation","text":"How is this format? You will have the chance to evaluate the difficulty of reading and writing this format when you do it for this week\u2019s assignment. Evaluating the size of the representation on disk is interesting because the storage requirement of this option depends not on the size of the universe but on the number of live cells in it. For a universe less than 11 \u00d7 11 in size it uses 4 bytes per live cell (1 for row, 1 for separating space, 1 for col and 1 for line end), plus another 4 for the universe size. Generalizing: 4_n_ + 4 bytes where n gives the number of live cells. (Note that the memory storage is affected by the size of the universe just not solely determined by it. This is because more bytes are required to represent the row and column coordinates the larger the universe is. In a 1,000 \u00d7 1,000 universe most coordinates will be 3 digit numbers, e.g. (148, 763) so most lines will be 8 bytes long and the formula will become 8_n_ + 8 bytes). How does this compare with the first two options? For this specific example it uses 24 bytes. As long as the universe is sparse it will be more efficient, but for a crowded universe it will be less efficient. We can calculate the point at which it ceases to become more efficient by finding the number of live cells at which the storage for two schemes is equal. Assuming a 1,000 \u00d7 1,000 universe Option 1 will require 2,001,000 bytes, Option 2 will require 1,001,000 bytes, and Option 3\u2019s requirements will vary with the percentage of live cells: % live cells 0 5 10 15 20 25 Storage in bytes 8 400,008 800,008 1,200,008 1,600,008 2,000,008 You can see that for this size universe the break even point is around 25% live cells.","title":"Evaluation"},{"location":"03.3_CGoL_2_Persistence/06_Option_4_Bits/","text":"Option 4: Use only 1 bit per cell There are numerous other options, but one that often occurs to students is that since cells are either dead or alive their state could be stored using single bit rather than an entire byte. This would reduce the storage requirements by a factor of 8 in the first two options. But how to convert our universe to a sequence of bits? Here are the pieces you\u2019ll need to assemble a solution: First, the class constructor for int s allows the base of the input to be specified, e.g. >>> int(\"111\", base=2) 7 >>> int(\"10111001\", base=2) 185 >>> u = \"10111001\"*100 >>> u '10111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001' >>> int(u,base=2) 4837579098363815845901068946209539970477569763248796116365912530103321133318674247966529243769558995244870719450137841107801679631419931528891062234043935523637663342000363503198703854485041547352386384255447142614167797595816256230844381625L So we could take our universe of numerical 1s and 0s, change them to string 1s and 0s, and concatenate them all to get a very long string representation of a binary number. We could then convert this binary number to int thus compressing it: >>> len(u) 800 >>> len(str(int(u, base=2))) 241 And then write that number to a file. To load the universe from the file we read in the int value and convert it to binary, and then to a list of binary values and then to a list of lists of binary values. Hint: >>> bin(185) '0b10111001' >>> list(bin(185)) ['0', 'b', '1', '0', '1', '1', '1', '0', '0', '1'] >>> list(bin(185))[2:] ['1', '0', '1', '1', '1', '0', '0', '1'] >>> It is indeed possible to do this helped along by Python\u2019s binary operators which allow us to manipulate the bits inside bytes, but these are not a focus of the course so we will just nod at this possibility as we move on by. (There are also fussy end conditions to deal with when the universe is not a multiple of 8 in size because then our information does not exactly fill bytes). Just know that you could use individual bits to represent cells, but that doing so is fussy.","title":"Option 4: Use only 1 bit per cell"},{"location":"03.3_CGoL_2_Persistence/06_Option_4_Bits/#option-4-use-only-1-bit-per-cell","text":"There are numerous other options, but one that often occurs to students is that since cells are either dead or alive their state could be stored using single bit rather than an entire byte. This would reduce the storage requirements by a factor of 8 in the first two options. But how to convert our universe to a sequence of bits? Here are the pieces you\u2019ll need to assemble a solution: First, the class constructor for int s allows the base of the input to be specified, e.g. >>> int(\"111\", base=2) 7 >>> int(\"10111001\", base=2) 185 >>> u = \"10111001\"*100 >>> u '10111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001101110011011100110111001' >>> int(u,base=2) 4837579098363815845901068946209539970477569763248796116365912530103321133318674247966529243769558995244870719450137841107801679631419931528891062234043935523637663342000363503198703854485041547352386384255447142614167797595816256230844381625L So we could take our universe of numerical 1s and 0s, change them to string 1s and 0s, and concatenate them all to get a very long string representation of a binary number. We could then convert this binary number to int thus compressing it: >>> len(u) 800 >>> len(str(int(u, base=2))) 241 And then write that number to a file. To load the universe from the file we read in the int value and convert it to binary, and then to a list of binary values and then to a list of lists of binary values. Hint: >>> bin(185) '0b10111001' >>> list(bin(185)) ['0', 'b', '1', '0', '1', '1', '1', '0', '0', '1'] >>> list(bin(185))[2:] ['1', '0', '1', '1', '1', '0', '0', '1'] >>> It is indeed possible to do this helped along by Python\u2019s binary operators which allow us to manipulate the bits inside bytes, but these are not a focus of the course so we will just nod at this possibility as we move on by. (There are also fussy end conditions to deal with when the universe is not a multiple of 8 in size because then our information does not exactly fill bytes). Just know that you could use individual bits to represent cells, but that doing so is fussy.","title":"Option 4: Use only 1 bit per cell"},{"location":"03.3_CGoL_2_Persistence/07_Pickling/","text":"Pickling Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It\u2019s straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and it can be done with pickling. Pickling is provided by a Python module that automatically converts Python built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'w') pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'r') u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2-3 times as large as our earlier hand-rolled solutions. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the whole dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"03.3_CGoL_2_Persistence/07_Pickling/#pickling","text":"Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It\u2019s straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and it can be done with pickling. Pickling is provided by a Python module that automatically converts Python built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'w') pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'r') u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2-3 times as large as our earlier hand-rolled solutions. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the whole dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"04.1_CRUD/00_index/","text":"From Pickles on Shelves to CRUD Context: Persistence Python helps out: Pickling Python helps out more: Shelves Gotcha! Shelves update on assignment not mutation (?!) CRUD = A controller for our database The Main Event Loop","title":"Contents"},{"location":"04.1_CRUD/00_index/#from-pickles-on-shelves-to-crud","text":"Context: Persistence Python helps out: Pickling Python helps out more: Shelves Gotcha! Shelves update on assignment not mutation (?!) CRUD = A controller for our database The Main Event Loop","title":"From Pickles on Shelves to CRUD"},{"location":"04.1_CRUD/01_Persistence/","text":"Persistence So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet It is time to talk about binary files.","title":"Persistence"},{"location":"04.1_CRUD/01_Persistence/#persistence","text":"So far each run of one of our programs has been independent from the rest. Each began with a blank slate of memory working only with values input during that run of the program, and all its results were lost when the program ended. This is typical of calculation type programs in which some one-time value is calculated, but there are many other types of programs that either work on existing data, or need to store their results. For example most office applications work on long-lived documents. You may use a word processor to open the existing copy of your resume, update it and then save the new version. Game programs may wish to save the state of a game so it can be resumed later, or to record and store a high score. What these situations require is the ability to move data out of RAM, which is volatile, often reused after a program terminates and always lost when a computer is turned off, to a longer lasting, stable storage medium, i.e. to move the data from memory to disk. The technical term for this is data persistence. There are several choices for the persistence medium Local text files Local binary files Local or remote database servers Remote storage, e.g. across the internet It is time to talk about binary files.","title":"Persistence"},{"location":"04.1_CRUD/02_Pickling/","text":"Pickling Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It's straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and in fact Python provides a module that automatically converts its built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects the way pickling preserves foods). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'wb') # we use wb to indicate we are writing bytes pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'rb') # we use rb to indicate we are reading bytes u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2 to 3 times as large as our hand-rolled solutions in Options 1 and 2. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the entire dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"04.1_CRUD/02_Pickling/#pickling","text":"Recall this bit of code from writing coordinates to a file, for coord in coords: f.write(str(coord[0])+' '+str(coord[1])+'\\n') It's straightforward enough, but it feels like busywork converting numbers to strings and bundling the strings together into lines. In fact it feels like such straightforward busywork that our intuitions suggest it could be automated, and in fact Python provides a module that automatically converts its built-in types to strings that can be stored in text files. The module is whimsically called pickle (because it preserves the objects the way pickling preserves foods). Its use is straightforward: # life.py universe = [ [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0] ] import pickle f = open( 'pickled_universe.txt', 'wb') # we use wb to indicate we are writing bytes pickle.dump(universe, f) f.close() f = open('pickled_universe.txt', 'rb') # we use rb to indicate we are reading bytes u = pickle.load(f) f.close() print(u) Output: >>> [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] >>> Almost any Python object can be pickled (among the exceptions are odd ducks like sockets for network connections and file handles). Given how compact it is why would we not just always use it? The answer is that we will often use it, but not without thinking first. One reason we will sometimes avoid it is that the pickled representation is neither particularly compact nor particularly readable. pickled_universe.txt above looks like this, (lp0 (lp1 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp2 I0 aI0 aI0 aI0 aI0 aI0 aI0 aI0 aa(lp3 I0 aI0 aI0 aI1 ... and is 383 bytes in size. That makes it 2 to 3 times as large as our hand-rolled solutions in Options 1 and 2. A more subtle reason is that it can be inefficient for some data types. One common situation is to want to store a dictionary of objects to disk. The dictionary can be pickled, but then to access any individual element of the dictionary the entire dictionary must be read into memory and unpickled before the element can be accessed. If the dictionary is large this can represent a significant amount of processing time and memory. Because this use case is so common Python provides the shelve module in its standard library. A shelve is like a dictionary that is stored on disk.","title":"Pickling"},{"location":"04.1_CRUD/03_Shelves/","text":"Shelves A shelve ( Official documentation ) is like a dictionary that is stored on disk. (The name continues the canning theme begun with pickle ). The dictionary values can be any object that can be pickled. Retrieval is fast because the dictionary keys are hashed for fast retrieval. Here is an example that stores quotations into a shelve on disk. The comments should make it self-explanatory. # shelve_test.py import shelve # First here are a couple of quotes to work with. b = ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] k = ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] # Now let's create an in-RAM dictionary with the quotes in it. quotes = {} # Add the quotes to the dictionary keyed by last name. quotes['Kernighan'] = k quotes['Beck'] = b # Now let's display what we have: print('Here\\'s the dictionary:') print(quotes) print() print('Here it is again by looping through it:') for person in quotes.keys(): print(quotes[person]) print() # Now let's create a shelve and put the quotes in it. # Like a file we open it, but unlike with a file # opening a shelve is non-destructive so you can reopen it as often # as you want. quotefile = shelve.open('quotes') # Notice how the access syntax mirrors the dictionary syntax above. quotefile['Kernighan'] = k quotefile['Beck'] = b quotefile.close() # The quotes should be stored on-disk now. # Let's reopen the shelve and display the quotes. quotefile = shelve.open('quotes') print('Here\\'s the content of the shelve:') # Notice how similar this is to working with the in-memory dictionary above. for key in quotefile: print(key, ':', quotefile[key]) quotefile.close() The example shows how to store and retrieve data with the shelve, but what about deleting a stored item? Just use del dictionary[key] or in the specific example above we could use del quotefile['Beck'] to remove the Kent Beck quote. A small gotcha Brian Kernighan is a very smart guy and has said many memorable things. What if we add a second quote by him to the shelve? Well if we use the same key, i.e. his last name Kernighan , it will replace the existing quote. What to do? One view is that last name was not a good choice for the key because it is not unique to the items being stored, i.e. two items can have the same key. Another is that it is a fine key, but the values in the dictionary should be a list of the quotes by Brian Kernighan not a single list element giving one quote, i.e. the entry should be a list of lists. In either case we probably want to be able to tell if we already have any quotes by him already and we can do that using the shelve's in method, if 'Kernighan' in quotefile: # deal with it...","title":"Shelves"},{"location":"04.1_CRUD/03_Shelves/#shelves","text":"A shelve ( Official documentation ) is like a dictionary that is stored on disk. (The name continues the canning theme begun with pickle ). The dictionary values can be any object that can be pickled. Retrieval is fast because the dictionary keys are hashed for fast retrieval. Here is an example that stores quotations into a shelve on disk. The comments should make it self-explanatory. # shelve_test.py import shelve # First here are a couple of quotes to work with. b = ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] k = ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] # Now let's create an in-RAM dictionary with the quotes in it. quotes = {} # Add the quotes to the dictionary keyed by last name. quotes['Kernighan'] = k quotes['Beck'] = b # Now let's display what we have: print('Here\\'s the dictionary:') print(quotes) print() print('Here it is again by looping through it:') for person in quotes.keys(): print(quotes[person]) print() # Now let's create a shelve and put the quotes in it. # Like a file we open it, but unlike with a file # opening a shelve is non-destructive so you can reopen it as often # as you want. quotefile = shelve.open('quotes') # Notice how the access syntax mirrors the dictionary syntax above. quotefile['Kernighan'] = k quotefile['Beck'] = b quotefile.close() # The quotes should be stored on-disk now. # Let's reopen the shelve and display the quotes. quotefile = shelve.open('quotes') print('Here\\'s the content of the shelve:') # Notice how similar this is to working with the in-memory dictionary above. for key in quotefile: print(key, ':', quotefile[key]) quotefile.close() The example shows how to store and retrieve data with the shelve, but what about deleting a stored item? Just use del dictionary[key] or in the specific example above we could use del quotefile['Beck'] to remove the Kent Beck quote.","title":"Shelves"},{"location":"04.1_CRUD/03_Shelves/#a-small-gotcha","text":"Brian Kernighan is a very smart guy and has said many memorable things. What if we add a second quote by him to the shelve? Well if we use the same key, i.e. his last name Kernighan , it will replace the existing quote. What to do? One view is that last name was not a good choice for the key because it is not unique to the items being stored, i.e. two items can have the same key. Another is that it is a fine key, but the values in the dictionary should be a list of the quotes by Brian Kernighan not a single list element giving one quote, i.e. the entry should be a list of lists. In either case we probably want to be able to tell if we already have any quotes by him already and we can do that using the shelve's in method, if 'Kernighan' in quotefile: # deal with it...","title":"A small gotcha"},{"location":"04.1_CRUD/04_Shelve_gotcha/","text":"A bigger Gotcha: Shelves update on assignment not mutation WTH!? \" Shelves update on assignment not mutation. \" Shelves are mostly very easy to use, but there is one common gotcha to be aware of when you use them and that is that shelves update on assignment not mutation . There have I said it enough times? Now I'll explain it. The problem: Surprise! Consider the following transcript carefully, >>> s = shelve.open('test_shelve') >>> s['bob'] = 42 >>> s['liz']=[31] >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 42 liz : [31] >>> s['bob'] = 43 >>> s['liz'][0] = 30 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [31] The thing to notice here is that s['bob'] was changed (from 42 to 43 ), but that s['liz'] was not (it's still just [31] ). WTH? The reason is that s['bob'] was assigned to , but s['liz'] was only mutated , that is the contents of the list s['liz'] were changed, but s['liz'] itself still refers to the same list object. That object's contents may have changed but Python has no (easy and efficient) way of noticing that. So s['bob'] was assigned to and therefore updated but s['liz'] was only mutated and so was not updated, just like the phrase says: \"Shelves update on assignment not mutation\". How can we force s['liz'] to be updated? Solution 1 Open the shelve with the option writeback=True , >>> s = shelve.open('test_shelve', writeback=True) >>> s['liz'][0] = 1 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [1] But listen to the official documentation: If the optional writeback parameter is set to True, all entries accessed are cached in memory, and written back at close time; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated). * Solution 2 Mutate the object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. In other words use a temporary name to force an assignment to the keyed name happen: >>> s = shelve.open('test_shelve') >>> tmp = s['liz'] >>> tmp[0] = 2 >>> s['liz'] = tmp >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [2] Summary Fact : Shelves update on assignment, not mutation . Implication : This means that changes to shelve members that contain mutable types, e.g. lists and dictionaries, are not automatically updated to disk. Solution 1 : Open the shelve with the option writeback set to True . Drawback : If the shelve is open for long a large number of cached shelve objects will accumulate and need to be written to the shelve file when it is closed. Solution 2 : Mutate the shelve object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. Drawback : It takes some care to do this consistently. Conclusion: Use Solution 2.","title":"A bigger Gotcha: Shelves update on assignment not mutation"},{"location":"04.1_CRUD/04_Shelve_gotcha/#a-bigger-gotcha-shelves-update-on-assignment-not-mutation","text":"WTH!? \" Shelves update on assignment not mutation. \" Shelves are mostly very easy to use, but there is one common gotcha to be aware of when you use them and that is that shelves update on assignment not mutation . There have I said it enough times? Now I'll explain it.","title":"A bigger Gotcha: Shelves update on assignment not mutation"},{"location":"04.1_CRUD/04_Shelve_gotcha/#the-problem-surprise","text":"Consider the following transcript carefully, >>> s = shelve.open('test_shelve') >>> s['bob'] = 42 >>> s['liz']=[31] >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 42 liz : [31] >>> s['bob'] = 43 >>> s['liz'][0] = 30 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [31] The thing to notice here is that s['bob'] was changed (from 42 to 43 ), but that s['liz'] was not (it's still just [31] ). WTH? The reason is that s['bob'] was assigned to , but s['liz'] was only mutated , that is the contents of the list s['liz'] were changed, but s['liz'] itself still refers to the same list object. That object's contents may have changed but Python has no (easy and efficient) way of noticing that. So s['bob'] was assigned to and therefore updated but s['liz'] was only mutated and so was not updated, just like the phrase says: \"Shelves update on assignment not mutation\". How can we force s['liz'] to be updated?","title":"The problem: Surprise!"},{"location":"04.1_CRUD/04_Shelve_gotcha/#solution-1","text":"Open the shelve with the option writeback=True , >>> s = shelve.open('test_shelve', writeback=True) >>> s['liz'][0] = 1 >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [1] But listen to the official documentation: If the optional writeback parameter is set to True, all entries accessed are cached in memory, and written back at close time; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated). *","title":"Solution 1"},{"location":"04.1_CRUD/04_Shelve_gotcha/#solution-2","text":"Mutate the object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. In other words use a temporary name to force an assignment to the keyed name happen: >>> s = shelve.open('test_shelve') >>> tmp = s['liz'] >>> tmp[0] = 2 >>> s['liz'] = tmp >>> s.close() >>> s = shelve.open('test_shelve') >>> for key in s: print(key, ':', s[key]) bob : 43 liz : [2]","title":"Solution 2"},{"location":"04.1_CRUD/04_Shelve_gotcha/#summary","text":"Fact : Shelves update on assignment, not mutation . Implication : This means that changes to shelve members that contain mutable types, e.g. lists and dictionaries, are not automatically updated to disk. Solution 1 : Open the shelve with the option writeback set to True . Drawback : If the shelve is open for long a large number of cached shelve objects will accumulate and need to be written to the shelve file when it is closed. Solution 2 : Mutate the shelve object via a temporary name assigned to it and then reassign the temporary name to the shelve (i.e. keyed) name. Drawback : It takes some care to do this consistently. Conclusion: Use Solution 2.","title":"Summary"},{"location":"04.1_CRUD/05_Controller/","text":"A controller for our database \"Wait a minute! What database?\" Is that your first thought? Because it would be a fair one if you hadn't noticed that once we have a persistent dictionary-like storage, e.g. a shelve, we have a database. And if we have a database we need some way to control it. Control what exactly? The actions that get performed on that database. Those actions are most easily recalled by remembering the acronym CRUD, C reate: We need a way to create a new entry in the database. R etrieve: We need to be able to retrieve an entry in the database. U pdate: We need a way to update an existing entry in the database. D elete: We need a way to delete an entry in the database. Those are really the only things we can do with a database, though the retrieve operation is a little slippery because it's unclear what it means. Does it refer just to accessing an entry whose key you know, or does it also include finding entries that match certain criteria? Because the latter operation, searching, is a very complicated task (basically it's the problem Google is being rewarded for \"solving\"). What we'll do here is to build a little controller 1 that will let us work on our database of quotations. The pseudocode for most controllers is similar 2 , Forever Display the possible actions Get the user's choice of action Execute the code corresponding to the chosen action The Python code for CRUD operations on a shelve of quotes could look like, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) # Forever over = False while not over: # Display the possible actions print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') # Get the user's choice of action choice = input() # Execute the code corresponding to the chosen action if choice == 'c': pass elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': pass elif choice == 'q': over = True else: print('Not a valid choice!') db.close() The code is a fairly straightforward translation of the pseudocode: The Forever loop is implemented with a quit option. The possible actions are displayed using a triple quoted string to display a menu of choices. We get the user's choice via a call to input . We choose the appropriate action using an if-elif-else cascade. The pass statements are new, but they do nothing. Truly. If they do nothing why have them? Because you can't have nothing between an if and an elif or between a pair of elif s, >>> if x > 5: elif x == 5: File \"<pyshell#59>\", line 2 elif x == 5: ^ IndentationError: expected an indented block >>> The job of a pass statement is to have a statement somewhere you don't want one by 1) being a statement, but 2) doing nothing. Most languages provide a \"do nothing\" statement. They were originally included because sometimes the structure that is otherwise the natural choice would have a blank where a statement is required. The solution: create a do nothing statement to avoid having a blank slot. They are used most commonly now during program construction as I have done above. They serve as temporary stand-ins when you are writing a program from the top-down or outside-in, i.e. from the general to the specific, because you can write the overall framework and put these dummy statements in as placeholders until you are ready to write more detailed code. Here's another version with a couple of the actions filled in, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] db[lastname] = [author, text] elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') for key in db: print(key, ':', db[key]) elif choice == 'q': over = True else: print('Not a valid choice!') db.close() and a sample run, >>> What file of quotes would you like to work with? quotes Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? c Who is the author of the quote? Fred Flintstone What did they say or write? Yaba daba doo! Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Flintstone : ['Fred Flintstone', 'Yaba daba doo!'] Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? q >>> What about the other actions? Check out the assignment :-) Controllers are ubiquitous in computing. If you have a device or server you want to manipulate through software then you need a controller. \u21a9 Which may have you thinking that it should be possible to build a universal controller which with some OOP and an MVC architecture it pretty much is. OOP will be the subject of the remaining four modules of this course. MVC you can either Google or wait to study in CPSC 129. \u21a9","title":"A controller for our database"},{"location":"04.1_CRUD/05_Controller/#a-controller-for-our-database","text":"\"Wait a minute! What database?\" Is that your first thought? Because it would be a fair one if you hadn't noticed that once we have a persistent dictionary-like storage, e.g. a shelve, we have a database. And if we have a database we need some way to control it. Control what exactly? The actions that get performed on that database. Those actions are most easily recalled by remembering the acronym CRUD, C reate: We need a way to create a new entry in the database. R etrieve: We need to be able to retrieve an entry in the database. U pdate: We need a way to update an existing entry in the database. D elete: We need a way to delete an entry in the database. Those are really the only things we can do with a database, though the retrieve operation is a little slippery because it's unclear what it means. Does it refer just to accessing an entry whose key you know, or does it also include finding entries that match certain criteria? Because the latter operation, searching, is a very complicated task (basically it's the problem Google is being rewarded for \"solving\"). What we'll do here is to build a little controller 1 that will let us work on our database of quotations. The pseudocode for most controllers is similar 2 , Forever Display the possible actions Get the user's choice of action Execute the code corresponding to the chosen action The Python code for CRUD operations on a shelve of quotes could look like, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) # Forever over = False while not over: # Display the possible actions print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') # Get the user's choice of action choice = input() # Execute the code corresponding to the chosen action if choice == 'c': pass elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': pass elif choice == 'q': over = True else: print('Not a valid choice!') db.close() The code is a fairly straightforward translation of the pseudocode: The Forever loop is implemented with a quit option. The possible actions are displayed using a triple quoted string to display a menu of choices. We get the user's choice via a call to input . We choose the appropriate action using an if-elif-else cascade. The pass statements are new, but they do nothing. Truly. If they do nothing why have them? Because you can't have nothing between an if and an elif or between a pair of elif s, >>> if x > 5: elif x == 5: File \"<pyshell#59>\", line 2 elif x == 5: ^ IndentationError: expected an indented block >>> The job of a pass statement is to have a statement somewhere you don't want one by 1) being a statement, but 2) doing nothing. Most languages provide a \"do nothing\" statement. They were originally included because sometimes the structure that is otherwise the natural choice would have a blank where a statement is required. The solution: create a do nothing statement to avoid having a blank slot. They are used most commonly now during program construction as I have done above. They serve as temporary stand-ins when you are writing a program from the top-down or outside-in, i.e. from the general to the specific, because you can write the overall framework and put these dummy statements in as placeholders until you are ready to write more detailed code. Here's another version with a couple of the actions filled in, # crud_controller.py import shelve fname = input('What file of quotes would you like to work with? ') db = shelve.open(fname) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] db[lastname] = [author, text] elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') for key in db: print(key, ':', db[key]) elif choice == 'q': over = True else: print('Not a valid choice!') db.close() and a sample run, >>> What file of quotes would you like to work with? quotes Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? c Who is the author of the quote? Fred Flintstone What did they say or write? Yaba daba doo! Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? l Here are the contents of the shelve quotes : Flintstone : ['Fred Flintstone', 'Yaba daba doo!'] Beck : ['Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.'] Kernighan : ['Brian Kernighan', 'Controlling complexity is the essence of computer programming.'] Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice? q >>> What about the other actions? Check out the assignment :-) Controllers are ubiquitous in computing. If you have a device or server you want to manipulate through software then you need a controller. \u21a9 Which may have you thinking that it should be possible to build a universal controller which with some OOP and an MVC architecture it pretty much is. OOP will be the subject of the remaining four modules of this course. MVC you can either Google or wait to study in CPSC 129. \u21a9","title":"A controller for our database"},{"location":"04.1_CRUD/06_The_main_event_loop/","text":"The main event loop You've already seen it. Go back to the previous page and look at the controller code. See the main loop that awaits an event from the user to trigger each action? That's a main event loop . It's the most common pattern for interactive (as opposed to batch) programs. They wait for each event or user action, e.g. a keypress or a mouse movement, and then trigger an action based on it. Most office productivity programs (word processors, spreadsheets, etc.) spend almost all of their time waiting for the user to do something and then just follow a clear set of rules to determine what routine to fire as a result. \"The main event loop\" is just jargon, not a deep idea, but it's jargon you should know, and even use, e.g. in interviews.","title":"The main event loop"},{"location":"04.1_CRUD/06_The_main_event_loop/#the-main-event-loop","text":"You've already seen it. Go back to the previous page and look at the controller code. See the main loop that awaits an event from the user to trigger each action? That's a main event loop . It's the most common pattern for interactive (as opposed to batch) programs. They wait for each event or user action, e.g. a keypress or a mouse movement, and then trigger an action based on it. Most office productivity programs (word processors, spreadsheets, etc.) spend almost all of their time waiting for the user to do something and then just follow a clear set of rules to determine what routine to fire as a result. \"The main event loop\" is just jargon, not a deep idea, but it's jargon you should know, and even use, e.g. in interviews.","title":"The main event loop"},{"location":"04.2_MVC_1/00_index/","text":"MVC Architecture (Model, View, Controller) Introduction Step 1: Separating the Model from the Controller Step 2: The Model Step 3: The Quote Class UIDs Step 4: The Model Revisited (for testing) Step 5: Controller revisited Support file: Quote_0.py Support file: MVC_Model_0.py Support file: MVC_Controller_0.py","title":"Contents"},{"location":"04.2_MVC_1/00_index/#mvc-architecture-model-view-controller","text":"Introduction Step 1: Separating the Model from the Controller Step 2: The Model Step 3: The Quote Class UIDs Step 4: The Model Revisited (for testing) Step 5: Controller revisited Support file: Quote_0.py Support file: MVC_Model_0.py Support file: MVC_Controller_0.py","title":"MVC Architecture (Model, View, Controller)"},{"location":"04.2_MVC_1/01_Introduction/","text":"Introduction MVC is an acronym for Model, View, and Controller. MVC is an application architecture, which means it is a way of structuring an application. This is not the same thing as the algorithm, instead it is a way of organizing the algorithm. In python this is typically done with modules. MVC architecture lets programmers separate their code into distinct components that can be edited independently. MVC architecture is so useful that it has been independently discovered multiple times. One classic example of MVC arcitecture is in databases. Databases tend to be long lived (university records, medical records, library catalogues). YTG has databases that are over 50 years old that they still need to access today. How they access that data will have changed a lot in 50 years. In that time the database may not have changed significantly, but the way we interact with it has. Let's consider and example with a bank database. The database holds the financial information for all the bank clients. Originally, the only way to interact with the database would have been through batch processing where one technically savy individual would process all the transactions. There was only this one way to access the database. Later terminals could be used by tellers (and other bank employees) to process transactions. Later bank machines were added so that individuals could do there own banking. Telephone banking was briefly possible through touch-tone phones. Now we can bank online with our computers or phones. In this example the database is our model, and it may not have changed. However, the view and controller has changed multiple times. The view and the controller are often bundled (the display and the keyboard/mouse). The view is what let's the user see the model and the controller is what let's the user interact with the model. In addition to being able to edit the view and the controller without changing the model, we can also do the converse where we edit the model without changes to the view or controller. A bank could overall its database without changing the web interface that we use. Another classic example of MVC is webpage design. Wepages are often programmed using three different programming languages HTML (for content), CSS (for presentation), and Javascript (for behaviour). This could also be decribed as a model, view, and controller. To see how powerful this can be check out the CSS Zen Garden to see how the same HTML can be displayed very differently just by changing the CSS code associated with the presentation (or view). MVC architecture has many of the same strengths as object-oriented programming. In object-oriented programming changes to the system are localized, simplifying the changes and ensuring that they don't break the rest of the code. Review The model is where the content or data is represented. The view is how the content/data is displayed. The controller is how the content/data is edited. In software the view and controller are often integrated. They are sometimes separated in physical systems, for example a tv where the is responsible for the view and the remote is responsible for the controller.","title":"Introduction"},{"location":"04.2_MVC_1/01_Introduction/#introduction","text":"MVC is an acronym for Model, View, and Controller. MVC is an application architecture, which means it is a way of structuring an application. This is not the same thing as the algorithm, instead it is a way of organizing the algorithm. In python this is typically done with modules. MVC architecture lets programmers separate their code into distinct components that can be edited independently. MVC architecture is so useful that it has been independently discovered multiple times. One classic example of MVC arcitecture is in databases. Databases tend to be long lived (university records, medical records, library catalogues). YTG has databases that are over 50 years old that they still need to access today. How they access that data will have changed a lot in 50 years. In that time the database may not have changed significantly, but the way we interact with it has. Let's consider and example with a bank database. The database holds the financial information for all the bank clients. Originally, the only way to interact with the database would have been through batch processing where one technically savy individual would process all the transactions. There was only this one way to access the database. Later terminals could be used by tellers (and other bank employees) to process transactions. Later bank machines were added so that individuals could do there own banking. Telephone banking was briefly possible through touch-tone phones. Now we can bank online with our computers or phones. In this example the database is our model, and it may not have changed. However, the view and controller has changed multiple times. The view and the controller are often bundled (the display and the keyboard/mouse). The view is what let's the user see the model and the controller is what let's the user interact with the model. In addition to being able to edit the view and the controller without changing the model, we can also do the converse where we edit the model without changes to the view or controller. A bank could overall its database without changing the web interface that we use. Another classic example of MVC is webpage design. Wepages are often programmed using three different programming languages HTML (for content), CSS (for presentation), and Javascript (for behaviour). This could also be decribed as a model, view, and controller. To see how powerful this can be check out the CSS Zen Garden to see how the same HTML can be displayed very differently just by changing the CSS code associated with the presentation (or view). MVC architecture has many of the same strengths as object-oriented programming. In object-oriented programming changes to the system are localized, simplifying the changes and ensuring that they don't break the rest of the code.","title":"Introduction"},{"location":"04.2_MVC_1/01_Introduction/#review","text":"The model is where the content or data is represented. The view is how the content/data is displayed. The controller is how the content/data is edited. In software the view and controller are often integrated. They are sometimes separated in physical systems, for example a tv where the is responsible for the view and the remote is responsible for the controller.","title":"Review"},{"location":"04.2_MVC_1/02_Step_1_Identify_model/","text":"Step 1: Identify the model Let's re-examine our CRUD controller and refactor it into an object-orieted MVC architecture. We are going to start by creating the code for the view and controller. The first step will be to look through our original code and identify the parts that belong to the model, so that we can remove them from the original file. Any references to how the quotes will be stored should properly be in the model, so I will comment out those cases in the code below and replace them with something more generic and object-oriented. We will start working with a model class, that we will write later once we know what it needs to do. # import shelve # fname = input('What file of quotes would you like to work with? ') model_name = input('What model would you like to work with? ') # db = shelve.open(fname) model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] # db[lastname] = [author, text] # the general case is storing an object by a unique identifier model.create(uid, obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') # for key in db: # print(key, ':', db[key]) model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') # db.close() model.close() We commented out all of the references to shelve and added a new class Model . So far model has three methods: the create method that take adds objects to the model with a unique identifier (uid), the listall method which displays the model, and the close method which closes the connection with the model.","title":"Step 1: Identify the model"},{"location":"04.2_MVC_1/02_Step_1_Identify_model/#step-1-identify-the-model","text":"Let's re-examine our CRUD controller and refactor it into an object-orieted MVC architecture. We are going to start by creating the code for the view and controller. The first step will be to look through our original code and identify the parts that belong to the model, so that we can remove them from the original file. Any references to how the quotes will be stored should properly be in the model, so I will comment out those cases in the code below and replace them with something more generic and object-oriented. We will start working with a model class, that we will write later once we know what it needs to do. # import shelve # fname = input('What file of quotes would you like to work with? ') model_name = input('What model would you like to work with? ') # db = shelve.open(fname) model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') lastname = author[author.rfind(' ')+1:] # db[lastname] = [author, text] # the general case is storing an object by a unique identifier model.create(uid, obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') # for key in db: # print(key, ':', db[key]) model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') # db.close() model.close() We commented out all of the references to shelve and added a new class Model . So far model has three methods: the create method that take adds objects to the model with a unique identifier (uid), the listall method which displays the model, and the close method which closes the connection with the model.","title":"Step 1: Identify the model"},{"location":"04.2_MVC_1/03_Step_2_Start_the_model/","text":"Step 2: Start the model Although our controller was not supposed to know that we were using a shelve to store our data, the model will have to know. Below is a sketch of the code that will be required to run the three methods used in our controller, as well as some place holders for methods we expect to need later. # MVC_Model_0.py import shelve class Model: def __init__(self, location): self.location = location self.datastore = shelve.open(location) def create(self, uid, item): self.datastore[uid] = item def retrieve(self, uid): pass def update(self, uid, item): pass def delete(self, uid): pass def listall(self): for key in self.datastore: print(key, ':', self.datastore[key]) def close(self): self.datastore.close() if __name__ == '__main__': pass We will need to import the model into our controller with the code from MVC_Model_0 import * .","title":"Step 2: Start the model"},{"location":"04.2_MVC_1/03_Step_2_Start_the_model/#step-2-start-the-model","text":"Although our controller was not supposed to know that we were using a shelve to store our data, the model will have to know. Below is a sketch of the code that will be required to run the three methods used in our controller, as well as some place holders for methods we expect to need later. # MVC_Model_0.py import shelve class Model: def __init__(self, location): self.location = location self.datastore = shelve.open(location) def create(self, uid, item): self.datastore[uid] = item def retrieve(self, uid): pass def update(self, uid, item): pass def delete(self, uid): pass def listall(self): for key in self.datastore: print(key, ':', self.datastore[key]) def close(self): self.datastore.close() if __name__ == '__main__': pass We will need to import the model into our controller with the code from MVC_Model_0 import * .","title":"Step 2: Start the model"},{"location":"04.2_MVC_1/04_Step_3_The_quote_class/","text":"Step 3: The Quote class Now we are going to update our controller and our model so that they can handle different types of data, not just quotes. To do that we will have to go through our code and identify areas that are specific to the structure of quotes. The main change we are going to make is that we are going to ask objects in our model to generate their own unique identifier (uid). So far we've been using the author name as the uid, but there are some limitations to using the author name. The biggest one so far has been that the same author can have multiple quotes. Moving forward each object in the model is going to generate its own uid. Let's look at how that changes the code in the model. # MVC_Model_0.py import shelve class Model: def __init__(self, location): self.location = location self.datastore = shelve.open(location) def create(self, item): self.datastore[uid] = item def retrieve(self, item): pass def update(self, item): pass def delete(self, item): pass def listall(self): for key in self.datastore: print(key, ':', self.datastore[key]) def close(self): self.datastore.close() if __name__ == '__main__': pass Now that we have removed the uid from the model, we also need to edit the controller. This will change how we create new objects, and later how we retrieve, update, and delete them. In the controller we stop assuming that our model only handles quotes, and will instead create a Quote object. The new quote object will generate the uid and the create method will use the uid provided by the object quote. from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') #lastname = author[author.rfind(' ')+1:] obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close() The last thing we are going to do is create the Quote class. Quote objects will need to be intialized and displayed. When a quote is initialized it generates its own uid using hash . # Quote_0.py class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return f'[{self.uid:s}] {self.author:s}] ~ {self.text:s}' if __name__ == '__main__': q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') print(q) print(r)","title":"Step 3: The Quote class"},{"location":"04.2_MVC_1/04_Step_3_The_quote_class/#step-3-the-quote-class","text":"Now we are going to update our controller and our model so that they can handle different types of data, not just quotes. To do that we will have to go through our code and identify areas that are specific to the structure of quotes. The main change we are going to make is that we are going to ask objects in our model to generate their own unique identifier (uid). So far we've been using the author name as the uid, but there are some limitations to using the author name. The biggest one so far has been that the same author can have multiple quotes. Moving forward each object in the model is going to generate its own uid. Let's look at how that changes the code in the model. # MVC_Model_0.py import shelve class Model: def __init__(self, location): self.location = location self.datastore = shelve.open(location) def create(self, item): self.datastore[uid] = item def retrieve(self, item): pass def update(self, item): pass def delete(self, item): pass def listall(self): for key in self.datastore: print(key, ':', self.datastore[key]) def close(self): self.datastore.close() if __name__ == '__main__': pass Now that we have removed the uid from the model, we also need to edit the controller. This will change how we create new objects, and later how we retrieve, update, and delete them. In the controller we stop assuming that our model only handles quotes, and will instead create a Quote object. The new quote object will generate the uid and the create method will use the uid provided by the object quote. from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') #lastname = author[author.rfind(' ')+1:] obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the shelve', fname, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close() The last thing we are going to do is create the Quote class. Quote objects will need to be intialized and displayed. When a quote is initialized it generates its own uid using hash . # Quote_0.py class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return f'[{self.uid:s}] {self.author:s}] ~ {self.text:s}' if __name__ == '__main__': q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') print(q) print(r)","title":"Step 3: The Quote class"},{"location":"04.2_MVC_1/05_UIDs/","text":"Unique identifiers Summary Systems often need ways to uniquely identify individual objects, e.g. employees are identified by employee numbers, people by SINs, books by ISBNs. Generating them automatically while ensuring they are unique is a difficult task, but one that has been studied in depth by computer scientists. Python provides the hash() function which can hash strings and numbers. We can use this to generate uid\u2019s for objects by building a unique string representing the object and then hashing it. The idea In the everyday world most uid\u2019s are numbers (but not all, e.g. license plates). These can be generated automatically by converting the object data into numerical form and then using arithmetic operations to generate a number in the desired range, e.g. In the SHA-1 algorithm, for example, the domain is flattened\u201d and chopped\u201d into words\u201d which are then mixed\u201d with one another using carefully chosen mathematical functions. The range (hash value\u201d) is made to be a definite size, 160 bits (which may be either smaller or larger than the domain), through the use of modular division.[ ^* (Note that the size of the desired range corresponds to the largest number of objects you will be able to uniquely identify. Note also the use of modulo %) For example to assign uid\u2019s to strings we could take the index of each string letter in the alphabet and add these values up. For example \u2019cab\u2019 would be assigned the number 6 because the positions of the letters c, a and b in the alphabet are 3, 2 and 1 respectively. The obvious flaw in this simple system is that anagrams will all be assigned the same id. We can improve it by differentiating the id values by using information about the positions of the letters in the string, e.g. by raising each letter\u2019s index value to the power of its position in the string. In this case \u2019cab\u2019 gets assigned the id 3 1 + 1 2 + 2 3 = 12. Note that this is not the same as any of cab\u2019s anagrams, e.g. the id of \u2019abc\u2019 is 1 1 + 2 2 + 3 3 = 32. (Whether all strings are guaranteeed to have a unique id in this scheme is an interesting, but difficult question we will not pursue in this course.) Here\u2019s some Python code implementing this scheme, import string s = 'cab' uid = 0 for i in range(len(s)): uid += (string.ascii_letters.index(s[i])+1) ** (i+1) print(uid) One problem with this scheme is that the id numbers get large quickly as the string gets longer because of the exponentiation operation, e.g. the id for \u2019Yabbadabbadoo\u2019 is 2075941410449291L! This is worked around in practice by reducing the number arithmetically by e.g. modulo operations or bitwise \u2019folding\u2019 of the number. (Note the use of modulo again. That strange operation you learned in CPSC 128 turns out the be very useful). Jargon Functions that generate uids are called hash functions: A hash function is a reproducible method of turning some kind of data into a (relatively) small number that may serve as a digital fingerprint\u201d of the data. The algorithm chops and mixes\u201d (i.e., substitutes or transposes) the data to create such fingerprints. * One common place hash functions are encountered is in checksum\u2019s used to validate the contents of downloaded files, e.g. SHA1, SHA2 and md5sum checksums. md5sum is a computer program which calculates and verifies 128-bit MD5 hashes, as described in RFC 1321. The MD5 hash (or checksum) functions as a compact digital fingerprint of a file. It is extremely unlikely that any two non-identical files will have the same MD5 hash (although it is certainly possible). Because almost any change to a file will cause its MD5 hash to also change, the MD5 hash is commonly used to verify the integrity of files (i.e., to verify that a file has not changed as a result of file transfer, disk error, meddling, etc.). * Practical implementation In fact however it is difficult to design a uid generator (or hashing scheme as they are called) that assigns unique uids. And since others have already done that work, we\u2019ll build on it. Python has a built-in function called hash that can hash numbers and strings, e.g. >>> hash('tim') 333309873 >>> hash('shelly') 1348423469 >>> hash('misha') -1866883155 >>> hash('Misha') 527638157 >>> hash(42) 42 Note that while hash() will return values for all Python objects, apart from strings and numbers these will not usually be uids, but simply internal ids that will vary from one computer to another and even one run of the program to another. For other object types we can first create a string that uniquely represents the object and then hash the string to get a compact, unique key. For example for our quote class we can concatenate the class name, author name and quote text, and hash the resulting string, def uid(self): return hash('Quote' + self.author + self.text)","title":"Unique identifiers"},{"location":"04.2_MVC_1/05_UIDs/#unique-identifiers","text":"","title":"Unique identifiers"},{"location":"04.2_MVC_1/05_UIDs/#summary","text":"Systems often need ways to uniquely identify individual objects, e.g. employees are identified by employee numbers, people by SINs, books by ISBNs. Generating them automatically while ensuring they are unique is a difficult task, but one that has been studied in depth by computer scientists. Python provides the hash() function which can hash strings and numbers. We can use this to generate uid\u2019s for objects by building a unique string representing the object and then hashing it.","title":"Summary"},{"location":"04.2_MVC_1/05_UIDs/#the-idea","text":"In the everyday world most uid\u2019s are numbers (but not all, e.g. license plates). These can be generated automatically by converting the object data into numerical form and then using arithmetic operations to generate a number in the desired range, e.g. In the SHA-1 algorithm, for example, the domain is flattened\u201d and chopped\u201d into words\u201d which are then mixed\u201d with one another using carefully chosen mathematical functions. The range (hash value\u201d) is made to be a definite size, 160 bits (which may be either smaller or larger than the domain), through the use of modular division.[ ^* (Note that the size of the desired range corresponds to the largest number of objects you will be able to uniquely identify. Note also the use of modulo %) For example to assign uid\u2019s to strings we could take the index of each string letter in the alphabet and add these values up. For example \u2019cab\u2019 would be assigned the number 6 because the positions of the letters c, a and b in the alphabet are 3, 2 and 1 respectively. The obvious flaw in this simple system is that anagrams will all be assigned the same id. We can improve it by differentiating the id values by using information about the positions of the letters in the string, e.g. by raising each letter\u2019s index value to the power of its position in the string. In this case \u2019cab\u2019 gets assigned the id 3 1 + 1 2 + 2 3 = 12. Note that this is not the same as any of cab\u2019s anagrams, e.g. the id of \u2019abc\u2019 is 1 1 + 2 2 + 3 3 = 32. (Whether all strings are guaranteeed to have a unique id in this scheme is an interesting, but difficult question we will not pursue in this course.) Here\u2019s some Python code implementing this scheme, import string s = 'cab' uid = 0 for i in range(len(s)): uid += (string.ascii_letters.index(s[i])+1) ** (i+1) print(uid) One problem with this scheme is that the id numbers get large quickly as the string gets longer because of the exponentiation operation, e.g. the id for \u2019Yabbadabbadoo\u2019 is 2075941410449291L! This is worked around in practice by reducing the number arithmetically by e.g. modulo operations or bitwise \u2019folding\u2019 of the number. (Note the use of modulo again. That strange operation you learned in CPSC 128 turns out the be very useful).","title":"The idea"},{"location":"04.2_MVC_1/05_UIDs/#jargon","text":"Functions that generate uids are called hash functions: A hash function is a reproducible method of turning some kind of data into a (relatively) small number that may serve as a digital fingerprint\u201d of the data. The algorithm chops and mixes\u201d (i.e., substitutes or transposes) the data to create such fingerprints. * One common place hash functions are encountered is in checksum\u2019s used to validate the contents of downloaded files, e.g. SHA1, SHA2 and md5sum checksums. md5sum is a computer program which calculates and verifies 128-bit MD5 hashes, as described in RFC 1321. The MD5 hash (or checksum) functions as a compact digital fingerprint of a file. It is extremely unlikely that any two non-identical files will have the same MD5 hash (although it is certainly possible). Because almost any change to a file will cause its MD5 hash to also change, the MD5 hash is commonly used to verify the integrity of files (i.e., to verify that a file has not changed as a result of file transfer, disk error, meddling, etc.). *","title":"Jargon"},{"location":"04.2_MVC_1/05_UIDs/#practical-implementation","text":"In fact however it is difficult to design a uid generator (or hashing scheme as they are called) that assigns unique uids. And since others have already done that work, we\u2019ll build on it. Python has a built-in function called hash that can hash numbers and strings, e.g. >>> hash('tim') 333309873 >>> hash('shelly') 1348423469 >>> hash('misha') -1866883155 >>> hash('Misha') 527638157 >>> hash(42) 42 Note that while hash() will return values for all Python objects, apart from strings and numbers these will not usually be uids, but simply internal ids that will vary from one computer to another and even one run of the program to another. For other object types we can first create a string that uniquely represents the object and then hash the string to get a compact, unique key. For example for our quote class we can concatenate the class name, author name and quote text, and hash the resulting string, def uid(self): return hash('Quote' + self.author + self.text)","title":"Practical implementation"},{"location":"04.2_MVC_1/06_Step_4_Model_revisited_for_testing/","text":"Step 4: Model revisited for testing Let's add some tests to our model. We are going to use our newly created quote objects to do the testing, which means that the first thing we need to do is import our class Quote . We will test by creating some quotes and adding them to our model. Once we have some quotes in the model we can make sure that they display correctly. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close() if __name__ == '__main__': q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') m = Model('test_model') m.create(q) r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') m.create(r) m.listall() m.close()","title":"Step 4: Model revisited for testing"},{"location":"04.2_MVC_1/06_Step_4_Model_revisited_for_testing/#step-4-model-revisited-for-testing","text":"Let's add some tests to our model. We are going to use our newly created quote objects to do the testing, which means that the first thing we need to do is import our class Quote . We will test by creating some quotes and adding them to our model. Once we have some quotes in the model we can make sure that they display correctly. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close() if __name__ == '__main__': q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') m = Model('test_model') m.create(q) r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') m.create(r) m.listall() m.close()","title":"Step 4: Model revisited for testing"},{"location":"04.2_MVC_1/07_Step_5_Controller_revisited/","text":"Step 5: Controller revisited We should now be able to run our controller with the model and the quote object. Because we have used MVC architecture it will not look any different from our original CRUD controller when we run it. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close()","title":"Step 5: Controller revisited"},{"location":"04.2_MVC_1/07_Step_5_Controller_revisited/#step-5-controller-revisited","text":"We should now be able to run our controller with the model and the quote object. Because we have used MVC architecture it will not look any different from our original CRUD controller when we run it. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection r - retrieve a quote from the collection and display it u - update a quote in the collection d - delete a quote from the collection l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) elif choice == 'r': pass elif choice == 'u': pass elif choice == 'd': pass elif choice == 'l': print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': over = True else: print('Not a valid choice!') model.close()","title":"Step 5: Controller revisited"},{"location":"04.3_PyGame_2_Animation/00_index/","text":"PyGame 2: Animation Introduction Making something move 1 Making something move 2 Making something move 3 Making something move 4 Making something move 5 Resource: The ball image","title":"Contents"},{"location":"04.3_PyGame_2_Animation/00_index/#pygame-2-animation","text":"Introduction Making something move 1 Making something move 2 Making something move 3 Making something move 4 Making something move 5 Resource: The ball image","title":"PyGame 2: Animation"},{"location":"04.3_PyGame_2_Animation/01_Introduction/","text":"Introduction Last time around we saw how to use PyGame to draw static shapes into a window. This time we\u2019ll see how to make those shapes move, or at least at how to produce the illusion of movement! This unit is aimed at showing you how animation can be done from scratch. It\u2019s a fundamental technique that every programmer should understand. Of course since it is fundamental most of it has been encapsulated into libraries that are available. The moving objects we\u2019ll be creating in this unit are usually referred to as sprites . PyGame does provide libary routines to manage sprites and those are what you would use were you creating a an actual arcade game. On the other hand sprites can be used badly[^*] if you are unaware of what is behind them so to become aware of what is behind them we\u2019ll be implementing ours from scratch. With great power comes great responsibility :-) The goal of this unit is to give you the awareness to use your power well. [^*] in the same way that if we want to find the first 5 that occurs in a list after the first 3 we might write the compact expression lst[lst.index(3):].index(5) without realizing that that is an O( n 2 ) operation!","title":"Introduction"},{"location":"04.3_PyGame_2_Animation/01_Introduction/#introduction","text":"Last time around we saw how to use PyGame to draw static shapes into a window. This time we\u2019ll see how to make those shapes move, or at least at how to produce the illusion of movement! This unit is aimed at showing you how animation can be done from scratch. It\u2019s a fundamental technique that every programmer should understand. Of course since it is fundamental most of it has been encapsulated into libraries that are available. The moving objects we\u2019ll be creating in this unit are usually referred to as sprites . PyGame does provide libary routines to manage sprites and those are what you would use were you creating a an actual arcade game. On the other hand sprites can be used badly[^*] if you are unaware of what is behind them so to become aware of what is behind them we\u2019ll be implementing ours from scratch. With great power comes great responsibility :-) The goal of this unit is to give you the awareness to use your power well. [^*] in the same way that if we want to find the first 5 that occurs in a list after the first 3 we might write the compact expression lst[lst.index(3):].index(5) without realizing that that is an O( n 2 ) operation!","title":"Introduction"},{"location":"04.3_PyGame_2_Animation/02_pygame_test_6/","text":"Making something move 1 Animation is all a trick that relies on the low frame rate of the human visual system. That is, if something changes fast enough and in small enough increments we don\u2019t notice the jumps from one image to the next. This is how the frame rate of movie projectors evolved---they kept speeding it up until it didn\u2019t look jumpy\u201d---which lives on in the refresh rates of modern tv\u2019s and monitors. Here we take our first step and move a shape down and across the screen. Sample output:","title":"Making something move 1"},{"location":"04.3_PyGame_2_Animation/02_pygame_test_6/#making-something-move-1","text":"Animation is all a trick that relies on the low frame rate of the human visual system. That is, if something changes fast enough and in small enough increments we don\u2019t notice the jumps from one image to the next. This is how the frame rate of movie projectors evolved---they kept speeding it up until it didn\u2019t look jumpy\u201d---which lives on in the refresh rates of modern tv\u2019s and monitors. Here we take our first step and move a shape down and across the screen.","title":"Making something move 1"},{"location":"04.3_PyGame_2_Animation/02_pygame_test_6/#sample-output","text":"","title":"Sample output:"},{"location":"04.3_PyGame_2_Animation/03_pygame_test_7/","text":"Making something move 2 It looks more like it\u2019s moving if it doesn\u2019t leave a trail behind it: Sample output:","title":"Making something move 2"},{"location":"04.3_PyGame_2_Animation/03_pygame_test_7/#making-something-move-2","text":"It looks more like it\u2019s moving if it doesn\u2019t leave a trail behind it:","title":"Making something move 2"},{"location":"04.3_PyGame_2_Animation/03_pygame_test_7/#sample-output","text":"","title":"Sample output:"},{"location":"04.3_PyGame_2_Animation/04_pygame_test_8/","text":"Making something move 3 What will happen when it gets to the wall, i.e. the edge of the screen? Wrong question ! What will happen is whatever we decide should happen . The window is our Universe and we are its designers. We get to decide what will happen. Let\u2019s make it seem to bounce off the edge. Sample output:","title":"Making something move 3"},{"location":"04.3_PyGame_2_Animation/04_pygame_test_8/#making-something-move-3","text":"What will happen when it gets to the wall, i.e. the edge of the screen? Wrong question ! What will happen is whatever we decide should happen . The window is our Universe and we are its designers. We get to decide what will happen. Let\u2019s make it seem to bounce off the edge.","title":"Making something move 3"},{"location":"04.3_PyGame_2_Animation/04_pygame_test_8/#sample-output","text":"","title":"Sample output:"},{"location":"04.3_PyGame_2_Animation/05_pygame_test_9/","text":"Making something move 4 Now let\u2019s get it to bounce off the other walls as well, and keep on bouncing forever.","title":"Making something move 4"},{"location":"04.3_PyGame_2_Animation/05_pygame_test_9/#making-something-move-4","text":"Now let\u2019s get it to bounce off the other walls as well, and keep on bouncing forever.","title":"Making something move 4"},{"location":"04.3_PyGame_2_Animation/06_pygame_test_10/","text":"Making something move 5 Finally, let\u2019s make something more interesting bounce.","title":"Making something move 5"},{"location":"04.3_PyGame_2_Animation/06_pygame_test_10/#making-something-move-5","text":"Finally, let\u2019s make something more interesting bounce.","title":"Making something move 5"},{"location":"05.1_Sorting_1/00_index/","text":"Sorting 1 Video(s): Sorting out sorting Straight insertion sort Straight selection sort Straight exchange sort Shell sort","title":"Contents"},{"location":"05.1_Sorting_1/00_index/#sorting-1","text":"Video(s): Sorting out sorting Straight insertion sort Straight selection sort Straight exchange sort Shell sort","title":"Sorting 1"},{"location":"05.1_Sorting_1/01_Sorting_out_sorting/","text":"Sorting Out Sorting This week the heavy lifting in terms of presenting material is going to be done by a historical set of videos. The video was originally a single production called Sorting out Sorting . It was created by Ronald Baecker at the University of Toronto in 1981. This was early days for both computer animation and algorithm visualization . The video\u2019s animation (and sound) techniques were quickly superceded by Hollywood, but the visualizations are still very helpful in understanding how the algorithms work and indeed set the stage for much of what has followed in the evolution of algorithm visualization (AV).\u201d[^*] The video describes the operation and performance of nine classic sorting algortihms, 3 each in 3 families. Families Insertion Sorts Selection Sorts Exchange Sorts Linear insertion Straight selection Bubble sort Binary Insertion Tree sort Shaker sort Shell sort Heap sort Quicksort I have italicized the names of the ones we will implement and compare. This week we will do the first four. In two weeks we will return to the topic of sorting and implement the Quicksort and Heap Sort algorithms. You can view the video in segments on You Tube: part 1 , part 2 , part 3 , part 4 . Happy viewing! [^*] http://portal.acm.org/citation.cfm?id=1384319","title":"Sorting Out Sorting"},{"location":"05.1_Sorting_1/01_Sorting_out_sorting/#sorting-out-sorting","text":"This week the heavy lifting in terms of presenting material is going to be done by a historical set of videos. The video was originally a single production called Sorting out Sorting . It was created by Ronald Baecker at the University of Toronto in 1981. This was early days for both computer animation and algorithm visualization . The video\u2019s animation (and sound) techniques were quickly superceded by Hollywood, but the visualizations are still very helpful in understanding how the algorithms work and indeed set the stage for much of what has followed in the evolution of algorithm visualization (AV).\u201d[^*] The video describes the operation and performance of nine classic sorting algortihms, 3 each in 3 families. Families Insertion Sorts Selection Sorts Exchange Sorts Linear insertion Straight selection Bubble sort Binary Insertion Tree sort Shaker sort Shell sort Heap sort Quicksort I have italicized the names of the ones we will implement and compare. This week we will do the first four. In two weeks we will return to the topic of sorting and implement the Quicksort and Heap Sort algorithms. You can view the video in segments on You Tube: part 1 , part 2 , part 3 , part 4 . Happy viewing! [^*] http://portal.acm.org/citation.cfm?id=1384319","title":"Sorting Out Sorting"},{"location":"05.1_Sorting_1/02_Straight_insertion_sort/","text":"Linear Insertion Sort As you saw in the video, linear insertion sort moves through the list one position at a time, and leaves behind it a sorted list, so that at any moment the portion of the list before the current position is sorted, and the portion after the current position is unsorted. These elements have been sorted These haven't At each step it takes the next value, i.e. the first value in the unsorted portion, and looks backward to insert it where it should go in the already sorted portion of the list: for each position in the list insert the current element at the appropriate place in the already sorted (front) portion of the list Not surprisingly this first description is not quite correct or complete. A minor correction, and an expansion are required. The minor correction is that we do not need to consider the first position in the list because there is no sorted list preceding it. Instead, we begin with the second element, asking if it is in the correct position relative to the first, and then continue on from there. The expansion is to elaborate on how we insert the current element at the appropriate place in the already sorted portion of the list\u201d. This can be broken into two steps, first finding its appropriate location, and second placing it there, leading us to this revised description: for each position in the list after the first find out where this value should be in the already sorted portion of the list place it there Now the location of the current value we are considering should be between a value smaller than it and one larger than it. We can find such a location by scanning backward from the current position looking for a value smaller than it. Either we will find one, or we will bump into the front of the list (if the current value is smaller than any we have in the list so far). In pseudocode we could write this (where the left arrow, \u2190, means assignment and our list is called lst and has n elements): proper_posn \u2190 current_posn while proper_posn \u2265 0 and lst[proper_posn]<lst[proper_posn-1] proper_posn \u2190 proper_posn - 1 When this loop ends proper_posn holds the index of the location where we should place the current value. But how to place it there? We cannot just swap it with whatever is there because this would upset the ordering of the first part of the list. Instead we have to shift everything down to and including proper_posn forwards one position to make a spot for the current value and then we can insert the current value in its proper position. This is the procedure shown in the video. Of course before shifting everything forward we have to remove the current value to a safe temporary location until its proper position has been cleared, and when we shift things we have to do it from the back rather than from the front, i.e. first we move the item behind the current position into the current position, then move the one behind it and so on. In pseudocode this procedure can be represented as: tmp \u2190 lst[current_posn] for posn \u2190 current_posn down to proper_posn+1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Putting all the pseudocode together (and filling in the first statement) gives: for current_posn \u2190 1 to n-1 proper_posn \u2190 current_posn while proper_posn \u2265 0 and lst[proper_posn] < lst[proper_posn-1] proper_posn \u2190 proper_posn - 1 tmp \u2190 lst[current_posn] for posn \u2190 current_posn down to proper_posn+1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4 Exercise : What would happen if we tried to move elements out of the way from front to back instead of back to front? That is starting from the proper position and moving forward to the current position? In this case the moving pseudocode might be: tmp \u2190 lst[current_posn] for posn \u2190 proper_posn to current_posn-1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Simulate the effect by hand on the data below. Fill in proper_posn yourself. lst: 11 37 62 78 19 48 94 6 current_posn: 4 proper_posn: We can simplify our code a bit if we combine the steps so that we immediately set aside the current value, then start shifting values forward until we find one smaller than the current value (or bump into the front of the list) and then insert the current value. The resulting Python program is: # ins_sort.py # Sorts list into ascending order. def ins_sort(lst): ''' Sorts a list into ascending order. It does this by considering each value after the first one, and inserting it into the front (sorted) part of the list where it belongs. ''' for i in range(1, len(lst)): tmp = lst[i] j = i-1 while j >= 0 and tmp < lst[j]: lst[j+1] = lst[j] j = j-1 lst[j+1] = tmp if __name__=='__main__': l = [ 8, 3, 1, 9, 5, 6, 2, 4 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8, 3 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8, 3, 8, 9, 8, 6, 3, 3 ] print('Before: ', l) ins_sort( l ) print('After: ', l)","title":"Linear Insertion Sort"},{"location":"05.1_Sorting_1/02_Straight_insertion_sort/#linear-insertion-sort","text":"As you saw in the video, linear insertion sort moves through the list one position at a time, and leaves behind it a sorted list, so that at any moment the portion of the list before the current position is sorted, and the portion after the current position is unsorted. These elements have been sorted These haven't At each step it takes the next value, i.e. the first value in the unsorted portion, and looks backward to insert it where it should go in the already sorted portion of the list: for each position in the list insert the current element at the appropriate place in the already sorted (front) portion of the list Not surprisingly this first description is not quite correct or complete. A minor correction, and an expansion are required. The minor correction is that we do not need to consider the first position in the list because there is no sorted list preceding it. Instead, we begin with the second element, asking if it is in the correct position relative to the first, and then continue on from there. The expansion is to elaborate on how we insert the current element at the appropriate place in the already sorted portion of the list\u201d. This can be broken into two steps, first finding its appropriate location, and second placing it there, leading us to this revised description: for each position in the list after the first find out where this value should be in the already sorted portion of the list place it there Now the location of the current value we are considering should be between a value smaller than it and one larger than it. We can find such a location by scanning backward from the current position looking for a value smaller than it. Either we will find one, or we will bump into the front of the list (if the current value is smaller than any we have in the list so far). In pseudocode we could write this (where the left arrow, \u2190, means assignment and our list is called lst and has n elements): proper_posn \u2190 current_posn while proper_posn \u2265 0 and lst[proper_posn]<lst[proper_posn-1] proper_posn \u2190 proper_posn - 1 When this loop ends proper_posn holds the index of the location where we should place the current value. But how to place it there? We cannot just swap it with whatever is there because this would upset the ordering of the first part of the list. Instead we have to shift everything down to and including proper_posn forwards one position to make a spot for the current value and then we can insert the current value in its proper position. This is the procedure shown in the video. Of course before shifting everything forward we have to remove the current value to a safe temporary location until its proper position has been cleared, and when we shift things we have to do it from the back rather than from the front, i.e. first we move the item behind the current position into the current position, then move the one behind it and so on. In pseudocode this procedure can be represented as: tmp \u2190 lst[current_posn] for posn \u2190 current_posn down to proper_posn+1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Putting all the pseudocode together (and filling in the first statement) gives: for current_posn \u2190 1 to n-1 proper_posn \u2190 current_posn while proper_posn \u2265 0 and lst[proper_posn] < lst[proper_posn-1] proper_posn \u2190 proper_posn - 1 tmp \u2190 lst[current_posn] for posn \u2190 current_posn down to proper_posn+1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4 Exercise : What would happen if we tried to move elements out of the way from front to back instead of back to front? That is starting from the proper position and moving forward to the current position? In this case the moving pseudocode might be: tmp \u2190 lst[current_posn] for posn \u2190 proper_posn to current_posn-1 lst[posn] \u2190 lst[posn-1] lst[proper_posn] \u2190 tmp Simulate the effect by hand on the data below. Fill in proper_posn yourself. lst: 11 37 62 78 19 48 94 6 current_posn: 4 proper_posn: We can simplify our code a bit if we combine the steps so that we immediately set aside the current value, then start shifting values forward until we find one smaller than the current value (or bump into the front of the list) and then insert the current value. The resulting Python program is: # ins_sort.py # Sorts list into ascending order. def ins_sort(lst): ''' Sorts a list into ascending order. It does this by considering each value after the first one, and inserting it into the front (sorted) part of the list where it belongs. ''' for i in range(1, len(lst)): tmp = lst[i] j = i-1 while j >= 0 and tmp < lst[j]: lst[j+1] = lst[j] j = j-1 lst[j+1] = tmp if __name__=='__main__': l = [ 8, 3, 1, 9, 5, 6, 2, 4 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8, 3 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8 ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ ] print('Before: ', l) ins_sort( l ) print('After: ', l) l = [ 8, 3, 8, 9, 8, 6, 3, 3 ] print('Before: ', l) ins_sort( l ) print('After: ', l)","title":"Linear Insertion Sort"},{"location":"05.1_Sorting_1/03_Straight_selection_sort/","text":"Straight Selection Sort Like insertion sort, straight selection sort proceeds through the list one position at a time, and like linear insertion it leaves a sorted list behind it as it proceeds. However it behaves quite differently at each position. Where linear insertion sort asks, Where in the already sorted portion of the list on my left should I insert this value? Straight selection asks, Which of the unsorted values on my right belongs here in this location. So where insertion sort scans to the left looking for the correct location for this value, selection sort scans to the right looking for the right value for this location. So, It begins by considering the first position in the list. Which value should go here, i.e. which value should come first in the list? Well since the list is to be sorted in ascending order the smallest value in the list should come first. So straight selection needs to find the smallest value in the list and place it here in the first position. To find the smallest value it scans the entire list looking for the smallest value. Once it has found it, it places it in the first position in the list. What does it do with the value that was in the first position? The most common solution is to swap it with the smallest value. Next it considers the second position in the list. Which value should go here? The second smallest value in the list. Since the smallest value has been placed in the first position the second smallest value will be the smallest value in the remainder of the list, i.e. from the second position to the end of the list. To find it, straight selection scans the remainder of the list for the smallest value and swaps it with the value currently in the second position. Then it considers the third position in the list, scans the remainder of the list (positions 3 through n ) for the smallest remaining value and swaps it with the value currently in the third position. The algorithm proceeds in this way up to the second last position in the list. It need not explicitly consider the last position, because the last number left should be the largest. (Another difference from insertion sort. Linear insertion did not need to consider the first value, but straight selection doesn\u2019t need to consider the last value.) We can summarize this algorithm as follows: for each position in the list find the smallest item in the remainder of the list swap it with the value in the current position The second line implies another loop which scans the remainder of the list looking for the smallest element. So we can expand the description above to: for each position in the list set smallest position to be the current position for each remaining position in the list if the element at this position is smaller than the one at smallest position set smallest position to this position swap the values in the current position and the smallest position Introducing variables into our description we get (and assuming we have a list lst with n elements): for current_posn \u2190 0 to n-2 smallest_posn \u2190 current_posn for posn \u2190 current_posn+1 to n-1 if lst[posn] < lst[smallest_posn] smallest_posn \u2190 posn swap lst[current_posn], lst[smallest_posn] Question : If the current value in the list is also the smallest in the remainder of the list this will perform an unnecessary swap. The unnecessary swap could be avoided by changing the final line to, if l[current_posn] > l[smallest_posn] swap l[current_posn], l[smallest_posn] Would this change make the program more efficient? Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4","title":"Straight Selection Sort"},{"location":"05.1_Sorting_1/03_Straight_selection_sort/#straight-selection-sort","text":"Like insertion sort, straight selection sort proceeds through the list one position at a time, and like linear insertion it leaves a sorted list behind it as it proceeds. However it behaves quite differently at each position. Where linear insertion sort asks, Where in the already sorted portion of the list on my left should I insert this value? Straight selection asks, Which of the unsorted values on my right belongs here in this location. So where insertion sort scans to the left looking for the correct location for this value, selection sort scans to the right looking for the right value for this location. So, It begins by considering the first position in the list. Which value should go here, i.e. which value should come first in the list? Well since the list is to be sorted in ascending order the smallest value in the list should come first. So straight selection needs to find the smallest value in the list and place it here in the first position. To find the smallest value it scans the entire list looking for the smallest value. Once it has found it, it places it in the first position in the list. What does it do with the value that was in the first position? The most common solution is to swap it with the smallest value. Next it considers the second position in the list. Which value should go here? The second smallest value in the list. Since the smallest value has been placed in the first position the second smallest value will be the smallest value in the remainder of the list, i.e. from the second position to the end of the list. To find it, straight selection scans the remainder of the list for the smallest value and swaps it with the value currently in the second position. Then it considers the third position in the list, scans the remainder of the list (positions 3 through n ) for the smallest remaining value and swaps it with the value currently in the third position. The algorithm proceeds in this way up to the second last position in the list. It need not explicitly consider the last position, because the last number left should be the largest. (Another difference from insertion sort. Linear insertion did not need to consider the first value, but straight selection doesn\u2019t need to consider the last value.) We can summarize this algorithm as follows: for each position in the list find the smallest item in the remainder of the list swap it with the value in the current position The second line implies another loop which scans the remainder of the list looking for the smallest element. So we can expand the description above to: for each position in the list set smallest position to be the current position for each remaining position in the list if the element at this position is smaller than the one at smallest position set smallest position to this position swap the values in the current position and the smallest position Introducing variables into our description we get (and assuming we have a list lst with n elements): for current_posn \u2190 0 to n-2 smallest_posn \u2190 current_posn for posn \u2190 current_posn+1 to n-1 if lst[posn] < lst[smallest_posn] smallest_posn \u2190 posn swap lst[current_posn], lst[smallest_posn] Question : If the current value in the list is also the smallest in the remainder of the list this will perform an unnecessary swap. The unnecessary swap could be avoided by changing the final line to, if l[current_posn] > l[smallest_posn] swap l[current_posn], l[smallest_posn] Would this change make the program more efficient? Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4","title":"Straight Selection Sort"},{"location":"05.1_Sorting_1/04_Straight_exchange_sort/","text":"Bubble Sort The straight exchange sort, or Bubble Sort, operates by exchanging neighbouring elements of the list if they are out of order. It keeps scanning through the list making exchanges until the list is ordered. A single pass through the list looks like this: for current_posn \u2190 0 to n-1 if lst[current_posn] > lst[current_posn+1] swap lst[current_posn], lst[current_posn+1] Exercise : Simulate this loop on the list: lst: 34 11 23 86 51 94 4 Notice that the largest value (94) is moved into the last position in the list. This will always occur. How would you explain to someone why it must happen? Since after the first pass through the list the largest value is where it belongs at the end of the list, the second pass only needs to loop to the second last element, and since it will move the second largest element into the second last position, the third iteration of the loop only needs to loop to the third last position, and so on So the complete bubble sort algorithm just places the single pass above into an outer loop that controls the limit of the current scan. for end_posn \u2190 n-1 down to 1 for current_posn \u2190 0 to end_posn if lst[current_posn] > lst[current_posn+1] swap lst[current_posn], lst[current_posn+1] Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4 The video suggested an optimization. As expressed above the algorithm will continue even after the list is sorted, but it could notice if the list is sorted and stop. How could it notice? It could use a boolean flag variable to remember if it made a swap on the last pass. If it didn\u2019t then all the elements of the list are in order and it can stop.","title":"Bubble Sort"},{"location":"05.1_Sorting_1/04_Straight_exchange_sort/#bubble-sort","text":"The straight exchange sort, or Bubble Sort, operates by exchanging neighbouring elements of the list if they are out of order. It keeps scanning through the list making exchanges until the list is ordered. A single pass through the list looks like this: for current_posn \u2190 0 to n-1 if lst[current_posn] > lst[current_posn+1] swap lst[current_posn], lst[current_posn+1] Exercise : Simulate this loop on the list: lst: 34 11 23 86 51 94 4 Notice that the largest value (94) is moved into the last position in the list. This will always occur. How would you explain to someone why it must happen? Since after the first pass through the list the largest value is where it belongs at the end of the list, the second pass only needs to loop to the second last element, and since it will move the second largest element into the second last position, the third iteration of the loop only needs to loop to the third last position, and so on So the complete bubble sort algorithm just places the single pass above into an outer loop that controls the limit of the current scan. for end_posn \u2190 n-1 down to 1 for current_posn \u2190 0 to end_posn if lst[current_posn] > lst[current_posn+1] swap lst[current_posn], lst[current_posn+1] Exercise : Simulate the pseudocode above on the list lst below. Draw the state of the list at the end of each iteration of the main loop. Does the pseudocode work? lst: 34 11 23 86 51 94 4 The video suggested an optimization. As expressed above the algorithm will continue even after the list is sorted, but it could notice if the list is sorted and stop. How could it notice? It could use a boolean flag variable to remember if it made a swap on the last pass. If it didn\u2019t then all the elements of the list are in order and it can stop.","title":"Bubble Sort"},{"location":"05.1_Sorting_1/05_Shell_sort/","text":"Shell Sort Shell sort is a modification of linear insertion sort based on the observation that if we move values more than 1 step toward their final position at a time they will get there faster. This might allow us to make fewer (potentially far fewer ) movements. Before we embark on the code for it, watch the description of it at the 4:30 mark of Sorting Out Sorting again. Notice that Shellsort does multiple linear insertion sorts of the list with different gaps between the values being sorted. All we need to do then is to modify our linear insertion sort to apply itself to the list multiple times with appropriate parameters each time. Let\u2019s begin by modifying our code for a simple linear insertion sort to sort values that are separated by a gap or step size, i.e. values that are not immediate neighbours. Where in our existing code is the assumption that values are next to each other baked in\u201d? for i in range(1, len(lst)): tmp = lst[i] j = i-1 while j >= 0 and tmp < lst[j]: lst[j+1] = lst[j] j = j-1 lst[j+1] = tmp Well we\u2019ll want i to increase by step instead of 1 each time, and when we move around in the list we will want to move step positions at a time instead of 1 so the -1 and +1 expressions will become -step and +step . Less obviously, our sublists will not necessarily begin in position one, but in other positions. Let me try to show this diagrammatically. Suppose our step size is 4. Then the list lst below will have several sublists: Index: 0 1 2 3 4 5 6 7 8 9 10 11 12 lst = [ 11, 89, 32, 42, 56, 78, 81, 39, 92, 16, 43, 57, 73] Sublists: 1) 11 56 92 73 2) 89 78 16 3) 32 81 43 4) 42 39 57 Index: 0 1 2 3 4 5 6 7 8 9 10 11 12 So the starting position for each sublist will have to vary as well. The changed code is, for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp Now this bit of code sorts one sublist of items step apart using a linear insertion sort. For example it might sort sublist 1) above. To sort all the sublists at a given step size we have to loop over the possible starting positions of the lists, for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp And to ensure the list is completely sorted we have to make the step size decline from something large \u2014 to get large efficient initial movements \u2014 to something small to ensure the list eventually gets sorted completely, step = len(lst)//2 while step>=1: for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp step = step//2 Here I have begun with a step size equal to half the list size and then reduced it to 1 by dividing by 2 after each pass of sorts. Packaging it all up gives us, # shell_sort.py # Sorts list into ascending order. def shell_sort(lst): ''' Sorts a list into ascending order. It does this by using Shell's algorithm: http://en.wikipedia.org/wiki/Shell_sort. ''' step = len(lst)//2 while step>=1: for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp step = step//2 if __name__=='__main__': lst = [ 11, 89, 32, 42, 56, 78, 81, 39, 92, 16, 43, 57, 73] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8, 3 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8, 3, 8, 9, 8, 6, 3, 3 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst)","title":"Shell Sort"},{"location":"05.1_Sorting_1/05_Shell_sort/#shell-sort","text":"Shell sort is a modification of linear insertion sort based on the observation that if we move values more than 1 step toward their final position at a time they will get there faster. This might allow us to make fewer (potentially far fewer ) movements. Before we embark on the code for it, watch the description of it at the 4:30 mark of Sorting Out Sorting again. Notice that Shellsort does multiple linear insertion sorts of the list with different gaps between the values being sorted. All we need to do then is to modify our linear insertion sort to apply itself to the list multiple times with appropriate parameters each time. Let\u2019s begin by modifying our code for a simple linear insertion sort to sort values that are separated by a gap or step size, i.e. values that are not immediate neighbours. Where in our existing code is the assumption that values are next to each other baked in\u201d? for i in range(1, len(lst)): tmp = lst[i] j = i-1 while j >= 0 and tmp < lst[j]: lst[j+1] = lst[j] j = j-1 lst[j+1] = tmp Well we\u2019ll want i to increase by step instead of 1 each time, and when we move around in the list we will want to move step positions at a time instead of 1 so the -1 and +1 expressions will become -step and +step . Less obviously, our sublists will not necessarily begin in position one, but in other positions. Let me try to show this diagrammatically. Suppose our step size is 4. Then the list lst below will have several sublists: Index: 0 1 2 3 4 5 6 7 8 9 10 11 12 lst = [ 11, 89, 32, 42, 56, 78, 81, 39, 92, 16, 43, 57, 73] Sublists: 1) 11 56 92 73 2) 89 78 16 3) 32 81 43 4) 42 39 57 Index: 0 1 2 3 4 5 6 7 8 9 10 11 12 So the starting position for each sublist will have to vary as well. The changed code is, for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp Now this bit of code sorts one sublist of items step apart using a linear insertion sort. For example it might sort sublist 1) above. To sort all the sublists at a given step size we have to loop over the possible starting positions of the lists, for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp And to ensure the list is completely sorted we have to make the step size decline from something large \u2014 to get large efficient initial movements \u2014 to something small to ensure the list eventually gets sorted completely, step = len(lst)//2 while step>=1: for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp step = step//2 Here I have begun with a step size equal to half the list size and then reduced it to 1 by dividing by 2 after each pass of sorts. Packaging it all up gives us, # shell_sort.py # Sorts list into ascending order. def shell_sort(lst): ''' Sorts a list into ascending order. It does this by using Shell's algorithm: http://en.wikipedia.org/wiki/Shell_sort. ''' step = len(lst)//2 while step>=1: for start in range(step): for i in range(start+step, len(lst), step): tmp = lst[i] j = i-step while j >= step-1 and tmp < lst[j]: lst[j+step] = lst[j] j = j-step lst[j+step] = tmp step = step//2 if __name__=='__main__': lst = [ 11, 89, 32, 42, 56, 78, 81, 39, 92, 16, 43, 57, 73] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8, 3 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst) lst = [ 8, 3, 8, 9, 8, 6, 3, 3 ] print('Before: ', lst) shell_sort( lst ) print('After: ', lst)","title":"Shell Sort"},{"location":"05.2_CGoL_3_Speed/00_index/","text":"Life 3: More speed! Where to begin? Measure, don\u2019t guess Reworking Aging The new aging scheme Is it better? Measure again","title":"Contents"},{"location":"05.2_CGoL_3_Speed/00_index/#life-3-more-speed","text":"Where to begin? Measure, don\u2019t guess Reworking Aging The new aging scheme Is it better? Measure again","title":"Life 3: More speed!"},{"location":"05.2_CGoL_3_Speed/01_Where_to_begin/","text":"Where to Begin? Let\u2019s try and speed up our Game of Life program. We knew from our first versions that displaying the game universe takes up a large majority of the program\u2019s running time, and on the previous assignment we found that using Pygame is faster than displaying to the terminal. This moved our program bottleneck from being the display of the universe to being the aging portion of our program. Let\u2019s turn our attention to this part of the algorithm. The source below shows a main loop of the program---the part that matters most for speed because it is the only part executed more than once. I have presented it as one monolithic code segment (i.e. no functions) and removed class mechanisms to make the structure of the algorithm as brief and clear as possible. generations = int(input('How many generations to time? ')) for generation in range(0, generations): # Create next universe next_u = [] for row in range(u_rows): next_u.append(u_cols*[0]) # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 # Replace universe with next universe u = next_u # Display the new universe # display(u) Looking at the source we can see that the loop consists of four blocks of code: Create the next universe, Age the universe, Replace the universe with the next universe, and Display the universe. I\u2019ve commented the display block out since we\u2019ve already investigated it. Our experience with cryptarithms in CPSC 128 taught us to look first to the most deeply nested loops to try and speed our code up. This makes sense since the code in the innermost loops is the code executed the most times, but it can be misleading when that nested code in fact runs quickly and there is some very slow but unnested code elsewhere. In this case that might be either of the other blocks which could plausibly take a significant amount of time. Which brings us to a key optimization guideline: If you\u2019re not measuring, you\u2019re guessing . Since we\u2019re supposed to be more like pocket-protector-wearing engineers than Vegas gamblers (sorry if you were hoping otherwise) let\u2019s measure.","title":"Where to Begin?"},{"location":"05.2_CGoL_3_Speed/01_Where_to_begin/#where-to-begin","text":"Let\u2019s try and speed up our Game of Life program. We knew from our first versions that displaying the game universe takes up a large majority of the program\u2019s running time, and on the previous assignment we found that using Pygame is faster than displaying to the terminal. This moved our program bottleneck from being the display of the universe to being the aging portion of our program. Let\u2019s turn our attention to this part of the algorithm. The source below shows a main loop of the program---the part that matters most for speed because it is the only part executed more than once. I have presented it as one monolithic code segment (i.e. no functions) and removed class mechanisms to make the structure of the algorithm as brief and clear as possible. generations = int(input('How many generations to time? ')) for generation in range(0, generations): # Create next universe next_u = [] for row in range(u_rows): next_u.append(u_cols*[0]) # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 # Replace universe with next universe u = next_u # Display the new universe # display(u) Looking at the source we can see that the loop consists of four blocks of code: Create the next universe, Age the universe, Replace the universe with the next universe, and Display the universe. I\u2019ve commented the display block out since we\u2019ve already investigated it. Our experience with cryptarithms in CPSC 128 taught us to look first to the most deeply nested loops to try and speed our code up. This makes sense since the code in the innermost loops is the code executed the most times, but it can be misleading when that nested code in fact runs quickly and there is some very slow but unnested code elsewhere. In this case that might be either of the other blocks which could plausibly take a significant amount of time. Which brings us to a key optimization guideline: If you\u2019re not measuring, you\u2019re guessing . Since we\u2019re supposed to be more like pocket-protector-wearing engineers than Vegas gamblers (sorry if you were hoping otherwise) let\u2019s measure.","title":"Where to Begin?"},{"location":"05.2_CGoL_3_Speed/02_Measure_dont_guess/","text":"Measure, don\u2019t guess To measure the absolute and relative amounts of time each block consumes I\u2019ve instrumented the code. The term instrumentation derives from pre-computer engineering practice where engineers would insert measuring devices into the engine/mine/bridge they were working on to measure salient characteristics. For us it means that we insert timers into our program to measure how long each block takes to run. Here\u2019s the instrumented code, creation_time = 0.0 aging_time = 0.0 copying_time = 0.0 for generation in range(0, generations): start = time.time() # Create next universe next_u = [] for row in range(u_rows): next_u.append(u_cols*[0]) end = time.time() creation_time += end - start start = time.time() # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 end = time.time() aging_time += end - start start = time.time() # Replace universe with next universe u = next_u end = time.time() copying_time += end - start # Display the new universe # display(u) total_time = creation_time + aging_time + copying_time print(f'total_time : {total_time:5.2f}') print(f'creation_time : {creation_time:5.2f} = {creation_time*100.0/total_time:5.2f}%') print(f'aging_time : {aging_time:5.2f} = {aging_time*100.0/total_time:5.2f}%') print(f'copying_time : {copying_time:5.2f} = {copying_time*100.0/total_time:5.2f}%') And here\u2019s the output it produces (100 generations of a 100x100 universe with random initialization of 42% live cells), >>> u_rows = 100 u_cols = 100 generations = 100 live_pct = 42 total_time : 7.73 creation_time : 0.01 = 0.10% aging_time : 7.72 = 99.83% copying_time : 0.01 = 0.06% >>>","title":"Measure, don\u2019t guess"},{"location":"05.2_CGoL_3_Speed/02_Measure_dont_guess/#measure-dont-guess","text":"To measure the absolute and relative amounts of time each block consumes I\u2019ve instrumented the code. The term instrumentation derives from pre-computer engineering practice where engineers would insert measuring devices into the engine/mine/bridge they were working on to measure salient characteristics. For us it means that we insert timers into our program to measure how long each block takes to run. Here\u2019s the instrumented code, creation_time = 0.0 aging_time = 0.0 copying_time = 0.0 for generation in range(0, generations): start = time.time() # Create next universe next_u = [] for row in range(u_rows): next_u.append(u_cols*[0]) end = time.time() creation_time += end - start start = time.time() # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 end = time.time() aging_time += end - start start = time.time() # Replace universe with next universe u = next_u end = time.time() copying_time += end - start # Display the new universe # display(u) total_time = creation_time + aging_time + copying_time print(f'total_time : {total_time:5.2f}') print(f'creation_time : {creation_time:5.2f} = {creation_time*100.0/total_time:5.2f}%') print(f'aging_time : {aging_time:5.2f} = {aging_time*100.0/total_time:5.2f}%') print(f'copying_time : {copying_time:5.2f} = {copying_time*100.0/total_time:5.2f}%') And here\u2019s the output it produces (100 generations of a 100x100 universe with random initialization of 42% live cells), >>> u_rows = 100 u_cols = 100 generations = 100 live_pct = 42 total_time : 7.73 creation_time : 0.01 = 0.10% aging_time : 7.72 = 99.83% copying_time : 0.01 = 0.06% >>>","title":"Measure, don\u2019t guess"},{"location":"05.2_CGoL_3_Speed/03_Reworking_aging/","text":"Reworking Aging This provides dramatic evidence that we should focus our attention on the block of code responsible for aging the universe, # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 Looking it over we see some quadruply nested code (in the innermost for loop) and since cryptarithms in CPSC 128 we\u2019ve known that nested loops can be slow. Let\u2019s see what we can do about them. We take our lead from a second optimization guideline: the fastest code is code that isn\u2019t there , since if it isn\u2019t there it takes no time to run. Is there a way we can eliminate the innermost pair of loops? (And it is important that we truly eliminate their computations, not just push them into functions or class methods, or hide them via calls to built-in functions like count or find which will still involve iteration.) At first it might seem impossible since we do need to know the number of live neighbours each cell has to correctly age the universe, and it is true that we need to know this. But is looping over each cell\u2019s neighbourhood the only way to find it? Consider the moment at which we discover that a cell dies. At that instant we already know that each of its neighbours will have one fewer live neighbour in the next generation . If we could record that right then so we could remember it next time around we wouldn\u2019t need to loop over their neighbourhoods in the next generation. Now, where to record this information? In a 2-D array of counts of each cell\u2019s neighbours. We\u2019d have to initialize this neighbour array before beginning the main loop, but then inside the loop we could just refer to it to determine if cells live or die without having to loop over their neighbourhoods. We won\u2019t have done away with all looping, since when a cell changes state, we will have to loop over its neighbours in the neighbour array changing their counts for the next generation, but since only a fraction of the cells in the universe change state each generation this should be much faster than looping over every cell in the universe\u2019s neighbourhoods. There\u2019s always a complication If you\u2019ve thought about that long enough to make it clear in your mind there is one complication to keep in mind, but it is not a new one: We can\u2019t change the neighbour array as we loop through the universe because that could lead to incorrect aging, we have to change the neighbour array for the next generation . I say this is not a new complication because it is the same issue we faced when changing the universe. The solution is also the same: we need two copies of the neighbour array, just as we did for the universe array, one current one, and one for the next generation.","title":"Reworking Aging"},{"location":"05.2_CGoL_3_Speed/03_Reworking_aging/#reworking-aging","text":"This provides dramatic evidence that we should focus our attention on the block of code responsible for aging the universe, # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): # Count its live neighbours neighbours = 0 for r in range(row-1, row+2): for c in range(col-1, col+2): if r >= u_rows: r = 0 # Handle toroidal universe if c >= u_cols: c = 0 # Handle toroidal universe neighbours += u[r][c] neighbours -= u[row][col] # Decide if it lives, dies or is born. if (u[row][col] == 1 and neighbours == 2) or neighbours == 3: next_u[row][col] = 1 Looking it over we see some quadruply nested code (in the innermost for loop) and since cryptarithms in CPSC 128 we\u2019ve known that nested loops can be slow. Let\u2019s see what we can do about them. We take our lead from a second optimization guideline: the fastest code is code that isn\u2019t there , since if it isn\u2019t there it takes no time to run. Is there a way we can eliminate the innermost pair of loops? (And it is important that we truly eliminate their computations, not just push them into functions or class methods, or hide them via calls to built-in functions like count or find which will still involve iteration.) At first it might seem impossible since we do need to know the number of live neighbours each cell has to correctly age the universe, and it is true that we need to know this. But is looping over each cell\u2019s neighbourhood the only way to find it? Consider the moment at which we discover that a cell dies. At that instant we already know that each of its neighbours will have one fewer live neighbour in the next generation . If we could record that right then so we could remember it next time around we wouldn\u2019t need to loop over their neighbourhoods in the next generation. Now, where to record this information? In a 2-D array of counts of each cell\u2019s neighbours. We\u2019d have to initialize this neighbour array before beginning the main loop, but then inside the loop we could just refer to it to determine if cells live or die without having to loop over their neighbourhoods. We won\u2019t have done away with all looping, since when a cell changes state, we will have to loop over its neighbours in the neighbour array changing their counts for the next generation, but since only a fraction of the cells in the universe change state each generation this should be much faster than looping over every cell in the universe\u2019s neighbourhoods.","title":"Reworking Aging"},{"location":"05.2_CGoL_3_Speed/03_Reworking_aging/#theres-always-a-complication","text":"If you\u2019ve thought about that long enough to make it clear in your mind there is one complication to keep in mind, but it is not a new one: We can\u2019t change the neighbour array as we loop through the universe because that could lead to incorrect aging, we have to change the neighbour array for the next generation . I say this is not a new complication because it is the same issue we faced when changing the universe. The solution is also the same: we need two copies of the neighbour array, just as we did for the universe array, one current one, and one for the next generation.","title":"There\u2019s always a complication"},{"location":"05.2_CGoL_3_Speed/04_The_new_aging_scheme/","text":"The New Aging Scheme Here\u2019s a diagram showing the four arrays we will now be working with and showing how they change over the course of one generation for a simple blinker. u next_u (at start) next_u (at end) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 \u2192 0 1 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 n next_n (at start) next_n (at end) 0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 2 1 2 0 0 2 1 2 0 1 2 3 2 1 0 3 2 3 0 0 3 2 3 0 \u2192 1 1 2 1 1 0 2 1 2 0 0 2 1 2 0 1 2 3 2 1 0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 Note well that u and n do not change over the course of a generation, and that all changes are reflected in next_u and next_n . These changes carry into the next generation because we copy next_u into u , and next_n into n between generations. This also helps clarify the aging logic (or it did in my mind) because it reminds us that it is cell changes we care about. This in turn suggests that we begin each generation with exact copies of our current universe and neighbour arrays and then record the changes in one of them. At the end of the generation we again make exact copies of them. We\u2019ll see if this is any slower than allocating new universes and waiting for garbage collection to clean up the old ones as we do now[^*]. The framework to make all this happen looks like this, # Construct initial neighbours array n by looping over whole universe and counting neighbours. # This is just like the original doubly nested loop we used to have to count neighbours in the aging block. ... for ... # main loop # Copy next_u into u and next_n into n. for row in range(0, u_rows): for col in range(0, u_cols): u[row][col] = next_u[row][col] n[row][col] = next_n[row][col] # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): if u[row][col] == 1 and (n[row][col] < 2 or n[row][col] > 3): next_u[row][col] = 0 # Update next_n to reflect this death by subtracting 1 from the neighbour # count of each of this cell's eight neighbours. # (While remembering that it's a toroidal universe!) ... elif u[row][col] == 0 and n[row][col] == 3: next_u[row][col] = 1 # Update next_n to reflect this birth by adding 1 to the neighbour # count of each of this cell's eight neighbours. # (And remembering that it's a toroidal universe!) ... # display(u) [^*] Didn\u2019t realize this is what we were doing? During the aging loop we had this, And afterward (at the start of the next aging loop) we had this,","title":"The New Aging Scheme"},{"location":"05.2_CGoL_3_Speed/04_The_new_aging_scheme/#the-new-aging-scheme","text":"Here\u2019s a diagram showing the four arrays we will now be working with and showing how they change over the course of one generation for a simple blinker. u next_u (at start) next_u (at end) 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 \u2192 0 1 1 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 n next_n (at start) next_n (at end) 0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 2 1 2 0 0 2 1 2 0 1 2 3 2 1 0 3 2 3 0 0 3 2 3 0 \u2192 1 1 2 1 1 0 2 1 2 0 0 2 1 2 0 1 2 3 2 1 0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 Note well that u and n do not change over the course of a generation, and that all changes are reflected in next_u and next_n . These changes carry into the next generation because we copy next_u into u , and next_n into n between generations. This also helps clarify the aging logic (or it did in my mind) because it reminds us that it is cell changes we care about. This in turn suggests that we begin each generation with exact copies of our current universe and neighbour arrays and then record the changes in one of them. At the end of the generation we again make exact copies of them. We\u2019ll see if this is any slower than allocating new universes and waiting for garbage collection to clean up the old ones as we do now[^*]. The framework to make all this happen looks like this, # Construct initial neighbours array n by looping over whole universe and counting neighbours. # This is just like the original doubly nested loop we used to have to count neighbours in the aging block. ... for ... # main loop # Copy next_u into u and next_n into n. for row in range(0, u_rows): for col in range(0, u_cols): u[row][col] = next_u[row][col] n[row][col] = next_n[row][col] # Age the universe: # Consider every cell in the universe for row in range(0, u_rows): for col in range(0, u_cols): if u[row][col] == 1 and (n[row][col] < 2 or n[row][col] > 3): next_u[row][col] = 0 # Update next_n to reflect this death by subtracting 1 from the neighbour # count of each of this cell's eight neighbours. # (While remembering that it's a toroidal universe!) ... elif u[row][col] == 0 and n[row][col] == 3: next_u[row][col] = 1 # Update next_n to reflect this birth by adding 1 to the neighbour # count of each of this cell's eight neighbours. # (And remembering that it's a toroidal universe!) ... # display(u) [^*] Didn\u2019t realize this is what we were doing? During the aging loop we had this, And afterward (at the start of the next aging loop) we had this,","title":"The New Aging Scheme"},{"location":"05.2_CGoL_3_Speed/05_Measure_again/","text":"Is it better? Measure Again Are the changes worth making? No guessing! Here are the measurements, >>> u_rows = 100 u_cols = 100 generations = 100 live_pct = 42 total_time : 0.93 copying_time : 0.50 = 53.22% aging_time : 0.44 = 46.78% >>> That\u2019s around 8 times faster or an 800% speed increase. Well worth doing. Which you will on the current assignment :-) (Hmm...I see that while we sped up the aging block we also slowed down the copying block. This is because we truly do copy now, whereas before we were renaming and then just allocating new blank memory (see the footnote on the previous page) without the requirement to loop over it assigning values, which we do have to do in the new scheme.)","title":"Is it better? Measure Again"},{"location":"05.2_CGoL_3_Speed/05_Measure_again/#is-it-better-measure-again","text":"Are the changes worth making? No guessing! Here are the measurements, >>> u_rows = 100 u_cols = 100 generations = 100 live_pct = 42 total_time : 0.93 copying_time : 0.50 = 53.22% aging_time : 0.44 = 46.78% >>> That\u2019s around 8 times faster or an 800% speed increase. Well worth doing. Which you will on the current assignment :-) (Hmm...I see that while we sped up the aging block we also slowed down the copying block. This is because we truly do copy now, whereas before we were renaming and then just allocating new blank memory (see the footnote on the previous page) without the requirement to loop over it assigning values, which we do have to do in the new scheme.)","title":"Is it better? Measure Again"},{"location":"06.1_MVC_2/00_index/","text":"MVC 2: Even more separation The Issue The Payoff Separating Controller and Quote A Quote Factory Adding More Object Types Your Turn MVC_controller.py MVC_model.py quote.py","title":"Contents"},{"location":"06.1_MVC_2/00_index/#mvc-2-even-more-separation","text":"The Issue The Payoff Separating Controller and Quote A Quote Factory Adding More Object Types Your Turn MVC_controller.py MVC_model.py quote.py","title":"MVC 2: Even more separation"},{"location":"06.1_MVC_2/01_The_issue/","text":"The Issue Our first pass at refactoring our text-controller/quote database application into an MVC architecture resulted in excellent separation of the model component from the view-controller, but the view-controller still has to know too much about the objects it is handling. Remember that one of the primary goals of MVC architecture is to allow development on the M, V and C components to proceed independently by insulating each component from the others. The problem with our existing code is that we cannot make changes to our object class Quote.py without also making changes to our controller, controller.py . I\u2019ve added a comment to each of the problematic lines below. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection # REFERENCES QUOTE r - retrieve a quote from the collection and display it # REFERENCES QUOTE u - update a quote in the collection # REFERENCES QUOTE d - delete a quote from the collection # REFERENCES QUOTE l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': # Create author = input('Who is the author of the quote? ') # REFERENCES QUOTE text = input('What did they say or write? ') # REFERENCES QUOTE obj = Quote(author, text) # QUOTE OBJECT model.create(obj) elif choice == 'r': # Retrieve uid = input( 'What is the uid of the object you wish to retrieve? ') if model.retrieve(uid): print(model.retrieve(uid)) else: print('Sorry your collection does not contain an object with that uid.') elif choice == 'u': # Update pass elif choice == 'd': # Delete uid = input( 'What is the uid of the object you wish to delete? ') if model.delete(uid): print(f'Object {uid:s} successfully deleted.') else: print(f'Object {uid:s} could not be deleted.') elif choice == 'l': # List print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': # Quit over = True else: print('Not a valid choice!') model.close() The issue: How can we free our controller from having to know about the innards of the objects it processes?","title":"The Issue"},{"location":"06.1_MVC_2/01_The_issue/#the-issue","text":"Our first pass at refactoring our text-controller/quote database application into an MVC architecture resulted in excellent separation of the model component from the view-controller, but the view-controller still has to know too much about the objects it is handling. Remember that one of the primary goals of MVC architecture is to allow development on the M, V and C components to proceed independently by insulating each component from the others. The problem with our existing code is that we cannot make changes to our object class Quote.py without also making changes to our controller, controller.py . I\u2019ve added a comment to each of the problematic lines below. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection # REFERENCES QUOTE r - retrieve a quote from the collection and display it # REFERENCES QUOTE u - update a quote in the collection # REFERENCES QUOTE d - delete a quote from the collection # REFERENCES QUOTE l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': # Create author = input('Who is the author of the quote? ') # REFERENCES QUOTE text = input('What did they say or write? ') # REFERENCES QUOTE obj = Quote(author, text) # QUOTE OBJECT model.create(obj) elif choice == 'r': # Retrieve uid = input( 'What is the uid of the object you wish to retrieve? ') if model.retrieve(uid): print(model.retrieve(uid)) else: print('Sorry your collection does not contain an object with that uid.') elif choice == 'u': # Update pass elif choice == 'd': # Delete uid = input( 'What is the uid of the object you wish to delete? ') if model.delete(uid): print(f'Object {uid:s} successfully deleted.') else: print(f'Object {uid:s} could not be deleted.') elif choice == 'l': # List print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': # Quit over = True else: print('Not a valid choice!') model.close() The issue: How can we free our controller from having to know about the innards of the objects it processes?","title":"The Issue"},{"location":"06.1_MVC_2/02_The_payoff/","text":"The Payoff: An ObjectServer Solving the issue (remember: How can we free our controller from having to know about the innards of the objects it processes? ) by separating our controller code from our Quote class will make it easier to work on our code by letting us work on each piece independently, but there is also a much bigger payoff. If we are able to completely separate the controller from the quote class (as we did the model last time around) then it should be easy to add new object types to the system, and instead of having a single purpose QuoteServer we should get, for free as it were, an ObjectServer that can store and retrieve any and all types of Python objects we might create. So as we disentangle the controller from the Quote class, let\u2019s keep the goal of being able to generalize to any type of object at all in mind.","title":"The Payoff: An ObjectServer"},{"location":"06.1_MVC_2/02_The_payoff/#the-payoff-an-objectserver","text":"Solving the issue (remember: How can we free our controller from having to know about the innards of the objects it processes? ) by separating our controller code from our Quote class will make it easier to work on our code by letting us work on each piece independently, but there is also a much bigger payoff. If we are able to completely separate the controller from the quote class (as we did the model last time around) then it should be easy to add new object types to the system, and instead of having a single purpose QuoteServer we should get, for free as it were, an ObjectServer that can store and retrieve any and all types of Python objects we might create. So as we disentangle the controller from the Quote class, let\u2019s keep the goal of being able to generalize to any type of object at all in mind.","title":"The Payoff: An ObjectServer"},{"location":"06.1_MVC_2/03_Separating_controller_and_quote/","text":"Separating Controller and Quote Back to the immediate issue: How can we free our controller from having to know about the innards of the objects it processes? Look again at our controller with the Quote-specific parts highlighted in are noted in the comments. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection # REFERENCES QUOTE r - retrieve a quote from the collection and display it # REFERENCES QUOTE u - update a quote in the collection # REFERENCES QUOTE d - delete a quote from the collection # REFERENCES QUOTE l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': # Create author = input('Who is the author of the quote? ') # REFERENCES QUOTE text = input('What did they say or write? ') # REFERENCES QUOTE obj = Quote(author, text) # QUOTE OBJECT model.create(obj) elif choice == 'r': # Retrieve uid = input( 'What is the uid of the object you wish to retrieve? ') if model.retrieve(uid): print(model.retrieve(uid)) else: print('Sorry your collection does not contain an object with that uid.') elif choice == 'u': # Update pass elif choice == 'd': # Delete uid = input( 'What is the uid of the object you wish to delete? ') if model.delete(uid): print(f'Object {uid:s} successfully deleted.') else: print(f'Object {uid:s} could not be deleted.') elif choice == 'l': # List print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': # Quit over = True else: print('Not a valid choice!') model.close() The striking thing is that only one our three CRD methods makes specific reference to Quote properties (note that Update isn\u2019t implemented in the code above, so we\u2019ll set it aside for the moment.). Retrieve and Delete are already able to work with generic objects since they only require a uid and no specific object properties to get their jobs done. (The only other place the quote class is referenced is in the user prompts and those we can quickly change to \u2019object\u2019.) So we want to remove the following code from MVC_Controller_0.py to somewhere else. if choice == 'c': # Create author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) To where? The only sensible answer is to Quote_0.py \u201d since it should be the Quote class\u2019s job to create Quote objects. But there is a bit of a chicken and egg problem here. We must get the user input about the quote object attributes author and text before we create a Quote object, but since there isn\u2019t a Quote object there is no self, and that means it can\u2019t be a Quote class method, but the Quote class is by careful design the only thing in Quote_0.py. So it seems that we are stuck because we can\u2019t prompt for object attributes until there is an object, but we also can\u2019t create an object until we have attributes (see chicken and egg). We are not the first programmers to encounter this problem, and several approaches have been worked out to deal with it. The one we will use is called the Factory Pattern. The rationale is this: Where do objects come from? They are made in factories. So if you want to create obejcts you need a factory to do it.","title":"Separating Controller and Quote"},{"location":"06.1_MVC_2/03_Separating_controller_and_quote/#separating-controller-and-quote","text":"Back to the immediate issue: How can we free our controller from having to know about the innards of the objects it processes? Look again at our controller with the Quote-specific parts highlighted in are noted in the comments. # MVC_controller_0.py from MVC_Model_0 import * from Quote_0 import * model_name = input('What model would you like to work with? ') model = Model(model_name) over = False while not over: print(''' Actions ------- c - create a quote to add to the collection # REFERENCES QUOTE r - retrieve a quote from the collection and display it # REFERENCES QUOTE u - update a quote in the collection # REFERENCES QUOTE d - delete a quote from the collection # REFERENCES QUOTE l - list all the items in the collection q - exit Your choice?''') choice = input() if choice == 'c': # Create author = input('Who is the author of the quote? ') # REFERENCES QUOTE text = input('What did they say or write? ') # REFERENCES QUOTE obj = Quote(author, text) # QUOTE OBJECT model.create(obj) elif choice == 'r': # Retrieve uid = input( 'What is the uid of the object you wish to retrieve? ') if model.retrieve(uid): print(model.retrieve(uid)) else: print('Sorry your collection does not contain an object with that uid.') elif choice == 'u': # Update pass elif choice == 'd': # Delete uid = input( 'What is the uid of the object you wish to delete? ') if model.delete(uid): print(f'Object {uid:s} successfully deleted.') else: print(f'Object {uid:s} could not be deleted.') elif choice == 'l': # List print('Here are the contents of the model', model_name, ':') model.listall() elif choice == 'q': # Quit over = True else: print('Not a valid choice!') model.close() The striking thing is that only one our three CRD methods makes specific reference to Quote properties (note that Update isn\u2019t implemented in the code above, so we\u2019ll set it aside for the moment.). Retrieve and Delete are already able to work with generic objects since they only require a uid and no specific object properties to get their jobs done. (The only other place the quote class is referenced is in the user prompts and those we can quickly change to \u2019object\u2019.) So we want to remove the following code from MVC_Controller_0.py to somewhere else. if choice == 'c': # Create author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) model.create(obj) To where? The only sensible answer is to Quote_0.py \u201d since it should be the Quote class\u2019s job to create Quote objects. But there is a bit of a chicken and egg problem here. We must get the user input about the quote object attributes author and text before we create a Quote object, but since there isn\u2019t a Quote object there is no self, and that means it can\u2019t be a Quote class method, but the Quote class is by careful design the only thing in Quote_0.py. So it seems that we are stuck because we can\u2019t prompt for object attributes until there is an object, but we also can\u2019t create an object until we have attributes (see chicken and egg). We are not the first programmers to encounter this problem, and several approaches have been worked out to deal with it. The one we will use is called the Factory Pattern. The rationale is this: Where do objects come from? They are made in factories. So if you want to create obejcts you need a factory to do it.","title":"Separating Controller and Quote"},{"location":"06.1_MVC_2/04_Quote_factory/","text":"A Quote Factory Here\u2019s what a Quote factory looks like: # quote.py # # Version 1 (archived as quote_1.py) # # Changes: # # - Changed naming convention to initial lower case to ease importing. # # - Added factory method to be called from controller when new Quote # object is required. # (for background see e.g. http://en.wikipedia.org/wiki/Factory_method_pattern). # # Version 0 (archived as Quote_0.py) # # - Initial version from module 4.2 MVC 1 earlier in course. def factory(): author = input('Who is the author of the quote? ') text = input('What did they say or write? ') return Quote(author, text) class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return f'[{self.uid:s}] {self.author:s}] ~ {self.text:s}' You can see the factory function above the Quote class. Function like this are called module methods , because the notation makes them look like methods of the module when we use them (remember that Python files are called modules ). For example: import quote q = quote.factory()# factory looks like a method of the module quote # (Which happens because it is!) The other small change to notice is that the module name has been changed from Quote_0.py to quote.py . There are a couple of reasons driving this. We change from capital Q Quote to lowercase q quote because Python convention is to use lower case names for modules that define classes. I\u2019ve removed the version information from the module name so it is called quote.py instead of quote_1.py , because when a software project grows and is made up of multiple modules it becomes tiresome and error-prone to have to edit the imports in other modules each time you update one module and change its name. Instead, the most up-to-date version will always have the name quote.py , but we will archive all versions with version numbers in their names as shown in the comments above. Python makes the archiving easy to do using the File \u2192 Save Copy As... menu command. Using the Quote factory the Create portion of our controller now looks like this: choice = input() if choice == 'c': # Create obj = quote.factory() # CHANGED model.create(obj) elif choice == 'r': # Retrieve ... Now our controller needs to know much less about Quote objects than it did before. In fact it just needs to know one thing: that the quote module will have a method called factory that will return a Python object.","title":"A Quote Factory"},{"location":"06.1_MVC_2/04_Quote_factory/#a-quote-factory","text":"Here\u2019s what a Quote factory looks like: # quote.py # # Version 1 (archived as quote_1.py) # # Changes: # # - Changed naming convention to initial lower case to ease importing. # # - Added factory method to be called from controller when new Quote # object is required. # (for background see e.g. http://en.wikipedia.org/wiki/Factory_method_pattern). # # Version 0 (archived as Quote_0.py) # # - Initial version from module 4.2 MVC 1 earlier in course. def factory(): author = input('Who is the author of the quote? ') text = input('What did they say or write? ') return Quote(author, text) class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return f'[{self.uid:s}] {self.author:s}] ~ {self.text:s}' You can see the factory function above the Quote class. Function like this are called module methods , because the notation makes them look like methods of the module when we use them (remember that Python files are called modules ). For example: import quote q = quote.factory()# factory looks like a method of the module quote # (Which happens because it is!) The other small change to notice is that the module name has been changed from Quote_0.py to quote.py . There are a couple of reasons driving this. We change from capital Q Quote to lowercase q quote because Python convention is to use lower case names for modules that define classes. I\u2019ve removed the version information from the module name so it is called quote.py instead of quote_1.py , because when a software project grows and is made up of multiple modules it becomes tiresome and error-prone to have to edit the imports in other modules each time you update one module and change its name. Instead, the most up-to-date version will always have the name quote.py , but we will archive all versions with version numbers in their names as shown in the comments above. Python makes the archiving easy to do using the File \u2192 Save Copy As... menu command. Using the Quote factory the Create portion of our controller now looks like this: choice = input() if choice == 'c': # Create obj = quote.factory() # CHANGED model.create(obj) elif choice == 'r': # Retrieve ... Now our controller needs to know much less about Quote objects than it did before. In fact it just needs to know one thing: that the quote module will have a method called factory that will return a Python object.","title":"A Quote Factory"},{"location":"06.1_MVC_2/05_Adding_more_object_types/","text":"Adding More Object Types Now that we have more separation between our controller and our object class let\u2019s take the next step towards an ObjectServer and see how our code will have to change to accomodate other objects besides Quotes. We\u2019ll have to ask our user what type of object they want to create and then branch to code to handle the creation of that type of object, so something like this would do the trick: choice = input() if choice == 'c': print('Object types:') print('1. Quotation') print('2. Riddle') print('3. Famous Programmer') obj_type = input('What type of object would you like to create? ') if obj_type == '1': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) elif obj_type == '2': text = input('What is the text of the riddle? ') answer = input('What is the answer to the riddle? ') obj = Riddle(text, answer) elif obj_type == '3': first_name = input('What is their first name? ') last_name = input('What is their last name? ') nationality = input('What is their nationality? ') source_of_fame = input('What are they famous for? ') obj = FamousProgrammer(first_name, last_name, nationality, source_of_fame) model.create(obj) elif choice == 'r': pass While this would work it doesn\u2019t take advantage of the quote module\u2019s factory method. Assuming the other modules for Riddles and FamousProgrammers would also be outfitted with factories the code can be shortened to: choice = input() if choice == 'c': print('Object types:') print('1. Quotation') print('2. Riddle') print('3. Famous Programmer') obj_type = input('What type of object would you like to create? ') if obj_type == '1': obj = quote.factory() elif obj_type == '2': obj = riddle.factory() elif obj_type == '3': obj = famousProgrammer.factory() model.create(obj) elif choice == 'r': pass (Note that we are establishing a convention here that our objects will be defined one to a module, and that each module will provide a factory method. This approach is known as programming by convention , in contrast to configuration where we would explicitly say, in for example a separate configuration file, what our classes are and what the names of each of their factories are, and where they may be found. Relying on conventions over explicit configuration is generally simpler and reduces the amount of code, but is not as flexible.) This is a further improvement, but there is an obvious repetitive pattern in the code, and it should be becoming second nature to us to replace repetitive code where we see it. In this case we can replace it like this: if choice == 'c': # Display menu of object choices: print('Which type of object do you want to create:') print('quote') print('riddle') print('famous_programmer') print('Hint: For the moment you _have_ to choose quote.') # Get the user's choice: obj_type = input('? ') # Call the appropriate object factory: obj = eval(obj_type+\".factory()\") # e.g. quote.factory() model.create(obj) First note that the menu of choices is changed from numerical choices, 1, 2, 3, to a list of module names. We use the module name input to build a string. For example if the user enters quote we build the string, quote.factory() . Then we execute that string as though it were a Python expression using the built-in function eval , so the line, obj = eval(obj_type+\".factory()\") # e.g. quote.factory() becomes in effect, obj = quote.factory() # e.g. quote.factory() This is our first small example of metaprogramming , the art of writing programs that write programs. In this case we wrote some code, that generates some other code, that we then execute. Metaprogramming is a very powerful technique that often allows for very short and expressive code that can respond to its execution context. Where might we go with this? Well imagine that we put all our class modules in one directory. We could scan that directory for the module names and build the menu of object choices programmatically. Once we had that in place we could add new object types to our ObjectServer by just dropping the class module into the right directory folder and not have to change our Controller (or Model) at all.","title":"Adding More Object Types"},{"location":"06.1_MVC_2/05_Adding_more_object_types/#adding-more-object-types","text":"Now that we have more separation between our controller and our object class let\u2019s take the next step towards an ObjectServer and see how our code will have to change to accomodate other objects besides Quotes. We\u2019ll have to ask our user what type of object they want to create and then branch to code to handle the creation of that type of object, so something like this would do the trick: choice = input() if choice == 'c': print('Object types:') print('1. Quotation') print('2. Riddle') print('3. Famous Programmer') obj_type = input('What type of object would you like to create? ') if obj_type == '1': author = input('Who is the author of the quote? ') text = input('What did they say or write? ') obj = Quote(author, text) elif obj_type == '2': text = input('What is the text of the riddle? ') answer = input('What is the answer to the riddle? ') obj = Riddle(text, answer) elif obj_type == '3': first_name = input('What is their first name? ') last_name = input('What is their last name? ') nationality = input('What is their nationality? ') source_of_fame = input('What are they famous for? ') obj = FamousProgrammer(first_name, last_name, nationality, source_of_fame) model.create(obj) elif choice == 'r': pass While this would work it doesn\u2019t take advantage of the quote module\u2019s factory method. Assuming the other modules for Riddles and FamousProgrammers would also be outfitted with factories the code can be shortened to: choice = input() if choice == 'c': print('Object types:') print('1. Quotation') print('2. Riddle') print('3. Famous Programmer') obj_type = input('What type of object would you like to create? ') if obj_type == '1': obj = quote.factory() elif obj_type == '2': obj = riddle.factory() elif obj_type == '3': obj = famousProgrammer.factory() model.create(obj) elif choice == 'r': pass (Note that we are establishing a convention here that our objects will be defined one to a module, and that each module will provide a factory method. This approach is known as programming by convention , in contrast to configuration where we would explicitly say, in for example a separate configuration file, what our classes are and what the names of each of their factories are, and where they may be found. Relying on conventions over explicit configuration is generally simpler and reduces the amount of code, but is not as flexible.) This is a further improvement, but there is an obvious repetitive pattern in the code, and it should be becoming second nature to us to replace repetitive code where we see it. In this case we can replace it like this: if choice == 'c': # Display menu of object choices: print('Which type of object do you want to create:') print('quote') print('riddle') print('famous_programmer') print('Hint: For the moment you _have_ to choose quote.') # Get the user's choice: obj_type = input('? ') # Call the appropriate object factory: obj = eval(obj_type+\".factory()\") # e.g. quote.factory() model.create(obj) First note that the menu of choices is changed from numerical choices, 1, 2, 3, to a list of module names. We use the module name input to build a string. For example if the user enters quote we build the string, quote.factory() . Then we execute that string as though it were a Python expression using the built-in function eval , so the line, obj = eval(obj_type+\".factory()\") # e.g. quote.factory() becomes in effect, obj = quote.factory() # e.g. quote.factory() This is our first small example of metaprogramming , the art of writing programs that write programs. In this case we wrote some code, that generates some other code, that we then execute. Metaprogramming is a very powerful technique that often allows for very short and expressive code that can respond to its execution context. Where might we go with this? Well imagine that we put all our class modules in one directory. We could scan that directory for the module names and build the menu of object choices programmatically. Once we had that in place we could add new object types to our ObjectServer by just dropping the class module into the right directory folder and not have to change our Controller (or Model) at all.","title":"Adding More Object Types"},{"location":"06.1_MVC_2/06_Your_turn/","text":"Your Turn You may recall that the our Controller never defined the Update operation. That\u2019s because I resisted hogging all the fun, and left it to you as an exercise for the assignment. In addition the assignment will have you implement another class that can be stored in our ObjectServer, e.g. a Riddle class or FamousProgrammer or other simple class of your choice. Use these modules as your starting points. quote.py MVC_model.py MVC_controller.py Read the version histories to see how they are changed from the previous versions you worked with. For the most part the changes are small, but they generally include: renaming modules to not include version numbers including more tests so that every method is called. As you change them be sure to save archival copies and to record your changes in version comments.","title":"Your Turn"},{"location":"06.1_MVC_2/06_Your_turn/#your-turn","text":"You may recall that the our Controller never defined the Update operation. That\u2019s because I resisted hogging all the fun, and left it to you as an exercise for the assignment. In addition the assignment will have you implement another class that can be stored in our ObjectServer, e.g. a Riddle class or FamousProgrammer or other simple class of your choice. Use these modules as your starting points. quote.py MVC_model.py MVC_controller.py Read the version histories to see how they are changed from the previous versions you worked with. For the most part the changes are small, but they generally include: renaming modules to not include version numbers including more tests so that every method is called. As you change them be sure to save archival copies and to record your changes in version comments.","title":"Your Turn"},{"location":"06.2_Mazes_1/00_index/","text":"Creating Mazes: A case study in OOP and algorithm development The Problem Approaches From English to Pseudocode Testing our Pseudocode Revising our pseudocode Data Structures (OOP) Initializing the Maze Add some debugging output Sharing walls Put the pieces together A starting point: maze_3.py","title":"Contents"},{"location":"06.2_Mazes_1/00_index/#creating-mazes-a-case-study-in-oop-and-algorithm-development","text":"The Problem Approaches From English to Pseudocode Testing our Pseudocode Revising our pseudocode Data Structures (OOP) Initializing the Maze Add some debugging output Sharing walls Put the pieces together A starting point: maze_3.py","title":"Creating Mazes: A case study in OOP and algorithm development"},{"location":"06.2_Mazes_1/01_The_problem/","text":"The Problem Something to think about... Consider the maze up above and the one below. How could one have a computer create more mazes like these?","title":"01 The problem"},{"location":"06.2_Mazes_1/01_The_problem/#the-problem","text":"Something to think about... Consider the maze up above and the one below. How could one have a computer create more mazes like these?","title":"The Problem"},{"location":"06.2_Mazes_1/02_Approaches/","text":"Approaches Not surprisingly there\u2019s more than one approach... Here\u2019s one: The algorithm starts by dividing the area into an array of rectangular cells, each with 4 walls. Each cell is given a region identifier. Then, at random, we find two cells in different regions, remove the intervening wall and combine the two regions into 1. We repeat this (width x height - 1) times. Now there is only one region which contains all the cells. This guarantees that there is a route from any cell to any other cell. Also, because we\u2019ve removed the smallest number of walls to achieve this state there will only be one direct route (ie. one that doesn\u2019t involve retracing your steps). And here\u2019s a lightly edited version of a maze carving approach from Robert Scott Ladd. Generate a new maze with all walls standing. The maze carving algorithm begins by selecting an entrance\u201d cell, opening the outside wall, and then following this algorithm: Pick a random direction, and move to the adjoining cell in that direction, if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Repeat the process until you reach a place that is surrounded by cells that have all already been visited. At this point, work your way back through the list of visited cells until you find one that does have an unvisited neighbor, and start carving again. The result is a maze with a long twisty solution and lots of long dead ends. And yet another from SlickCow: To draw a maze, first create some kind of outer shell with two holes--one that will function as a start and another as a finish. This shell determines the overall shape of your maze, so make it something interesting to look at. To add complexity, you have to draw internal lines, following one simple rule: any and every line you draw must be connected to some other line at one of its ends. That is, you should draw lines that branch out from a line that was already drawn. This forces your first line to be connected to some part of your outer shell, but your second line could be connected to either the shell or the first line. Your third line could be connected to either the shell, first, or second line... Go ahead and go crazy drawing lines. The more lines there are, the harder the maze becomes. A very fine tipped pencil or pen will allow for extremely complex mazes. It helps to leave the open end of lines at places people are likely to come to traversing the maze. This forces them to make a decision between at least two corridors... one is correct, the others must be wrong. Using this one rule, there will always be one and only one pathway from the start to the finish. Any line you draw without connections to other lines will not affect the navigation through the maze, but it could add certain aesthetic qualities. Any line you draw that has two connections presents an opportunity to block off the correct pathway from start to finish. It is something to be avoided. *","title":"02 Approaches"},{"location":"06.2_Mazes_1/02_Approaches/#approaches","text":"Not surprisingly there\u2019s more than one approach... Here\u2019s one: The algorithm starts by dividing the area into an array of rectangular cells, each with 4 walls. Each cell is given a region identifier. Then, at random, we find two cells in different regions, remove the intervening wall and combine the two regions into 1. We repeat this (width x height - 1) times. Now there is only one region which contains all the cells. This guarantees that there is a route from any cell to any other cell. Also, because we\u2019ve removed the smallest number of walls to achieve this state there will only be one direct route (ie. one that doesn\u2019t involve retracing your steps). And here\u2019s a lightly edited version of a maze carving approach from Robert Scott Ladd. Generate a new maze with all walls standing. The maze carving algorithm begins by selecting an entrance\u201d cell, opening the outside wall, and then following this algorithm: Pick a random direction, and move to the adjoining cell in that direction, if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Repeat the process until you reach a place that is surrounded by cells that have all already been visited. At this point, work your way back through the list of visited cells until you find one that does have an unvisited neighbor, and start carving again. The result is a maze with a long twisty solution and lots of long dead ends. And yet another from SlickCow: To draw a maze, first create some kind of outer shell with two holes--one that will function as a start and another as a finish. This shell determines the overall shape of your maze, so make it something interesting to look at. To add complexity, you have to draw internal lines, following one simple rule: any and every line you draw must be connected to some other line at one of its ends. That is, you should draw lines that branch out from a line that was already drawn. This forces your first line to be connected to some part of your outer shell, but your second line could be connected to either the shell or the first line. Your third line could be connected to either the shell, first, or second line... Go ahead and go crazy drawing lines. The more lines there are, the harder the maze becomes. A very fine tipped pencil or pen will allow for extremely complex mazes. It helps to leave the open end of lines at places people are likely to come to traversing the maze. This forces them to make a decision between at least two corridors... one is correct, the others must be wrong. Using this one rule, there will always be one and only one pathway from the start to the finish. Any line you draw without connections to other lines will not affect the navigation through the maze, but it could add certain aesthetic qualities. Any line you draw that has two connections presents an opportunity to block off the correct pathway from start to finish. It is something to be avoided. *","title":"Approaches"},{"location":"06.2_Mazes_1/03_Step_1_From_english_to_pseudcode/","text":"Step 1: From English to Pseudocode We are going to start by implementing the second approach. The first thing we are going to do is try and translate the english description to pseudocode. Here is my first pass. Generate a new maze with all walls standing. The maze carving algorithm begins by selecting an \"entrance\" cell, opening the outside wall, and then following this algorithm: Pick a random direction, move to the adjoining cell in that direction if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Repeat the process until you reach a place that is surrounded by cells that have all already been visited. At this point, work your way back through the list of visited cells until you find one that does have an unvisited neighbor, and start carving again. This has started to break the code into distinct actions, but they don't sound like python code. In particular there are some issues with how we've described the loops. The algorithm is actually a double loop, one loop until we find a cell that is surrounded, and then working back until we find a cell with an unvisited. Let's clean it up a little. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall while there are cells with unvisited neighbours while not all this cell's neighbours have been visited Pick a random direction, move to the adjoining cell in that direction if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, This tells us we have to keep carving as long as we have some cells that have never been reached. While at a given cell with unvisited neighbours pick a random direction that hasn't been visited. We are going to need to add some instructions to handle the cases where we accidentally pick a neighbour that has already been visited. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall while there are unvisited cells while not all this cell's neighbours have been visited Pick a random direction, if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, The added indentation gives us a better idea of the structure of the algorithm.","title":"Step 1: From English to Pseudocode"},{"location":"06.2_Mazes_1/03_Step_1_From_english_to_pseudcode/#step-1-from-english-to-pseudocode","text":"We are going to start by implementing the second approach. The first thing we are going to do is try and translate the english description to pseudocode. Here is my first pass. Generate a new maze with all walls standing. The maze carving algorithm begins by selecting an \"entrance\" cell, opening the outside wall, and then following this algorithm: Pick a random direction, move to the adjoining cell in that direction if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Repeat the process until you reach a place that is surrounded by cells that have all already been visited. At this point, work your way back through the list of visited cells until you find one that does have an unvisited neighbor, and start carving again. This has started to break the code into distinct actions, but they don't sound like python code. In particular there are some issues with how we've described the loops. The algorithm is actually a double loop, one loop until we find a cell that is surrounded, and then working back until we find a cell with an unvisited. Let's clean it up a little. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall while there are cells with unvisited neighbours while not all this cell's neighbours have been visited Pick a random direction, move to the adjoining cell in that direction if you haven\u2019t visited it before. Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from and the one you\u2019re in, then move to another randomly-selected adjacent cell. Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, This tells us we have to keep carving as long as we have some cells that have never been reached. While at a given cell with unvisited neighbours pick a random direction that hasn't been visited. We are going to need to add some instructions to handle the cases where we accidentally pick a neighbour that has already been visited. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall while there are unvisited cells while not all this cell's neighbours have been visited Pick a random direction, if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, The added indentation gives us a better idea of the structure of the algorithm.","title":"Step 1: From English to Pseudocode"},{"location":"06.2_Mazes_1/04_Step_2_Testing_our_pseudocode/","text":"Step 2: Testing our pseudocode Let's walk through our algorithm. First we have to generate a new maze with all the walls standing . -------------- | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- The next step is to select an entrance cell . We will also add an asterisk to mark our current location --- --------- | | *| | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- In general a maze cell only has 4 neighbours, but our starting cell has just 3 (one on the left, one below, and one on the right). None of our cell's neighbours have been visited. So we will begin the virst loop while there are univisited cells and the inner loop while not all this cell's neighbours have been visited . Then we will pick a random direction which will be to the right. We move to the adjoining cell in that direction and add the previous cell to the list of visited cells . Then we need to knock down the wall between the cell you came from . --- --------- | | v *| | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- Now we have reached the end of our inner while loop so we will loop back to our logic and check to see if not all this cell's neighbours have been visited . Interestingly, this cell now refers to our new location. Not all of our current cells have been visited, so we will pick a random neighbour, if we picked our left neighbour the if condition would not let us execute, so we would select again. Let us imagine we picked the cell below. --- --------- | | v v| | | |--+--+ +--+--| | | | *| | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- I will walk this algorithm several times until we first exit the inner while loop because we reach a cell where all its neighbours have been visited. --- --------- | | v v| * v| |--+--+ +--+ | | | | v v v| |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- At this stage we need to Work your way back through the list of visited cells until you find one that does have an unvisited neighbor . I'm not sure what should happen to the cell at the deadend, so I will leave it as a question mark, and trace back to the most recent cell that still has an unvisited neighbour. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v *| |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- Now we reenter the inner while loop and I will trace it until our next deadend. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | | | v| * v| |--+--+ +--+ | | | | v v v| -------------- Now we trace back to the most recent cell that still has an unvisited neighbour. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | | | v| ? v| |--+--+ +--+ | | | | * v v| -------------- We pick some more random directions until we hit a deadend. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | v v| v| ? v| | + + +--+ | | *| v v v v| -------------- So we backtrack. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | * v| v| ? v| | + + +--+ | | ?| v v v v| -------------- And we pick some more random directions until we hit a deadend. --- --------- | *| v v| ? v| | +--+ +--+ | | v| | v v v| | +--+--+--+ | | v| | v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- Then we backtrack. --- --------- | ?| v v| ? v| | +--+ +--+ | | *| | v v v| | +--+--+--+ | | v| | v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- And we pick some more random directions until we hit a deadend. --- --------- | ?| v v| ? v| | +--+ +--+ | | v v| v v v| | + +--+--+ | | v| *| v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- Then we backtrack. At this point there are no unvisited cells, so our backtracking will take us all the way back to our entrance. This changes our perception of the outer while loop a little. Instead of saying while there are univisited cells we can instead say while the list of visited cells is not empty . This means we will also need to add a cell to our list of visited cells before the loop. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall Put the entrance cell into visited list while list of visited cells is not empty while not all this cell's neighbours have been visited Pick a random direction, if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, This generates a pretty cute little maze. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | -------------- The last missing piece to our maze is the exit. So the last line of our pseudocode should be to randomly choose an exit point for the maze . We don't want the entrance and exit to be too close to each other, so we will choose the entrance from the top and the exit from the bottom row. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | ------------","title":"Step 2: Testing our pseudocode"},{"location":"06.2_Mazes_1/04_Step_2_Testing_our_pseudocode/#step-2-testing-our-pseudocode","text":"Let's walk through our algorithm. First we have to generate a new maze with all the walls standing . -------------- | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- The next step is to select an entrance cell . We will also add an asterisk to mark our current location --- --------- | | *| | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- In general a maze cell only has 4 neighbours, but our starting cell has just 3 (one on the left, one below, and one on the right). None of our cell's neighbours have been visited. So we will begin the virst loop while there are univisited cells and the inner loop while not all this cell's neighbours have been visited . Then we will pick a random direction which will be to the right. We move to the adjoining cell in that direction and add the previous cell to the list of visited cells . Then we need to knock down the wall between the cell you came from . --- --------- | | v *| | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- Now we have reached the end of our inner while loop so we will loop back to our logic and check to see if not all this cell's neighbours have been visited . Interestingly, this cell now refers to our new location. Not all of our current cells have been visited, so we will pick a random neighbour, if we picked our left neighbour the if condition would not let us execute, so we would select again. Let us imagine we picked the cell below. --- --------- | | v v| | | |--+--+ +--+--| | | | *| | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- I will walk this algorithm several times until we first exit the inner while loop because we reach a cell where all its neighbours have been visited. --- --------- | | v v| * v| |--+--+ +--+ | | | | v v v| |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- At this stage we need to Work your way back through the list of visited cells until you find one that does have an unvisited neighbor . I'm not sure what should happen to the cell at the deadend, so I will leave it as a question mark, and trace back to the most recent cell that still has an unvisited neighbour. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v *| |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | |--+--+--+--+--| | | | | | | -------------- Now we reenter the inner while loop and I will trace it until our next deadend. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | | | v| * v| |--+--+ +--+ | | | | v v v| -------------- Now we trace back to the most recent cell that still has an unvisited neighbour. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | | | v| ? v| |--+--+ +--+ | | | | * v v| -------------- We pick some more random directions until we hit a deadend. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | v v| v| ? v| | + + +--+ | | *| v v v v| -------------- So we backtrack. --- --------- | | v v| ? v| |--+--+ +--+ | | | | v v v| |--+--+--+--+ | | | | v v v| |--+--+ +--+--| | * v| v| ? v| | + + +--+ | | ?| v v v v| -------------- And we pick some more random directions until we hit a deadend. --- --------- | *| v v| ? v| | +--+ +--+ | | v| | v v v| | +--+--+--+ | | v| | v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- Then we backtrack. --- --------- | ?| v v| ? v| | +--+ +--+ | | *| | v v v| | +--+--+--+ | | v| | v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- And we pick some more random directions until we hit a deadend. --- --------- | ?| v v| ? v| | +--+ +--+ | | v v| v v v| | + +--+--+ | | v| *| v v v| | +--+ +--+--| | v v| v| ? v| | + + +--+ | | ?| v v v v| -------------- Then we backtrack. At this point there are no unvisited cells, so our backtracking will take us all the way back to our entrance. This changes our perception of the outer while loop a little. Instead of saying while there are univisited cells we can instead say while the list of visited cells is not empty . This means we will also need to add a cell to our list of visited cells before the loop. Generate a new maze with all walls standing. Select an \"entrance\" cell, opening the outside wall Put the entrance cell into visited list while list of visited cells is not empty while not all this cell's neighbours have been visited Pick a random direction, if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, This generates a pretty cute little maze. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | -------------- The last missing piece to our maze is the exit. So the last line of our pseudocode should be to randomly choose an exit point for the maze . We don't want the entrance and exit to be too close to each other, so we will choose the entrance from the top and the exit from the bottom row. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | ------------","title":"Step 2: Testing our pseudocode"},{"location":"06.2_Mazes_1/05_Step_3_Revise_pseudocode/","text":"Step 3: Revising our pseudocode Let's look at the pseudocode and tidy it up a bit more. We are going to focus on increasing the efficiency of the instructions Pick a random direction , which will result in us picking an already visited cell (especially as we increase the amount of the maze that has already been visited). Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall opening the outside wall # unclear language what does opening mean? # we need to make a visited list before we can add to it Put the entrance cell into visited list while list of visited cells is not empty: # this is wasteful, because we often pick a cell that has been visitied # instead we want to pick from a set of possible directions while not all this cell's neighbours have been visited Pick a random direction if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from # this next steps will be triggered when the list of visited neighbours is empty Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, Randomly choose an exit point for the maze in the bottom outer wall We are going to create a list of the current cell's vistiable neighbours and choose our next cell from that. If the list isn't empty we will select from it and continue through the inner loop, otherwise if it is empty we will backtrack to a neighbour that has unvisited neighbours. Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall break the exterior wall of the entrance cell visited_cells = [] Add entrance cell to visited list while list of visited cells is not empty build a list of the current cell's visitable neighbours check the four neighbours if cell is inside the maze and the cell hasn't been visited add cell to the visitable list if list is not empty pick a cell randomly from the list make chosen cell be the current cells add previous cell to visited list break wall between cells else # if the list is empty # we need to back up, pop would be helpful set current cell to be be visited_cells[index-1] Randomly choose an exit point for the maze in the bottom outer wall The list of visited cells should also store the order that we visited them. We did this naturally when we walked through the algorithm, but it should be explicit in our code. We are going to change our variable name from visited_cells to visited_path. When it is time to backtrack on our path we will use pop to remove the last cell from the path, so that we can continue back to a new branching point in our maze (a cell with an unvisited neighbour). Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall break the exterior wall of the entrance cell visited_path = [] Add entrance cell to visited list while visited_path is not empty build a list of the current cell's visitable neighbours check the four neighbours if cell is inside the maze and the cell hasn't been visited add cell to the visitable list if list is not empty pick a cell randomly from the list make chosen cell be the current cells add previous cell to visited list break wall between cells else # if the list is empty pop this cell off visited_path and use one at end of visited_path as current cell Randomly choose an exit point for the maze in the bottom outer wall # Some thoughts about how we will tell if a cell has been visited How to tell is a cell has been visited: 1) \"Calculate\" it by checking how many walls it has. 2) Remember it, i.e. store that fact somewhere in cell (object).","title":"Step 3: Revising our pseudocode"},{"location":"06.2_Mazes_1/05_Step_3_Revise_pseudocode/#step-3-revising-our-pseudocode","text":"Let's look at the pseudocode and tidy it up a bit more. We are going to focus on increasing the efficiency of the instructions Pick a random direction , which will result in us picking an already visited cell (especially as we increase the amount of the maze that has already been visited). Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall opening the outside wall # unclear language what does opening mean? # we need to make a visited list before we can add to it Put the entrance cell into visited list while list of visited cells is not empty: # this is wasteful, because we often pick a cell that has been visitied # instead we want to pick from a set of possible directions while not all this cell's neighbours have been visited Pick a random direction if the cell in that direction hasn't been visited move to the adjoining cell in that direction Add the previous cell location to the list of visited cells. Knock out the wall between the cell you came from # this next steps will be triggered when the list of visited neighbours is empty Work your way back through the list of visited cells until you find one that does have an unvisited neighbor, Randomly choose an exit point for the maze in the bottom outer wall We are going to create a list of the current cell's vistiable neighbours and choose our next cell from that. If the list isn't empty we will select from it and continue through the inner loop, otherwise if it is empty we will backtrack to a neighbour that has unvisited neighbours. Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall break the exterior wall of the entrance cell visited_cells = [] Add entrance cell to visited list while list of visited cells is not empty build a list of the current cell's visitable neighbours check the four neighbours if cell is inside the maze and the cell hasn't been visited add cell to the visitable list if list is not empty pick a cell randomly from the list make chosen cell be the current cells add previous cell to visited list break wall between cells else # if the list is empty # we need to back up, pop would be helpful set current cell to be be visited_cells[index-1] Randomly choose an exit point for the maze in the bottom outer wall The list of visited cells should also store the order that we visited them. We did this naturally when we walked through the algorithm, but it should be explicit in our code. We are going to change our variable name from visited_cells to visited_path. When it is time to backtrack on our path we will use pop to remove the last cell from the path, so that we can continue back to a new branching point in our maze (a cell with an unvisited neighbour). Generate a new maze with all walls standing. Select an \"entrance\" cell in the top outer wall break the exterior wall of the entrance cell visited_path = [] Add entrance cell to visited list while visited_path is not empty build a list of the current cell's visitable neighbours check the four neighbours if cell is inside the maze and the cell hasn't been visited add cell to the visitable list if list is not empty pick a cell randomly from the list make chosen cell be the current cells add previous cell to visited list break wall between cells else # if the list is empty pop this cell off visited_path and use one at end of visited_path as current cell Randomly choose an exit point for the maze in the bottom outer wall # Some thoughts about how we will tell if a cell has been visited How to tell is a cell has been visited: 1) \"Calculate\" it by checking how many walls it has. 2) Remember it, i.e. store that fact somewhere in cell (object).","title":"Step 3: Revising our pseudocode"},{"location":"06.2_Mazes_1/06_Step_4_OOP/","text":"Step 4: Data structures (OOP) Before we consider our algorithm further, we first need to think about how we are going to refer to things like cells and walls. Let's start with our maze and think about how we are going to represent it. It is time to consider our objects. A maze has a grid or array of cells, and each one of those cells can have up to four walls. Walls can be broken up into two types: interior walls that are broken all the time and exterior walls that are only broken at the very beginning and end of the algorithm. Cells also need to track whether they've been visited or not. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | ------------ A maze is an array of cells, each of which has four walls, and may or may not have been visited. Walls can be exterior, interior, or doors (broken walls). Let's start to build some classes for this description. # maze_2.py class Wall: def __init__(self,s): self.state = s # exterior, interior, or door class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] # we will need to initialize an array of cells def carve(self): pass def display(self): pass if __name__ == '__init__': m = Maze(5,5) m.carve() m = m.display() Next we need to flesh out our classes.","title":"Step 4: Data structures (OOP)"},{"location":"06.2_Mazes_1/06_Step_4_OOP/#step-4-data-structures-oop","text":"Before we consider our algorithm further, we first need to think about how we are going to refer to things like cells and walls. Let's start with our maze and think about how we are going to represent it. It is time to consider our objects. A maze has a grid or array of cells, and each one of those cells can have up to four walls. Walls can be broken up into two types: interior walls that are broken all the time and exterior walls that are only broken at the very beginning and end of the algorithm. Cells also need to track whether they've been visited or not. --- --------- | | | | | +--+ +--+ | | | | | + +--+--+ | | | | | | +--+ +--+--| | | | | | + + +--+ | | | | ------------ A maze is an array of cells, each of which has four walls, and may or may not have been visited. Walls can be exterior, interior, or doors (broken walls). Let's start to build some classes for this description. # maze_2.py class Wall: def __init__(self,s): self.state = s # exterior, interior, or door class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] # we will need to initialize an array of cells def carve(self): pass def display(self): pass if __name__ == '__init__': m = Maze(5,5) m.carve() m = m.display() Next we need to flesh out our classes.","title":"Step 4: Data structures (OOP)"},{"location":"06.2_Mazes_1/07_Step_5_Initializing_maze/","text":"Step 5: Initializing the maze The maze will need to be initialized at the beginning or our program. It will have only interior and exterior walls (no doors). The exterior walls will only be associated with our first and last rows and columns. That means that the interior cells will be initialized slightly differently than our outside cells. The interior cells will all have 4 interior walls. The corners will have 2 exterior walls and 2 interior walls. The rest of the exterior cells will have 3 interior walls and 1 exterior wall. We are going to consider the top, bottom, and middle rows as separate cases. In each of those cases we will consider the left, right, and middle columns separately. ============== || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ============== # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), Wall(INT))) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(INT))) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(Wall(INT), Wall(EXT), Wall(EXT), Wall(INT))) else: # bottom middle row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(INT))) else: # middle if c == 0: # left row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(Wall(INT), Wall(EXT), Wall(INT), Wall(INT))) else: # middle row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(INT))) self.cells.append(row) def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() To test that this code is working we are going to need to work on our display.","title":"Step 5: Initializing the maze"},{"location":"06.2_Mazes_1/07_Step_5_Initializing_maze/#step-5-initializing-the-maze","text":"The maze will need to be initialized at the beginning or our program. It will have only interior and exterior walls (no doors). The exterior walls will only be associated with our first and last rows and columns. That means that the interior cells will be initialized slightly differently than our outside cells. The interior cells will all have 4 interior walls. The corners will have 2 exterior walls and 2 interior walls. The rest of the exterior cells will have 3 interior walls and 1 exterior wall. We are going to consider the top, bottom, and middle rows as separate cases. In each of those cases we will consider the left, right, and middle columns separately. ============== || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ||--+--+--+--+--|| || | | | | || ============== # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), Wall(INT))) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(INT))) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(Wall(INT), Wall(EXT), Wall(EXT), Wall(INT))) else: # bottom middle row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(INT))) else: # middle if c == 0: # left row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(Wall(INT), Wall(EXT), Wall(INT), Wall(INT))) else: # middle row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(INT))) self.cells.append(row) def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() To test that this code is working we are going to need to work on our display.","title":"Step 5: Initializing the maze"},{"location":"06.2_Mazes_1/08_Step_6_Debugging_output/","text":"Step 6: Adding debugging output To debug this we are going to need to be able to dispay the current maze. That doesn't necessarily look like the pretty display we will eventually do with pygame, where we might not want to track things like exterior vs interior walls, or whether a cell has been visited. The display for debugging won't necessarily even look like a maze. We are going to do this by writing an __str__ method. We will need to write an __str__ method for the Maze, which call the __str__ method of the Cell, which will call the __str__ method of the Wall. # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False def __str__(self): s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s+= 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), Wall(INT))) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(INT))) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(Wall(INT), Wall(EXT), Wall(EXT), Wall(INT))) else: # bottom middle row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(INT))) else: # middle if c == 0: # left row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(Wall(INT), Wall(EXT), Wall(INT), Wall(INT))) else: # middle row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(INT))) self.cells.append(row) def __str__(self): s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' # add a space after each cell s += '\\n' return s def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) The output of this code will look like this... EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU","title":"Step 6: Adding debugging output"},{"location":"06.2_Mazes_1/08_Step_6_Debugging_output/#step-6-adding-debugging-output","text":"To debug this we are going to need to be able to dispay the current maze. That doesn't necessarily look like the pretty display we will eventually do with pygame, where we might not want to track things like exterior vs interior walls, or whether a cell has been visited. The display for debugging won't necessarily even look like a maze. We are going to do this by writing an __str__ method. We will need to write an __str__ method for the Maze, which call the __str__ method of the Cell, which will call the __str__ method of the Wall. # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False def __str__(self): s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s+= 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), Wall(INT))) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(INT))) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(Wall(INT), Wall(EXT), Wall(EXT), Wall(INT))) else: # bottom middle row.append(Cell(Wall(INT), Wall(INT), Wall(EXT), Wall(INT))) else: # middle if c == 0: # left row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(Wall(INT), Wall(EXT), Wall(INT), Wall(INT))) else: # middle row.append(Cell(Wall(INT), Wall(INT), Wall(INT), Wall(INT))) self.cells.append(row) def __str__(self): s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' # add a space after each cell s += '\\n' return s def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) The output of this code will look like this... EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU","title":"Step 6: Adding debugging output"},{"location":"06.2_Mazes_1/09_Step_7_Sharing_walls/","text":"Step 7: Sharing walls There is one problem with our representation. The interior walls between adjacent cells are shared. Right now if we knocked down a wall between two adjacent cells we would have to adjust the walls in two different cells (either the north of on and the south of the other, or the east of one and the west of the other). If we think about our maze, what we would actually like if for those two walls to be the same wall. We can do that by using a shared reference to the same Wall object in the adjacent Cell s. Shared references are commonly used when formatting tables on webpages or in Microsoft Word. This is also needed when adding borders to cells in Excel spreadsheets. To see this problem we're going to manually take the east wall from the cell at position (1,1). if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) m.cells[1][1].east.state = DOOR print(m) The output of this code will look like this... EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IDIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU Because we have not set up shared references the door appears in the east wall of cell[1][1] , but does not show up in the west wall of cell[1][2] . The problem is that every time we initialized a cell we created 4 new walls. That had to happen for the first cell, but after that we should have begun to share our references. We are going to do that by accessing the walls we've built using the indexes of those cells. The west wall of each new cell added to our row will be equal to the east wall of the previous cell in the row. We will use the same logic for the north walls in each subsequent row will be equal to the south wall of the cell above it. # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False def __str__(self): s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s+= 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), row[c-1].east)) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), row[c-1].east)) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(self.cells[r-1][c].south, Wall(EXT), Wall(EXT), row[c-1].east)) else: # bottom middle row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), row[c-1].east)) else: # middle if c == 0: # left row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(self.cells[r-1][c].south, Wall(EXT), Wall(INT), row[c-1].east)) else: # middle row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), row[c-1].east)) self.cells.append(row) def __str__(self): s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' # add a space after each cell s += '\\n' return s def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) # Now check that wall references are truly shared between cells # we'll manually create this: ## =======D====== ##|| | | | | || ##||--+--+--+--+--|| ##|| | D | | || ##||--+--+--+--+--|| ##|| | | | | || ##||--+--+--+D-+--|| ##|| | | | | || ##||--+--+--+--+--|| ##|| | | | | || ## ============== m.cells[1][1].east.state = DOOR m.cells[0][2].north.state = DOOR m.cells[2][3].south.state = DOOR print(m) I've added some more wall breaks, one in an exterior wall and two in interior walls. Let's see how they show up. EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU EIIEU EIIIU DIIIU EIIIU EEIIU IIIEU IDIIU IIIDU IIIIU IEIIU IIIEU IIIIU IIIIU IIDIU IEIIU IIIEU IIIIU IIIIU DIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU Looking at this closely it looks like we now have working shared references. We've created some really robust data structure, with some built in debugging with our str routine. The next steps are to program the carve to create the maze, as well as an elegeant display to show our final product in pygame.","title":"Step 7: Sharing walls"},{"location":"06.2_Mazes_1/09_Step_7_Sharing_walls/#step-7-sharing-walls","text":"There is one problem with our representation. The interior walls between adjacent cells are shared. Right now if we knocked down a wall between two adjacent cells we would have to adjust the walls in two different cells (either the north of on and the south of the other, or the east of one and the west of the other). If we think about our maze, what we would actually like if for those two walls to be the same wall. We can do that by using a shared reference to the same Wall object in the adjacent Cell s. Shared references are commonly used when formatting tables on webpages or in Microsoft Word. This is also needed when adding borders to cells in Excel spreadsheets. To see this problem we're going to manually take the east wall from the cell at position (1,1). if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) m.cells[1][1].east.state = DOOR print(m) The output of this code will look like this... EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IDIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU Because we have not set up shared references the door appears in the east wall of cell[1][1] , but does not show up in the west wall of cell[1][2] . The problem is that every time we initialized a cell we created 4 new walls. That had to happen for the first cell, but after that we should have begun to share our references. We are going to do that by accessing the walls we've built using the indexes of those cells. The west wall of each new cell added to our row will be equal to the east wall of the previous cell in the row. We will use the same logic for the north walls in each subsequent row will be equal to the south wall of the cell above it. # maze_2.py # Define our wall states (INT,EXT,DOOR) = list(range(3)) class Wall: def __init__(self,s): self.state = s # exterior, interior, or door def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): self.north = n self.east = e self.south = s self.west = w self.visited = False def __str__(self): s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s+= 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # top if c == 0: # top left row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # top right row.append(Cell(Wall(EXT), Wall(EXT), Wall(INT), row[c-1].east)) else: # top middle row.append(Cell(Wall(EXT), Wall(INT), Wall(INT), row[c-1].east)) elif r == self.height - 1: # bottom if c == 0: # bottom left row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # bottom right row.append(Cell(self.cells[r-1][c].south, Wall(EXT), Wall(EXT), row[c-1].east)) else: # bottom middle row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), row[c-1].east)) else: # middle if c == 0: # left row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # right row.append(Cell(self.cells[r-1][c].south, Wall(EXT), Wall(INT), row[c-1].east)) else: # middle row.append(Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), row[c-1].east)) self.cells.append(row) def __str__(self): s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' # add a space after each cell s += '\\n' return s def carve(self): pass def display(self): pass if __name__ == '__main__': m = Maze(5,5) m.carve() m.display() print(m) # Now check that wall references are truly shared between cells # we'll manually create this: ## =======D====== ##|| | | | | || ##||--+--+--+--+--|| ##|| | D | | || ##||--+--+--+--+--|| ##|| | | | | || ##||--+--+--+D-+--|| ##|| | | | | || ##||--+--+--+--+--|| ##|| | | | | || ## ============== m.cells[1][1].east.state = DOOR m.cells[0][2].north.state = DOOR m.cells[2][3].south.state = DOOR print(m) I've added some more wall breaks, one in an exterior wall and two in interior walls. Let's see how they show up. EIIEU EIIIU EIIIU EIIIU EEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIIEU IIIIU IIIIU IIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU EIIEU EIIIU DIIIU EIIIU EEIIU IIIEU IDIIU IIIDU IIIIU IEIIU IIIEU IIIIU IIIIU IIDIU IEIIU IIIEU IIIIU IIIIU DIIIU IEIIU IIEEU IIEIU IIEIU IIEIU IEEIU Looking at this closely it looks like we now have working shared references. We've created some really robust data structure, with some built in debugging with our str routine. The next steps are to program the carve to create the maze, as well as an elegeant display to show our final product in pygame.","title":"Step 7: Sharing walls"},{"location":"06.2_Mazes_1/10_Step_8_Put_the_pieces_together/","text":"Step 8: Putting the pieces together Here is the last version of the code before you finish the program for your assignment. We've added some comments, and included the pseudocode for the carve method. The display method in pygame will look very similar to our initialization code for the maze, in that you will need to loop through each cell and decide when to draw lines and when not to. There will also be a bit of arithmetic to decide the size of the cells. # maze_3.py # # A Maze is an array of Cells, each of which has four Walls, # and may or may not have been visited. (INT, EXT, DOOR) = list(range(3)) class Wall: def __init__(self, s): self.state = s def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): # Four walls: self.north = n self.east = e self.south = s self.west = w # Flag for whether it has been visited or not. self.visited = False def __str__(self): ''' Display to aid in development and debugging, NOT meant for users' eyes. ''' s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s += 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # Top row if c == 0: # Leftmost cell # North East South West row.append( Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(Wall(EXT), Wall(EXT), Wall(INT), row[c-1].east)) else: # Middle cells row.append( Cell(Wall(EXT), Wall(INT), Wall(INT), row[c-1].east)) elif r == self.height - 1: # Bottom row if c == 0: # Leftmost cell row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(self.cells[r-1][c].south, Wall(EXT), Wall(EXT), row[c-1].east)) else: # Middle cells row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), row[c-1].east)) else: # Interior row if c == 0: # Leftmost cell row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(self.cells[r-1][c].south, Wall(EXT), Wall(INT), row[c-1].east)) else: # Middle cells row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), row[c-1].east)) self.cells.append(row) def __str__(self): ''' Display to aid in development and debugging, NOT meant for users' eyes. ''' s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' s += '\\n' return s def carve(self): ## Generate a new maze with all walls standing. ## Select an \"entrance\" cell in the top outer wall. ## Break the exterior wall of this entrance cell. ## visited_path = [] ## Add the entrance cell to visited_path ## while visited_path isn't empty: ## build list of curent cell's visitable neighbours ## check four neighbours ## if cell is inside the maze ## and cell hasn't already been visited ## Add cell to visitable list ## if visitable list is not empty: ## pick a cell randomly from the list ## make chosen cell be the current cell ## add previous cell to visited list ## break wall between the previous cell and this one ## else: # list is empty ## pop this cell off visited_path ## and use the one at end of visited_path as current cell ## Randomly choose an exit point for the maze in bottom outer wall pass def display(self): ''' Pygame display of maze. ''' pass if __name__ == '__main__': m = Maze(5,5) print(m) # Now check that wall references are truly shared between cells # we'll manually create this: ## =======D====== ##|| | | | | || ##||--+--+--+--+--|| ##|| | D | | || ##||--+--+--+--+--|| ##|| | | | | || ##||--+--+--+D-+--|| ##|| | | | | || ##||--+--+--+--+--|| ##|| | | | | || ## ============== m.cells[1][1].east.state = DOOR m.cells[0][2].north.state = DOOR m.cells[2][3].south.state = DOOR print(m) m = Maze(25, 25) m.carve() m.display() # Using Pygame.","title":"Step 8: Putting the pieces together"},{"location":"06.2_Mazes_1/10_Step_8_Put_the_pieces_together/#step-8-putting-the-pieces-together","text":"Here is the last version of the code before you finish the program for your assignment. We've added some comments, and included the pseudocode for the carve method. The display method in pygame will look very similar to our initialization code for the maze, in that you will need to loop through each cell and decide when to draw lines and when not to. There will also be a bit of arithmetic to decide the size of the cells. # maze_3.py # # A Maze is an array of Cells, each of which has four Walls, # and may or may not have been visited. (INT, EXT, DOOR) = list(range(3)) class Wall: def __init__(self, s): self.state = s def __str__(self): s = '' if self.state == INT: s += 'I' elif self.state == EXT: s += 'E' elif self.state == DOOR: s += 'D' return s class Cell: def __init__(self, n, e, s, w): # Four walls: self.north = n self.east = e self.south = s self.west = w # Flag for whether it has been visited or not. self.visited = False def __str__(self): ''' Display to aid in development and debugging, NOT meant for users' eyes. ''' s = '' s += str(self.north) s += str(self.east) s += str(self.south) s += str(self.west) if self.visited: s += 'V' else: s += 'U' return s class Maze: def __init__(self, w, h): self.width = w self.height = h self.cells = [] for r in range(self.height): # Build a row of cells and append it to self.cells row = [] for c in range(self.width): if r == 0: # Top row if c == 0: # Leftmost cell # North East South West row.append( Cell(Wall(EXT), Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(Wall(EXT), Wall(EXT), Wall(INT), row[c-1].east)) else: # Middle cells row.append( Cell(Wall(EXT), Wall(INT), Wall(INT), row[c-1].east)) elif r == self.height - 1: # Bottom row if c == 0: # Leftmost cell row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(self.cells[r-1][c].south, Wall(EXT), Wall(EXT), row[c-1].east)) else: # Middle cells row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(EXT), row[c-1].east)) else: # Interior row if c == 0: # Leftmost cell row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), Wall(EXT))) elif c == self.width - 1: # Rightmost cell row.append( Cell(self.cells[r-1][c].south, Wall(EXT), Wall(INT), row[c-1].east)) else: # Middle cells row.append( Cell(self.cells[r-1][c].south, Wall(INT), Wall(INT), row[c-1].east)) self.cells.append(row) def __str__(self): ''' Display to aid in development and debugging, NOT meant for users' eyes. ''' s = '' for r in range(self.height): for c in range(self.width): s += str(self.cells[r][c]) s += ' ' s += '\\n' return s def carve(self): ## Generate a new maze with all walls standing. ## Select an \"entrance\" cell in the top outer wall. ## Break the exterior wall of this entrance cell. ## visited_path = [] ## Add the entrance cell to visited_path ## while visited_path isn't empty: ## build list of curent cell's visitable neighbours ## check four neighbours ## if cell is inside the maze ## and cell hasn't already been visited ## Add cell to visitable list ## if visitable list is not empty: ## pick a cell randomly from the list ## make chosen cell be the current cell ## add previous cell to visited list ## break wall between the previous cell and this one ## else: # list is empty ## pop this cell off visited_path ## and use the one at end of visited_path as current cell ## Randomly choose an exit point for the maze in bottom outer wall pass def display(self): ''' Pygame display of maze. ''' pass if __name__ == '__main__': m = Maze(5,5) print(m) # Now check that wall references are truly shared between cells # we'll manually create this: ## =======D====== ##|| | | | | || ##||--+--+--+--+--|| ##|| | D | | || ##||--+--+--+--+--|| ##|| | | | | || ##||--+--+--+D-+--|| ##|| | | | | || ##||--+--+--+--+--|| ##|| | | | | || ## ============== m.cells[1][1].east.state = DOOR m.cells[0][2].north.state = DOOR m.cells[2][3].south.state = DOOR print(m) m = Maze(25, 25) m.carve() m.display() # Using Pygame.","title":"Step 8: Putting the pieces together"},{"location":"07.1_Sorting_2/00_index/","text":"Sorting and Algorithm Analysis 2 Introduction Quicksort A more Pythonic Quicksort Representing a tree using a list Heapsort","title":"Contents"},{"location":"07.1_Sorting_2/00_index/#sorting-and-algorithm-analysis-2","text":"Introduction Quicksort A more Pythonic Quicksort Representing a tree using a list Heapsort","title":"Sorting and Algorithm Analysis 2"},{"location":"07.1_Sorting_2/01_Introduction/","text":"Introduction This week we\u2019ll tackle the two best performing sorting algorithms presented in Sorting Out Sorting . On the downside this means it is back to tricky algorithms. On the upside the code is very short. And there are still no tricky data structures!","title":"Introduction"},{"location":"07.1_Sorting_2/01_Introduction/#introduction","text":"This week we\u2019ll tackle the two best performing sorting algorithms presented in Sorting Out Sorting . On the downside this means it is back to tricky algorithms. On the upside the code is very short. And there are still no tricky data structures!","title":"Introduction"},{"location":"07.1_Sorting_2/02_Quicksort_1/","text":"Quicksort The portion of the film Sorting out Sorting provides fairly detailed instructions for Quicksort: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning forward from the front of the list look for a value larger than the pivot Scanning backwards from the end of the list look for a value smaller than the pivot if the larger value is to the left of the smaller value: Exchange the two values Continue this until the scanners cross (which means the values are separated) Move pivot into the \"middle\" Call recursively on both parts of the list This sounds precise enough to be translated into Python, so let\u2019s give it a try. Set the first element to be the pivot If we call our list lst , this is just: ``` python pivot = lst[0] ``` Scanning forward from the front of the list look for a value larger than the pivot This is a loop starting at the front of the list and moving toward the back looking for values larger than the pivot: ``` python lo = 1 while lst[lo] < pivot: lo = lo + 1 ``` Why start `lo` at 1? Because we do not want to consider the pivot element itself which is in position 0. Note that this loop will stop at values greater than or equal to the pivot (not just greater than). Is this right? Hard to tell right now, but we\u2019ll keep it in mind as a possible problem. Scanning backwards from the end of the list look for a value smaller than the pivot This is similar to above, but starting at the end of the list, and moving toward the front. ``` python hi = len(lst) - 1 while lst[hi] > pivot: hi = hi - 1 ``` if the larger value is to the left of the smaller value: If the larger value is to the left of the smaller value, it\u2019s index, lo , will be smaller than the smaller value\u2019s index, hi : ``` python if lo < hi: ``` Exchange the two values We can use the old tuple trick\u201d to swap the values, ``` python (lst[lo], lst[hi]) = (lst[hi], lst[lo]) ``` Continue this until the scanners cross (which means the values are separated) _Continue_ and _until_ indicate we need to loop. Python does not support _until_ loops so we\u2019ll have to reverse the logic to express it as a `while` loop. This means that _until_ the scanners cross\u201d becomes, _While_ the scanners _haven\u2019t_ crossed\u201d. This while statement goes at the top of the loop body: ``` python while lo < hi: ``` Let\u2019s put these pieces together and see what we have so far: pivot = lst[0] while lo < hi: lo = 1 while lst[lo] < pivot: lo = lo + 1 hi = len(lst) - 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) Obviously the initialization of lo and hi should be moved outside the loop, pivot = lst[0] lo = 1 hi = len(lst) - 1 while lo < hi: while lst[lo] < pivot: lo = lo + 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) The last bits to complete the function are to exchange the pivot into position and call the function again. Watching the film we can see that the pivot is exchanged with the element where the index hi ends up. And calling the sort on each part of the list just requires us to package our code into a function and call it on each part: # quicksort_v1.py def quicksort(lst): print('Before:', lst) pivot = lst[0] lo = 1 hi = len(lst) - 1 while lo < hi: while lst[lo] < pivot: lo = lo + 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) if lst[0] > lst[hi]: (lst[0], lst[hi]) = (lst[hi], lst[0]) print('After:', lst) quicksort(lst[0:hi]) quicksort(lst[lo:]) l = [49, 12, 67, 87, 21, 94, 24, 73, 69, 34] print(quicksort(l)) The first problem on the assignment asks you to get this code working because it doesn\u2019t quite work as written above. Not because I have intentionally introduced errors, but because English descriptions just aren\u2019t as precise as programs --- if they were we\u2019d be able to program in English instead of learning new languages! No the code above just needs to be tightened up a bit. After all this code has not been created to lead you astray, but to lead you toward a working program. The key is to test it on different kinds of lists and tackle the bugs that each reveals. I believe that I made four smallish changes to the program to get it to work on all lists. Hint: The first problem is that it does not have an end condition to stop the recursive calls. Once you see the error message think about what lists do not need sorting and add in an appropriate condition to halt the recursion. (I have left in the print statements I used during my own debugging since I found them helpful.)","title":"Quicksort"},{"location":"07.1_Sorting_2/02_Quicksort_1/#quicksort","text":"The portion of the film Sorting out Sorting provides fairly detailed instructions for Quicksort: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning forward from the front of the list look for a value larger than the pivot Scanning backwards from the end of the list look for a value smaller than the pivot if the larger value is to the left of the smaller value: Exchange the two values Continue this until the scanners cross (which means the values are separated) Move pivot into the \"middle\" Call recursively on both parts of the list This sounds precise enough to be translated into Python, so let\u2019s give it a try. Set the first element to be the pivot If we call our list lst , this is just: ``` python pivot = lst[0] ``` Scanning forward from the front of the list look for a value larger than the pivot This is a loop starting at the front of the list and moving toward the back looking for values larger than the pivot: ``` python lo = 1 while lst[lo] < pivot: lo = lo + 1 ``` Why start `lo` at 1? Because we do not want to consider the pivot element itself which is in position 0. Note that this loop will stop at values greater than or equal to the pivot (not just greater than). Is this right? Hard to tell right now, but we\u2019ll keep it in mind as a possible problem. Scanning backwards from the end of the list look for a value smaller than the pivot This is similar to above, but starting at the end of the list, and moving toward the front. ``` python hi = len(lst) - 1 while lst[hi] > pivot: hi = hi - 1 ``` if the larger value is to the left of the smaller value: If the larger value is to the left of the smaller value, it\u2019s index, lo , will be smaller than the smaller value\u2019s index, hi : ``` python if lo < hi: ``` Exchange the two values We can use the old tuple trick\u201d to swap the values, ``` python (lst[lo], lst[hi]) = (lst[hi], lst[lo]) ``` Continue this until the scanners cross (which means the values are separated) _Continue_ and _until_ indicate we need to loop. Python does not support _until_ loops so we\u2019ll have to reverse the logic to express it as a `while` loop. This means that _until_ the scanners cross\u201d becomes, _While_ the scanners _haven\u2019t_ crossed\u201d. This while statement goes at the top of the loop body: ``` python while lo < hi: ``` Let\u2019s put these pieces together and see what we have so far: pivot = lst[0] while lo < hi: lo = 1 while lst[lo] < pivot: lo = lo + 1 hi = len(lst) - 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) Obviously the initialization of lo and hi should be moved outside the loop, pivot = lst[0] lo = 1 hi = len(lst) - 1 while lo < hi: while lst[lo] < pivot: lo = lo + 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) The last bits to complete the function are to exchange the pivot into position and call the function again. Watching the film we can see that the pivot is exchanged with the element where the index hi ends up. And calling the sort on each part of the list just requires us to package our code into a function and call it on each part: # quicksort_v1.py def quicksort(lst): print('Before:', lst) pivot = lst[0] lo = 1 hi = len(lst) - 1 while lo < hi: while lst[lo] < pivot: lo = lo + 1 while lst[hi] > pivot: hi = hi - 1 if lo < hi: (lst[lo], lst[hi]) = (lst[hi], lst[lo]) if lst[0] > lst[hi]: (lst[0], lst[hi]) = (lst[hi], lst[0]) print('After:', lst) quicksort(lst[0:hi]) quicksort(lst[lo:]) l = [49, 12, 67, 87, 21, 94, 24, 73, 69, 34] print(quicksort(l)) The first problem on the assignment asks you to get this code working because it doesn\u2019t quite work as written above. Not because I have intentionally introduced errors, but because English descriptions just aren\u2019t as precise as programs --- if they were we\u2019d be able to program in English instead of learning new languages! No the code above just needs to be tightened up a bit. After all this code has not been created to lead you astray, but to lead you toward a working program. The key is to test it on different kinds of lists and tackle the bugs that each reveals. I believe that I made four smallish changes to the program to get it to work on all lists. Hint: The first problem is that it does not have an end condition to stop the recursive calls. Once you see the error message think about what lists do not need sorting and add in an appropriate condition to halt the recursion. (I have left in the print statements I used during my own debugging since I found them helpful.)","title":"Quicksort"},{"location":"07.1_Sorting_2/03_Quicksort_2/","text":"A more Pythonic Quicksort The first version of Quicksort we developed followed Sorting out Sorting\u2019s directions closely and so referred to portions of the list using index ranges (the lo and hi variables in the code). This is the approach that has to be taken in most traditional high level languages, e.g. Pascal, or C and its descendants. It works though it takes some careful testing to make sure it works on all types of lists (as you will find on Problem 1 of the assignment). The film Sorting Out Sorting presented the algorithm in terms of swapping values by index because that was how the languages of the day worked. Python on the other hand has language constructs that make creating and combining lists very easy and these can simplify the process of writing the program and of getting it working. Recall our pseudocode for the Quicksort: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning forward from the front of the list for a larger value Scanning from the back of the list for a smaller value if lo < hi: Interchange the two values Continue until lo > hi (all values are separated) Swap pivot with hi value (Move pivot into \"middle\") Call recursively on both sides of list We can restate this to be less index focussed: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning through the entire list and Placing values smaller than the pivot into a list called smaller And the values larger than the pivot into a list called larger Then call Quicksort on smaller And on Larger And finally return the concatenation of smaller, the pivot, and larger Translated into Python this gives us, # quicksort_v2.py def qsort(lst): if len(lst) <= 1: return lst pivot = lst[0] smaller = [] larger = [] for item in lst[1:]: if item <= pivot: smaller.append(item) else: larger.append(item) # print(smaller, '+', pivot, '+', larger) return qsort(smaller) + [pivot] + qsort(larger) l = [49, 12, 67, 87, 21, 94, 24, 73, 69, 34] print(qsort(l)) Notes: I have left my debugging print statement in. It is quite instructive to study the output it produces on different types of lists. Note that it is not a drop-in replacement for our earlier version because it returns a sorted version of the list rather than sorting the list in-place . To create a drop-in replacement you would need to add a wrapper function around this one to call it and assign its return value to the original list. Magic can be dangerous Given that this one is easier to get working and more readable than our first version why would we ever use the first approach? One reason is that not all languages allow the second approach. Another is that the second approach is somewhat opaque. We don\u2019t know exactly what is happening in memory when we whip the smaller and larger lists into being. Are they taking up more memory? A lot or a little? Does it take very long to create them? The only way to find out is to time the competing versions and see what the cost of easier programming is. You will be doing that as part of the assignment.","title":"A more Pythonic Quicksort"},{"location":"07.1_Sorting_2/03_Quicksort_2/#a-more-pythonic-quicksort","text":"The first version of Quicksort we developed followed Sorting out Sorting\u2019s directions closely and so referred to portions of the list using index ranges (the lo and hi variables in the code). This is the approach that has to be taken in most traditional high level languages, e.g. Pascal, or C and its descendants. It works though it takes some careful testing to make sure it works on all types of lists (as you will find on Problem 1 of the assignment). The film Sorting Out Sorting presented the algorithm in terms of swapping values by index because that was how the languages of the day worked. Python on the other hand has language constructs that make creating and combining lists very easy and these can simplify the process of writing the program and of getting it working. Recall our pseudocode for the Quicksort: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning forward from the front of the list for a larger value Scanning from the back of the list for a smaller value if lo < hi: Interchange the two values Continue until lo > hi (all values are separated) Swap pivot with hi value (Move pivot into \"middle\") Call recursively on both sides of list We can restate this to be less index focussed: Set the first element to be the pivot Separate all the smaller values from all the larger values by Scanning through the entire list and Placing values smaller than the pivot into a list called smaller And the values larger than the pivot into a list called larger Then call Quicksort on smaller And on Larger And finally return the concatenation of smaller, the pivot, and larger Translated into Python this gives us, # quicksort_v2.py def qsort(lst): if len(lst) <= 1: return lst pivot = lst[0] smaller = [] larger = [] for item in lst[1:]: if item <= pivot: smaller.append(item) else: larger.append(item) # print(smaller, '+', pivot, '+', larger) return qsort(smaller) + [pivot] + qsort(larger) l = [49, 12, 67, 87, 21, 94, 24, 73, 69, 34] print(qsort(l)) Notes: I have left my debugging print statement in. It is quite instructive to study the output it produces on different types of lists. Note that it is not a drop-in replacement for our earlier version because it returns a sorted version of the list rather than sorting the list in-place . To create a drop-in replacement you would need to add a wrapper function around this one to call it and assign its return value to the original list.","title":"A more Pythonic Quicksort"},{"location":"07.1_Sorting_2/03_Quicksort_2/#magic-can-be-dangerous","text":"Given that this one is easier to get working and more readable than our first version why would we ever use the first approach? One reason is that not all languages allow the second approach. Another is that the second approach is somewhat opaque. We don\u2019t know exactly what is happening in memory when we whip the smaller and larger lists into being. Are they taking up more memory? A lot or a little? Does it take very long to create them? The only way to find out is to time the competing versions and see what the cost of easier programming is. You will be doing that as part of the assignment.","title":"Magic can be dangerous"},{"location":"07.1_Sorting_2/04_Tree_in_a_list/","text":"Representing a tree using a list When Sorting Out Sorting got to Heapsort your first thought on seeing the tree might be What is that thing?!\u201d Computer scientists call them trees --- even though they look more like root systems than tree branches! We apologize, but it\u2019s all because we used to draw them on paper working down the page so as they grew we would add branches\u201d downward in the direction we were used to writing. There is some jargon used to describe their parts: the circles are called nodes , the lines are called branches , the node at the top is called the root , and the nodes along the bottom are called leaves . You can also see that computer scientists don\u2019t worry about mixing metaphors. the node directly above another one is its parent (like in a family tree), the nodes directly below a node are its children . (There are in fact many types of trees used in Computer Science. This is a balanced binary tree. Binary because each node has at most two children, and balanced because it\u2019s all filled in\u201d, or more formally because all paths from root to leaf have the same length.) Your second thought as you watched the tree operations in the video might be to wonder how on earth you\u2019d write code to work with it. We\u2019ve worked with lists and strings and tuples and dictionaries, but none of them look like a tree, and at first glance none of them seem to be good candidates to represent something like a tree. To see how we can do it let\u2019s look our list and tree together and see how we might map one onto the other. lst = [ 48, 32, 68, 18, 29, 71, 41 ] Working with the tree\u201d means being able to follow the branches to get from node to node. Notice that at any instant at most three movements are possible: From a node down to its left child From a node down to its right child From a node up to its parent To see how we might do that in the list let me draw arrows on the list to show how the values are linked in the tree: Since list operations work with the list indices let me replace the list values with their corresponding indices. And now let\u2019s look for patterns! How about from nodes to their left children? parent node index 0 1 2 left child index 1 3 5 Perhaps you can see the relationship here? The index of a left child is twice the index of its parent plus one. Or in Python, def left_child(node): return 2*node + 1 Now, how about from nodes to their right children? parent node index 0 1 2 right child index 2 4 6 Most students find this one less obvious, from 0 to 2 looks like we add two, from 1 to 4 looks like we multiply by four and from 2 to 6 looks like we multiply by three. No good pattern there. So look at it another way: we can see in the diagram above that the right child always comes right after the left child in the list, so its index will be exactly one greater, i.e. its index will be (2*node + 1) + 1 , which is 2*node + 1 + 1 or 2*node + 2 . Or in Python, def right_child(node): return 2*node + 2 And finally child to parent: child node index 0 1 2 3 4 5 6 parent index - 0 0 1 1 2 2 This is almost a divide by two pattern which makes sense: since we got from parents to children by multiplying by two and adding, we should be able to get back by subtracting and then dividing by two: def parent(node): return (node-1)//2 These three functions, left_child , right_child and parent will let us move through a list as though it were a heap. Most often we move forward through a list by incrementing an index by 1 and backward by decrementing it by 1. These functions calculate how far to move based on where we are to simulate the movement though a tree. Using them we will seem to bounce around the list by jumping back and forth, but the jumps aren\u2019t random they are carefully calibrated to replicate moving through a tree. So we can represent a Heap in a list just by modifying how we move through the list.","title":"Representing a tree using a list"},{"location":"07.1_Sorting_2/04_Tree_in_a_list/#representing-a-tree-using-a-list","text":"When Sorting Out Sorting got to Heapsort your first thought on seeing the tree might be What is that thing?!\u201d Computer scientists call them trees --- even though they look more like root systems than tree branches! We apologize, but it\u2019s all because we used to draw them on paper working down the page so as they grew we would add branches\u201d downward in the direction we were used to writing. There is some jargon used to describe their parts: the circles are called nodes , the lines are called branches , the node at the top is called the root , and the nodes along the bottom are called leaves . You can also see that computer scientists don\u2019t worry about mixing metaphors. the node directly above another one is its parent (like in a family tree), the nodes directly below a node are its children . (There are in fact many types of trees used in Computer Science. This is a balanced binary tree. Binary because each node has at most two children, and balanced because it\u2019s all filled in\u201d, or more formally because all paths from root to leaf have the same length.) Your second thought as you watched the tree operations in the video might be to wonder how on earth you\u2019d write code to work with it. We\u2019ve worked with lists and strings and tuples and dictionaries, but none of them look like a tree, and at first glance none of them seem to be good candidates to represent something like a tree. To see how we can do it let\u2019s look our list and tree together and see how we might map one onto the other. lst = [ 48, 32, 68, 18, 29, 71, 41 ] Working with the tree\u201d means being able to follow the branches to get from node to node. Notice that at any instant at most three movements are possible: From a node down to its left child From a node down to its right child From a node up to its parent To see how we might do that in the list let me draw arrows on the list to show how the values are linked in the tree: Since list operations work with the list indices let me replace the list values with their corresponding indices. And now let\u2019s look for patterns! How about from nodes to their left children? parent node index 0 1 2 left child index 1 3 5 Perhaps you can see the relationship here? The index of a left child is twice the index of its parent plus one. Or in Python, def left_child(node): return 2*node + 1 Now, how about from nodes to their right children? parent node index 0 1 2 right child index 2 4 6 Most students find this one less obvious, from 0 to 2 looks like we add two, from 1 to 4 looks like we multiply by four and from 2 to 6 looks like we multiply by three. No good pattern there. So look at it another way: we can see in the diagram above that the right child always comes right after the left child in the list, so its index will be exactly one greater, i.e. its index will be (2*node + 1) + 1 , which is 2*node + 1 + 1 or 2*node + 2 . Or in Python, def right_child(node): return 2*node + 2 And finally child to parent: child node index 0 1 2 3 4 5 6 parent index - 0 0 1 1 2 2 This is almost a divide by two pattern which makes sense: since we got from parents to children by multiplying by two and adding, we should be able to get back by subtracting and then dividing by two: def parent(node): return (node-1)//2 These three functions, left_child , right_child and parent will let us move through a list as though it were a heap. Most often we move forward through a list by incrementing an index by 1 and backward by decrementing it by 1. These functions calculate how far to move based on where we are to simulate the movement though a tree. Using them we will seem to bounce around the list by jumping back and forth, but the jumps aren\u2019t random they are carefully calibrated to replicate moving through a tree. So we can represent a Heap in a list just by modifying how we move through the list.","title":"Representing a tree using a list"},{"location":"07.1_Sorting_2/05_Heapsort/","text":"Heapsort Start by watching the portion of Sorting Out Sorting that covers Heapsort again. At first Heapsort may look like some manic game of musical chairs with values dancing around a tree\u201d. But if you watch carefully (or perhaps enough times!), a general pattern should become apparent: create a heap, move a value, reheap. First we convert the whole tree to a heap. Then we move the top item in the tree to the current last position in the list. Now moving that last value into the root position of the tree will usually unheapify the tree, so we reheapify it (but not including that last item). We repeat this as many times as there are items in the tree. Written out in pseudocode format instead of English we get something like this, heapify the tree As many times as there are elements in the list: swap the root element with the last element reheapify the tree (except for last item) There are some clarifications needed: The first is that last changes, it reduces by one on each iteration. It starts out as the last position in the list and then moves forward one position on each iteration (in the video this corresponds to moving across the tree from right to left and then up a level as necessary). The second is that heapify and reheapify are not identical processes. If you watch the video again you will see that the initial heapifying is bottom up. It starts with the bottommost subtrees of 3 elements and then works its way upward. Reheapifying can start at the top and then work its way down one path in the tree, because the root-last swap that was done can be fixed by rejigging just one path from the root to a leaf. Taking these changes into account produces a refined version: heapify the tree set last to len(lst) - 1 while last > 0: swap the root with last reheap the tree stopping before last So what exactly do we do when we reheap starting at a particular location? We check that value against its children and make sure it is larger than them. If it is, we are done. If it isn\u2019t we swap it with the largest of its children and then call reheap on the subtree that starts at that child (so it is a recursive procedure), e.g. if we begin with this, we heap the top subtree to get this, and then call reheap on the lower right subtree, to get this final subtree, Reheaping then works like this, compare root (of subtree) with both children if root is larger than both children stop elif the left child is largest swap root and left child call reheap on left child subtree elif the right child is largest swap root and right child call reheap on right child subtree or translated into something Pythonish after rearranging the tests so as not to bother starting with a do nothing branch, def reheap(lst, node): lc = left_child(node) rc = right_child(node) if lst[lc] > lst[node] and lst[lc] > lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc) Running this reveals that it doesn\u2019t know when to stop reheaping and falls off the bottom of the tree heading downward (because we forgot to provide a stopping condition for the recursive calls). We fix this by adding a stopping point to get, # reheap.py def left_child( node ): return 2*node + 1 def right_child( node ): return 2*node + 2 def reheap(lst, node, stop): lc = left_child(node) rc = right_child(node) if lc >= stop: return if lst[lc] > lst[node] and lst[lc] >lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc, stop) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc, stop) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) reheap(lst, 0, len(lst)-1) print('After:', lst) This works on a full tree, but it does assume that nodes always have both children which will not always be the case. With reheap in place we can further refine our earlier pseudocode, heapify the tree for last in range(len(lst)-1, -1, -1): (lst[0], lst[last]) = (lst[last], lst[0]) reheap(lst, 0, last) Which just leaves the puzzle of what heapify the tree\u201d means. In retrospect, with the experience we have gained writing reheap, it\u2019s not hard to see that heapify just consists of calling reheap on all subtrees of the list from the bottom up , # heapify.py def parent(node): return (node-1)//2 def heapify(lst): for node in range(parent(len(lst)-1), -1, -1): reheap(lst, node, len(lst)-1) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) heapify(lst) print('After:', lst) Now we just need to combine these to get a working Python heapsort: # heapsort.py def left_child( node ): return 2*node + 1 def right_child( node ): return 2*node + 2 def parent(node): return (node-1)//2 def reheap(lst, node, stop): lc = left_child(node) rc = right_child(node) if lc >= stop: return if lst[lc] > lst[node] and lst[lc] > lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc, stop) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc, stop) def heapify(lst): for node in range(parent(len(lst)-1), -1, -1): reheap(lst, node, len(lst)-1) def heapsort(lst): heapify(lst) print('Heaped:', lst) for last in range(len(lst)-1, -1, -1): (lst[0], lst[last]) = (lst[last], lst[0]) reheap(lst, 0, last-1) print(lst) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) heapsort(lst) print('After:', lst) Which works on many but not all lists. Problem 2 on the assignment is to tweak it so it works on all lists.","title":"Heapsort"},{"location":"07.1_Sorting_2/05_Heapsort/#heapsort","text":"Start by watching the portion of Sorting Out Sorting that covers Heapsort again. At first Heapsort may look like some manic game of musical chairs with values dancing around a tree\u201d. But if you watch carefully (or perhaps enough times!), a general pattern should become apparent: create a heap, move a value, reheap. First we convert the whole tree to a heap. Then we move the top item in the tree to the current last position in the list. Now moving that last value into the root position of the tree will usually unheapify the tree, so we reheapify it (but not including that last item). We repeat this as many times as there are items in the tree. Written out in pseudocode format instead of English we get something like this, heapify the tree As many times as there are elements in the list: swap the root element with the last element reheapify the tree (except for last item) There are some clarifications needed: The first is that last changes, it reduces by one on each iteration. It starts out as the last position in the list and then moves forward one position on each iteration (in the video this corresponds to moving across the tree from right to left and then up a level as necessary). The second is that heapify and reheapify are not identical processes. If you watch the video again you will see that the initial heapifying is bottom up. It starts with the bottommost subtrees of 3 elements and then works its way upward. Reheapifying can start at the top and then work its way down one path in the tree, because the root-last swap that was done can be fixed by rejigging just one path from the root to a leaf. Taking these changes into account produces a refined version: heapify the tree set last to len(lst) - 1 while last > 0: swap the root with last reheap the tree stopping before last So what exactly do we do when we reheap starting at a particular location? We check that value against its children and make sure it is larger than them. If it is, we are done. If it isn\u2019t we swap it with the largest of its children and then call reheap on the subtree that starts at that child (so it is a recursive procedure), e.g. if we begin with this, we heap the top subtree to get this, and then call reheap on the lower right subtree, to get this final subtree, Reheaping then works like this, compare root (of subtree) with both children if root is larger than both children stop elif the left child is largest swap root and left child call reheap on left child subtree elif the right child is largest swap root and right child call reheap on right child subtree or translated into something Pythonish after rearranging the tests so as not to bother starting with a do nothing branch, def reheap(lst, node): lc = left_child(node) rc = right_child(node) if lst[lc] > lst[node] and lst[lc] > lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc) Running this reveals that it doesn\u2019t know when to stop reheaping and falls off the bottom of the tree heading downward (because we forgot to provide a stopping condition for the recursive calls). We fix this by adding a stopping point to get, # reheap.py def left_child( node ): return 2*node + 1 def right_child( node ): return 2*node + 2 def reheap(lst, node, stop): lc = left_child(node) rc = right_child(node) if lc >= stop: return if lst[lc] > lst[node] and lst[lc] >lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc, stop) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc, stop) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) reheap(lst, 0, len(lst)-1) print('After:', lst) This works on a full tree, but it does assume that nodes always have both children which will not always be the case. With reheap in place we can further refine our earlier pseudocode, heapify the tree for last in range(len(lst)-1, -1, -1): (lst[0], lst[last]) = (lst[last], lst[0]) reheap(lst, 0, last) Which just leaves the puzzle of what heapify the tree\u201d means. In retrospect, with the experience we have gained writing reheap, it\u2019s not hard to see that heapify just consists of calling reheap on all subtrees of the list from the bottom up , # heapify.py def parent(node): return (node-1)//2 def heapify(lst): for node in range(parent(len(lst)-1), -1, -1): reheap(lst, node, len(lst)-1) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) heapify(lst) print('After:', lst) Now we just need to combine these to get a working Python heapsort: # heapsort.py def left_child( node ): return 2*node + 1 def right_child( node ): return 2*node + 2 def parent(node): return (node-1)//2 def reheap(lst, node, stop): lc = left_child(node) rc = right_child(node) if lc >= stop: return if lst[lc] > lst[node] and lst[lc] > lst[rc]: (lst[lc], lst[node]) = (lst[node], lst[lc]) reheap(lst, lc, stop) elif lst[rc] > lst[node]: (lst[rc], lst[node]) = (lst[node], lst[rc]) reheap(lst, rc, stop) def heapify(lst): for node in range(parent(len(lst)-1), -1, -1): reheap(lst, node, len(lst)-1) def heapsort(lst): heapify(lst) print('Heaped:', lst) for last in range(len(lst)-1, -1, -1): (lst[0], lst[last]) = (lst[last], lst[0]) reheap(lst, 0, last-1) print(lst) lst = [48, 32, 68, 18, 29, 71, 41] print('Before:', lst) heapsort(lst) print('After:', lst) Which works on many but not all lists. Problem 2 on the assignment is to tweak it so it works on all lists.","title":"Heapsort"},{"location":"07.1_Sorting_2/Heapsort_old/","text":"Heapsort First we review the heapsort algorithm by doing it by hand for a small tree. Then we work on pseudocode to express our understanding of the algorithm. Note the three tries it took on paper\u201d just to get the swapping done right. To express it in Python we will need to figure out how to store our heap (binary tree) in a list, and replace our uses of lc and rc with calculations.","title":"Heapsort"},{"location":"07.1_Sorting_2/Heapsort_old/#heapsort","text":"First we review the heapsort algorithm by doing it by hand for a small tree. Then we work on pseudocode to express our understanding of the algorithm. Note the three tries it took on paper\u201d just to get the swapping done right. To express it in Python we will need to figure out how to store our heap (binary tree) in a list, and replace our uses of lc and rc with calculations.","title":"Heapsort"},{"location":"07.2_CGoL_4_GUI/00_index/","text":"Life 4: Renovations A graphical interface to go with our graphical display Step 1: Make a plan Step 2: Review existing code Step 3: Test existing code Step 4: Make room for the menu Step 5: Refactoring interlude Step 6: Display the menu icons Step 7: Map mouse clicks to actions Step 8: Merge the UI and the simulation [11:09] life_gui_6.py: Ending point of the presentation; starting point for the assignment","title":"Contents"},{"location":"07.2_CGoL_4_GUI/00_index/#life-4-renovations","text":"A graphical interface to go with our graphical display Step 1: Make a plan Step 2: Review existing code Step 3: Test existing code Step 4: Make room for the menu Step 5: Refactoring interlude Step 6: Display the menu icons Step 7: Map mouse clicks to actions Step 8: Merge the UI and the simulation [11:09] life_gui_6.py: Ending point of the presentation; starting point for the assignment","title":"Life 4: Renovations"},{"location":"07.2_CGoL_4_GUI/01_The_goal/","text":"The Goal Our game of life program has a graphical display now that looks more polished than the terminal output we began with, but graphical output deserves a graphical interface. Something like this, The interface isn\u2019t huge, but you will notice a small row of icons in the upper left corner that can be used to control the execution of the game. Allows one to load a saved configuration of the universe. Save the current universe to a file. Pause the simulation. Advance one generation. Simulate continuously. Edit the universe, i.e. clicking the mouse will toggle the state of the cell beneath the cursor. Clear the universe.","title":"The Goal"},{"location":"07.2_CGoL_4_GUI/01_The_goal/#the-goal","text":"Our game of life program has a graphical display now that looks more polished than the terminal output we began with, but graphical output deserves a graphical interface. Something like this, The interface isn\u2019t huge, but you will notice a small row of icons in the upper left corner that can be used to control the execution of the game. Allows one to load a saved configuration of the universe. Save the current universe to a file. Pause the simulation. Advance one generation. Simulate continuously. Edit the universe, i.e. clicking the mouse will toggle the state of the cell beneath the cursor. Clear the universe.","title":"The Goal"},{"location":"07.2_CGoL_4_GUI/02_Step_1_Make_a_plan/","text":"Step 1: Make a plan In a previous module we made a beautiful graphic to display Conway's Game of Life (like the one shown below). A good graphic deserves a good graphical user interface. The new version will have icons at the top that let us perform different actions in our game. Here are the steps we will need to take to make the changes: Review code. Make room to display the menu of icons (without breaking our display). Display icons. React to mouse clicks on icons: Detect the mouse click. Get mouse location. Map from coordinates to icon. Take matching action (invoke function). We are going to work through this list to make our fanciest Game of Life yet!","title":"Step 1: Make a plan"},{"location":"07.2_CGoL_4_GUI/02_Step_1_Make_a_plan/#step-1-make-a-plan","text":"In a previous module we made a beautiful graphic to display Conway's Game of Life (like the one shown below). A good graphic deserves a good graphical user interface. The new version will have icons at the top that let us perform different actions in our game. Here are the steps we will need to take to make the changes: Review code. Make room to display the menu of icons (without breaking our display). Display icons. React to mouse clicks on icons: Detect the mouse click. Get mouse location. Map from coordinates to icon. Take matching action (invoke function). We are going to work through this list to make our fanciest Game of Life yet!","title":"Step 1: Make a plan"},{"location":"07.2_CGoL_4_GUI/03_Step_2_Review_existing_code/","text":"Step 2: Review existing code Let's look at the graphical code for making the Game of Life. This code draws the universe and populates some random cells for the initial generation of our universe. # life_gui_0.py # # Graphical user interface for Conway's Game of Life. import pygame import time import random # Colour definitions. BLACK = (0, 0, 0) WHITE = (255, 255, 255) RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) TEAL = (0, 128, 128) YELLOW = (255, 255, 0) GREY = (128,128,128) SILVER = (192, 192, 192) pygame.init() U_ROWS = 25 # rows in the Life universe. U_COLS = 40 # cols in the Life universe. live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") cell_size = 16 # matches the size of the Aqua-Ball-icon grid_size = cell_size + 1 # + 1 allows for 1 pixel border on LHS of cell. SCREEN_HEIGHT = U_ROWS*grid_size + 1 # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*grid_size + 1 screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (0, y*grid_size), (SCREEN_WIDTH, y*grid_size)) # 0 SCREEN_WIDTH # # 0*grid_size ---------------------------------- # # 1*grid_size ---------------------------------- # # 2*grid_size ---------------------------------- # # ... # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size, 0), (x*grid_size, SCREEN_WIDTH)) pygame.display.flip() for i in range(1,100): # + 1s offset below move past LH borderline, below upper borderline. screen.blit(live_cell, (random.randint(0, U_COLS)*grid_size+1, random.randint(0, U_ROWS)*grid_size+1)) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False pygame.quit()","title":"Step 2: Review existing code"},{"location":"07.2_CGoL_4_GUI/03_Step_2_Review_existing_code/#step-2-review-existing-code","text":"Let's look at the graphical code for making the Game of Life. This code draws the universe and populates some random cells for the initial generation of our universe. # life_gui_0.py # # Graphical user interface for Conway's Game of Life. import pygame import time import random # Colour definitions. BLACK = (0, 0, 0) WHITE = (255, 255, 255) RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) TEAL = (0, 128, 128) YELLOW = (255, 255, 0) GREY = (128,128,128) SILVER = (192, 192, 192) pygame.init() U_ROWS = 25 # rows in the Life universe. U_COLS = 40 # cols in the Life universe. live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") cell_size = 16 # matches the size of the Aqua-Ball-icon grid_size = cell_size + 1 # + 1 allows for 1 pixel border on LHS of cell. SCREEN_HEIGHT = U_ROWS*grid_size + 1 # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*grid_size + 1 screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (0, y*grid_size), (SCREEN_WIDTH, y*grid_size)) # 0 SCREEN_WIDTH # # 0*grid_size ---------------------------------- # # 1*grid_size ---------------------------------- # # 2*grid_size ---------------------------------- # # ... # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size, 0), (x*grid_size, SCREEN_WIDTH)) pygame.display.flip() for i in range(1,100): # + 1s offset below move past LH borderline, below upper borderline. screen.blit(live_cell, (random.randint(0, U_COLS)*grid_size+1, random.randint(0, U_ROWS)*grid_size+1)) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False pygame.quit()","title":"Step 2: Review existing code"},{"location":"07.2_CGoL_4_GUI/04_Step_3_Test_existing_code/","text":"Step 3: Test existing code The first thing we're going to do it add an outside border to our universe. This will be a good intermediate step make sure we are getting all of the boundaries in the right place. The addition of a border is going to change all of our coordinates, if the border was 10 pixels we would want to start drawing at (10,10) instead of (0,0). Instead of hardcoding the value 10, we will create a new constant BORDER_WIDTH . This will have a number of effects, starting with some changes to our screen size. BORDER_WIDTH = 10 # we have to add 2x the border to the height account for the top and bottom borders SCREEN_HEIGHT = CELL_ROWS*grid_size + 1 + 2*BORDER_WIDTH # we have to add 2x the border to the width account for the left and right borders SCREEN_WIDTH = CELL_COLS*grid_size + 1 + 2*BORDER_WIDTH screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) This will also affect the position of our lines. We are going to have to start the horizontal lines at BORDER_WIDTH instead of 0 and end them at SCREEN_WIDTH-BORDER_WIDTH instead of SCREEN_WIDTH . We also need to shift all our horizontal lines downward from y*grid_size to y*grid_size+BORDER_WIDTH . Similar adjustments will need to be made for the vertical lines. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size+BORDER_WIDTH), (SCREEN_WIDTH-BORDER_WIDTH, y*grid_size+BORDER_WIDTH)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT-BORDER_WIDTH)) pygame.display.flip() This will also offset the position of all the cells. Let's add some code to add the width of the border to the position of the cell to account for the border at the top and left of the screen. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS)*grid_size+1+BORDER_WIDTH, random.randint(0, CELL_ROWS)*grid_size+1+BORDER_WIDTH)) # time.sleep(0.2) pygame.display.flip() When we run this updated version of the code we get the following output. You can see that some of our Aqua-Balls are falling outside our grid. More subtly the bottom side of the vertical line and the right side of the horizontal lines are extending past the outer border. Let's start by addressing the issue with cells appearing outside of our border. This looks like an issue with the range we can select cells in. The issue is that random.randint is inclusive of the top of the range, unlike range and random.randrange . We can fix this by including a -1. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS-1)*grid_size+1+BORDER_WIDTH, random.randint(0, CELL_ROWS-1)*grid_size+1+BORDER_WIDTH)) # time.sleep(0.2) pygame.display.flip() This cleans up the first problem. Now let's tackle the lines that are slightly too long. It is in the second coordinate only of both our horizontal and vertical lines, and we will guess that it is likely an off by 1 error. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size+BORDER_WIDTH), (SCREEN_WIDTH-BORDER_WIDTH-1, y*grid_size+BORDER_WIDTH)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT-BORDER_WIDTH-1)) pygame.display.flip() This fixes the problem, but let's think about why with some actual numbers. If we had a 1x1 universe, the cell would be 17 pixels across, plus 1 pixel for the right hand grid line, plus 20 for the two borders. `17+1+10+10=38 pixels` If we subtract 10 pixels to remove the border on the second coordinate of our line we get 28, but because we start from 0 we need to subtract -1 (just like the last item in a list is at index len(lst)-1 . Now our display should look like this:","title":"Step 3: Test existing code"},{"location":"07.2_CGoL_4_GUI/04_Step_3_Test_existing_code/#step-3-test-existing-code","text":"The first thing we're going to do it add an outside border to our universe. This will be a good intermediate step make sure we are getting all of the boundaries in the right place. The addition of a border is going to change all of our coordinates, if the border was 10 pixels we would want to start drawing at (10,10) instead of (0,0). Instead of hardcoding the value 10, we will create a new constant BORDER_WIDTH . This will have a number of effects, starting with some changes to our screen size. BORDER_WIDTH = 10 # we have to add 2x the border to the height account for the top and bottom borders SCREEN_HEIGHT = CELL_ROWS*grid_size + 1 + 2*BORDER_WIDTH # we have to add 2x the border to the width account for the left and right borders SCREEN_WIDTH = CELL_COLS*grid_size + 1 + 2*BORDER_WIDTH screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) This will also affect the position of our lines. We are going to have to start the horizontal lines at BORDER_WIDTH instead of 0 and end them at SCREEN_WIDTH-BORDER_WIDTH instead of SCREEN_WIDTH . We also need to shift all our horizontal lines downward from y*grid_size to y*grid_size+BORDER_WIDTH . Similar adjustments will need to be made for the vertical lines. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size+BORDER_WIDTH), (SCREEN_WIDTH-BORDER_WIDTH, y*grid_size+BORDER_WIDTH)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT-BORDER_WIDTH)) pygame.display.flip() This will also offset the position of all the cells. Let's add some code to add the width of the border to the position of the cell to account for the border at the top and left of the screen. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS)*grid_size+1+BORDER_WIDTH, random.randint(0, CELL_ROWS)*grid_size+1+BORDER_WIDTH)) # time.sleep(0.2) pygame.display.flip() When we run this updated version of the code we get the following output. You can see that some of our Aqua-Balls are falling outside our grid. More subtly the bottom side of the vertical line and the right side of the horizontal lines are extending past the outer border. Let's start by addressing the issue with cells appearing outside of our border. This looks like an issue with the range we can select cells in. The issue is that random.randint is inclusive of the top of the range, unlike range and random.randrange . We can fix this by including a -1. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS-1)*grid_size+1+BORDER_WIDTH, random.randint(0, CELL_ROWS-1)*grid_size+1+BORDER_WIDTH)) # time.sleep(0.2) pygame.display.flip() This cleans up the first problem. Now let's tackle the lines that are slightly too long. It is in the second coordinate only of both our horizontal and vertical lines, and we will guess that it is likely an off by 1 error. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size+BORDER_WIDTH), (SCREEN_WIDTH-BORDER_WIDTH-1, y*grid_size+BORDER_WIDTH)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT-BORDER_WIDTH-1)) pygame.display.flip() This fixes the problem, but let's think about why with some actual numbers. If we had a 1x1 universe, the cell would be 17 pixels across, plus 1 pixel for the right hand grid line, plus 20 for the two borders. `17+1+10+10=38 pixels` If we subtract 10 pixels to remove the border on the second coordinate of our line we get 28, but because we start from 0 we need to subtract -1 (just like the last item in a list is at index len(lst)-1 . Now our display should look like this:","title":"Step 3: Test existing code"},{"location":"07.2_CGoL_4_GUI/05_Step_4_Make_room_for_the_menu/","text":"Step 4: Make room for the menu Next we will make some more room above the top border to add a menu. The menu icons are 16x16 pixels, so we need to add 16 pixels at the top of our window. We will introduce a new constant called MENU_HEIGHT , just in case we want to use different sized icons in the future. Let's start by changing the screen size so that we have room for the changes. MENU_HEIGHT = 16 BORDER_WIDTH = 10 SCREEN_HEIGHT = CELL_ROWS*grid_size + 1 + 2*BORDER_WIDTH + MENU_HEIGHT SCREEN_WIDTH = CELL_COLS*grid_size + 1 + 2*BORDER_WIDTH screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) Now we need to adjust the position of the grid by adding the MENU_HEIGHT to all the y coordinates. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size + BORDER_WIDTH + MENU_HEIGHT), (SCREEN_WIDTH-BORDER_WIDTH, y*grid_size + BORDER_WIDTH + MENU_HEIGHT)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH)) pygame.display.flip() Notice that we don't adjust the y position at the bottom of our vertical lines, that is because that change is built in to the change in the SCREEN_HEIGHT . Finally we need to adjust the position of our cells on the y axis. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS-1)*grid_size + 1 + BORDER_WIDTH, random.randint(0, CELL_ROWS-1)*grid_size + 1 + BORDER_WIDTH + MENU_HEIGHT)) # time.sleep(0.2) pygame.display.flip() Now we have space to add our menu!","title":"Step 4: Make room for the menu"},{"location":"07.2_CGoL_4_GUI/05_Step_4_Make_room_for_the_menu/#step-4-make-room-for-the-menu","text":"Next we will make some more room above the top border to add a menu. The menu icons are 16x16 pixels, so we need to add 16 pixels at the top of our window. We will introduce a new constant called MENU_HEIGHT , just in case we want to use different sized icons in the future. Let's start by changing the screen size so that we have room for the changes. MENU_HEIGHT = 16 BORDER_WIDTH = 10 SCREEN_HEIGHT = CELL_ROWS*grid_size + 1 + 2*BORDER_WIDTH + MENU_HEIGHT SCREEN_WIDTH = CELL_COLS*grid_size + 1 + 2*BORDER_WIDTH screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) Now we need to adjust the position of the grid by adding the MENU_HEIGHT to all the y coordinates. # Draw horizontal lines. for y in range(0, CELL_ROWS+1): pygame.draw.line(screen, GREY, (BORDER_WIDTH, y*grid_size + BORDER_WIDTH + MENU_HEIGHT), (SCREEN_WIDTH-BORDER_WIDTH, y*grid_size + BORDER_WIDTH + MENU_HEIGHT)) # Draw vertical lines. for x in range(0, CELL_COLS+1): pygame.draw.line(screen, GREY, (x*grid_size+BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT), (x*grid_size+BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH)) pygame.display.flip() Notice that we don't adjust the y position at the bottom of our vertical lines, that is because that change is built in to the change in the SCREEN_HEIGHT . Finally we need to adjust the position of our cells on the y axis. for i in range(1,CELL_ROWS*CELL_COLS//10): screen.blit(live_cell, (random.randint(0, CELL_COLS-1)*grid_size + 1 + BORDER_WIDTH, random.randint(0, CELL_ROWS-1)*grid_size + 1 + BORDER_WIDTH + MENU_HEIGHT)) # time.sleep(0.2) pygame.display.flip() Now we have space to add our menu!","title":"Step 4: Make room for the menu"},{"location":"07.2_CGoL_4_GUI/06_Step_5_Refactoring_interlude/","text":"Step 5: Refactoring interlude The calculations for the positions of the grid and the cells are starting to get a bit long and complicated. Before we move forward it would be nice to clean up the code a little by replacing some of those calculations with variables. We will want variable names for the grid, and probably the menu area when we start working with that. Both the grid and the menu area are rectangular regions on the screen. We will encapsulate with a class that can handle rectangluar regions in our screen. We are going to define our rectangular region with a pair of coordinates, one pair at the top left and one pair at the bottom right. class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right The first rectangle we are going to define is a game area. game_area = Rectangle(BORDER_WIDTH + MENU_HEIGHT, BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH - 1, SCREEN_WIDTH - BORDER_WIDTH - 1) # We can now use the rectangle object to easily find the placement of the grid # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (game_area.left, game_area.top + y*grid_size), (game_area.right, game_area.top + y*grid_size)) # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (game_area.left + x*grid_size, game_area.top ), (game_area.left + x*grid_size, game_area.bottom)) pygame.display.flip() # We can also use the Rectangle to place the cells for i in range(1,100): # + 1s below move past LH borderline, below upper borderline. screen.blit(live_cell, (game_area.left + random.randint(0, U_COLS-1)*grid_size+1, game_area.top + random.randint(0, U_ROWS-1)*grid_size+1)) pygame.display.flip() This makes our code easier to read because we can see that we are working from very clear reference points in our game area. Now we are ready to start working on the menu.","title":"Step 5: Refactoring interlude"},{"location":"07.2_CGoL_4_GUI/06_Step_5_Refactoring_interlude/#step-5-refactoring-interlude","text":"The calculations for the positions of the grid and the cells are starting to get a bit long and complicated. Before we move forward it would be nice to clean up the code a little by replacing some of those calculations with variables. We will want variable names for the grid, and probably the menu area when we start working with that. Both the grid and the menu area are rectangular regions on the screen. We will encapsulate with a class that can handle rectangluar regions in our screen. We are going to define our rectangular region with a pair of coordinates, one pair at the top left and one pair at the bottom right. class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right The first rectangle we are going to define is a game area. game_area = Rectangle(BORDER_WIDTH + MENU_HEIGHT, BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH - 1, SCREEN_WIDTH - BORDER_WIDTH - 1) # We can now use the rectangle object to easily find the placement of the grid # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (game_area.left, game_area.top + y*grid_size), (game_area.right, game_area.top + y*grid_size)) # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (game_area.left + x*grid_size, game_area.top ), (game_area.left + x*grid_size, game_area.bottom)) pygame.display.flip() # We can also use the Rectangle to place the cells for i in range(1,100): # + 1s below move past LH borderline, below upper borderline. screen.blit(live_cell, (game_area.left + random.randint(0, U_COLS-1)*grid_size+1, game_area.top + random.randint(0, U_ROWS-1)*grid_size+1)) pygame.display.flip() This makes our code easier to read because we can see that we are working from very clear reference points in our game area. Now we are ready to start working on the menu.","title":"Step 5: Refactoring interlude"},{"location":"07.2_CGoL_4_GUI/07_Step_6_Display_menu_icons/","text":"Step 6: Display the menu icons The next job is to display the menu icons. We are going to need to get the icons, load them, and blip them to our screen in the right location. The locations will all be in our menu area. Let's start by defining a Rectangle for our menu area. MENU_HEIGHT = 16 SCREEN_BORDER = 10 SCREEN_HEIGHT = U_ROWS*GRID_SIZE + 1 + 2*SCREEN_BORDER + MENU_HEIGHT # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*GRID_SIZE + 1 + 2*SCREEN_BORDER menu_area = Rectangle(BORDER_WIDTH, BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT, SCREEN_WIDTH - BORDER_WIDTH) The next thing we need to do is load our graphics. We've done that once before when we loaded our Aqua-Ball. Let's look at that code. live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") We need to do that same thing for all of our menu icons (load, save, pause, step, play, edit, clear). You can download all of the appropriate images here . Loading the images will look like this: load_icon = pygame.image.load(\"folder.png\") save_icon = pygame.image.load(\"folder_add.png\") pause_icon = pygame.image.load(\"control_pause_blue.png\") step_icon = pygame.image.load(\"control_play_blue.png\") play_icon = pygame.image.load(\"control_fastforward_blue.png\") edit_icon = pygame.image.load(\"pencil.png\") clear_icon = pygame.image.load(\"picture_empty.png\") I used _icon as part of the names, because the variable names also sound like they would make good function names. The next step is to display all the images on the screen, but it really feels we should be able to simplify that process. We don't want to call blit 7 times, we would rather use a list to simplify the process. Rather than refactoring later, let's do some planning now. We will create a menu, which will be a list. Inside the list will be sublists that contain matching function names and file names. We will also include some blank separators between the different sections of our menu. To get the code working we will include some functions to go with each action. We aren't going to fill them in in. def load(): print('Running load') def save(): print('Running save') def pause(): print('Running pause') def step(): print('Running step') def play(): print('Running play') def edit(): print('Running edit') def clear(): print('Running clear') def null(): print('Doing nothing') menu = [ [load, \"folder.png\"], [save, \"folder_add.png\"], [null, \"black_separator.png\"], [pause, \"control_pause_blue.png\"], [step, \"control_play_blue.png\"], [play, \"control_fastforward_blue.png\"], [null, \"black_separator.png\"], [edit, \"pencil.png\"], [clear, \"picture_empty.png\"] ] The next step is to draw the menu. Now that all of our menu information is in a list, it should be relatively easy to draw it with a for loop. The loop will have to calculate where to put each item and were going to do that by multiplying the index by the grid_size , which means we're going to need to use range . As we load each image we will append it to the end of the corresponding menu items list. for i in range(len(menu)): # load and save the image in pygame menu[i].append(pygame.image.load(menu[i][1])) # display icon at position defined by the menu_area screen.blit(menu[i][2], (menu_area.left + i*grid_size + 1, menu_area.top)) # + 1 for border This draws some beautiful icons.","title":"Step 6: Display the menu icons"},{"location":"07.2_CGoL_4_GUI/07_Step_6_Display_menu_icons/#step-6-display-the-menu-icons","text":"The next job is to display the menu icons. We are going to need to get the icons, load them, and blip them to our screen in the right location. The locations will all be in our menu area. Let's start by defining a Rectangle for our menu area. MENU_HEIGHT = 16 SCREEN_BORDER = 10 SCREEN_HEIGHT = U_ROWS*GRID_SIZE + 1 + 2*SCREEN_BORDER + MENU_HEIGHT # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*GRID_SIZE + 1 + 2*SCREEN_BORDER menu_area = Rectangle(BORDER_WIDTH, BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT, SCREEN_WIDTH - BORDER_WIDTH) The next thing we need to do is load our graphics. We've done that once before when we loaded our Aqua-Ball. Let's look at that code. live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") We need to do that same thing for all of our menu icons (load, save, pause, step, play, edit, clear). You can download all of the appropriate images here . Loading the images will look like this: load_icon = pygame.image.load(\"folder.png\") save_icon = pygame.image.load(\"folder_add.png\") pause_icon = pygame.image.load(\"control_pause_blue.png\") step_icon = pygame.image.load(\"control_play_blue.png\") play_icon = pygame.image.load(\"control_fastforward_blue.png\") edit_icon = pygame.image.load(\"pencil.png\") clear_icon = pygame.image.load(\"picture_empty.png\") I used _icon as part of the names, because the variable names also sound like they would make good function names. The next step is to display all the images on the screen, but it really feels we should be able to simplify that process. We don't want to call blit 7 times, we would rather use a list to simplify the process. Rather than refactoring later, let's do some planning now. We will create a menu, which will be a list. Inside the list will be sublists that contain matching function names and file names. We will also include some blank separators between the different sections of our menu. To get the code working we will include some functions to go with each action. We aren't going to fill them in in. def load(): print('Running load') def save(): print('Running save') def pause(): print('Running pause') def step(): print('Running step') def play(): print('Running play') def edit(): print('Running edit') def clear(): print('Running clear') def null(): print('Doing nothing') menu = [ [load, \"folder.png\"], [save, \"folder_add.png\"], [null, \"black_separator.png\"], [pause, \"control_pause_blue.png\"], [step, \"control_play_blue.png\"], [play, \"control_fastforward_blue.png\"], [null, \"black_separator.png\"], [edit, \"pencil.png\"], [clear, \"picture_empty.png\"] ] The next step is to draw the menu. Now that all of our menu information is in a list, it should be relatively easy to draw it with a for loop. The loop will have to calculate where to put each item and were going to do that by multiplying the index by the grid_size , which means we're going to need to use range . As we load each image we will append it to the end of the corresponding menu items list. for i in range(len(menu)): # load and save the image in pygame menu[i].append(pygame.image.load(menu[i][1])) # display icon at position defined by the menu_area screen.blit(menu[i][2], (menu_area.left + i*grid_size + 1, menu_area.top)) # + 1 for border This draws some beautiful icons.","title":"Step 6: Display the menu icons"},{"location":"07.2_CGoL_4_GUI/08_Step_7_Map_clicks_to_actions/","text":"Step 7: Map mouse clicks to actions We have icons, but they don't react to mouse clicks. The first step is to figure out how to detect a mouse click, and then once we do that to figure out the mouse location. Let's start a new program just to deal with this new idea. import pygame import sys BLACK = (0, 0, 0) SCREEN_HEIGHT = 480 SCREEN_WIDTH = 640 pygame.init() screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # checks for a MOUSEBUTTON event elif event.type == pygame.MOUSEBUTTONUP: # print the position of the mouse as a tuple (x,y) print(\"mouse at \", event.pos) pygame.quit() There are lots of pygame events, you can see all these events with dir(pygame) . We are recording the position when the mouse button comes back up after a click. Usually programs look for a click where the mouse has come up and down in the same location, but we aren't going to worry about that for now. The print statement is printing the position in our terminal window. Now let's add this to our current Game of Life gui. The next step is to map that click to the location of our menu icons. Before we figure out if the click maps to a specific icon we are going to check that the click occured in our menu area. Later when we edit the universe we will also want to detect clicks in our game area. # life_gui_3.py # # Graphical user interface for Conway's Game of Life. import pygame import time import random # Colour definitions. BLACK = (0, 0, 0) WHITE = (255, 255, 255) RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) TEAL = (0, 128, 128) YELLOW = (255, 255, 0) GREY = (128,128,128) SILVER = (192, 192, 192) class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right U_ROWS = 25 # rows in the Life universe. U_COLS = 40 # cols in the Life universe. CELL_SIZE = 16 GRID_SIZE = CELL_SIZE + 1 # + 1 allows for 1 pixel border on LHS of cell. MENU_HEIGHT = 16 BORDER_WIDTH = 10 SCREEN_HEIGHT = U_ROWS*GRID_SIZE + 1 + 2*BORDER_WIDTH + MENU_HEIGHT # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*GRID_SIZE + 1 + 2*BORDER_WIDTH def load(): print('Running load') def save(): print('Running save') def pause(): print('Running pause') def step(): print('Running step') def play(): print('Running play') def edit(): print('Running edit') def clear(): print('Running clear') def null(): print('Doing nothing') pygame.init() screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") # Define menu menu = [ [load, \"folder.png\"], [save, \"folder_add.png\"], [null, \"black_separator.png\"], [pause, \"control_pause_blue.png\"], [step, \"control_play_blue.png\"], [play, \"control_fastforward_blue.png\"], [null, \"black_separator.png\"], [edit, \"pencil.png\"], [clear, \"picture_empty.png\"] ] menu_area = Rectangle(BORDER_WIDTH, BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT, SCREEN_WIDTH - BORDER_WIDTH) for i in range(len(menu)): menu[i].append(pygame.image.load(menu[i][1])) screen.blit(menu[i][2], (menu_area.left + i*GRID_SIZE + 1, menu_area.top)) game_area = Rectangle(BORDER_WIDTH + MENU_HEIGHT, BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH - 1, SCREEN_WIDTH - BORDER_WIDTH - 1) # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (game_area.left, game_area.top + y*GRID_SIZE), (game_area.right, game_area.top + y*GRID_SIZE)) # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (game_area.left + x*GRID_SIZE, game_area.top ), (game_area.left + x*GRID_SIZE, game_area.bottom)) pygame.display.flip() for i in range(1,100): # + 1s below move past LH borderline, below upper borderline. screen.blit(live_cell, (game_area.left + random.randint(0, U_COLS-1)*GRID_SIZE+1, game_area.top + random.randint(0, U_ROWS-1)*GRID_SIZE+1)) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # checks for a MOUSEBUTTON event elif event.type == pygame.MOUSEBUTTONUP: # save the x and y position of the mouse click x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) pygame.quit() We've changed the code slightly so that we have defined x and y coordinate. Let's add an if-elif to detect clicks either in the menu or game area. We will do that by adding it as a method to our rectangle class. class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right def inside(self, x, y): ''' Returns True is the x value is between the left and right value and the y value is between the top and bottom.''' return x >= self.left and x <= self.right and y >= self.top and y <= self.bottom Let's use this new method to find our menu icons. We only care about the x position if we are in the menu area, and we should be able to map each icon to its postion based on its index in the menu list. running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: # save the x and y position of the mouse click x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) # print Boolean if menu_area.inside(x,y): # make sure its in the menu are menu_position = (x - menu_area.left)//GRID_SIZE # map x coordinate to menu position print('Menu item: ', menu_position) # print menu item 1-9 menu[menu_position][0]() # run the function associated with the menu item pygame.quit() We can run the functions with menu[menu_position][0]() because we have the function object for each icon as the first index of each list. We tell python to run the function with the round parentheses. This works well to detect clicks on the icons, but it doesn't cope well when you click inside the menu to the right of the rightmost icon. We can solve this with another if statement. running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) if menu_area.inside(x,y): menu_position = (x - menu_area.left)//GRID_SIZE print('Menu item: ', menu_position) if menu_position < len(menu): menu[menu_position][0]() pygame.quit() Now it handles only calls the functions if their is a corresponding menu item.","title":"Step 7: Map mouse clicks to actions"},{"location":"07.2_CGoL_4_GUI/08_Step_7_Map_clicks_to_actions/#step-7-map-mouse-clicks-to-actions","text":"We have icons, but they don't react to mouse clicks. The first step is to figure out how to detect a mouse click, and then once we do that to figure out the mouse location. Let's start a new program just to deal with this new idea. import pygame import sys BLACK = (0, 0, 0) SCREEN_HEIGHT = 480 SCREEN_WIDTH = 640 pygame.init() screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # checks for a MOUSEBUTTON event elif event.type == pygame.MOUSEBUTTONUP: # print the position of the mouse as a tuple (x,y) print(\"mouse at \", event.pos) pygame.quit() There are lots of pygame events, you can see all these events with dir(pygame) . We are recording the position when the mouse button comes back up after a click. Usually programs look for a click where the mouse has come up and down in the same location, but we aren't going to worry about that for now. The print statement is printing the position in our terminal window. Now let's add this to our current Game of Life gui. The next step is to map that click to the location of our menu icons. Before we figure out if the click maps to a specific icon we are going to check that the click occured in our menu area. Later when we edit the universe we will also want to detect clicks in our game area. # life_gui_3.py # # Graphical user interface for Conway's Game of Life. import pygame import time import random # Colour definitions. BLACK = (0, 0, 0) WHITE = (255, 255, 255) RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) TEAL = (0, 128, 128) YELLOW = (255, 255, 0) GREY = (128,128,128) SILVER = (192, 192, 192) class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right U_ROWS = 25 # rows in the Life universe. U_COLS = 40 # cols in the Life universe. CELL_SIZE = 16 GRID_SIZE = CELL_SIZE + 1 # + 1 allows for 1 pixel border on LHS of cell. MENU_HEIGHT = 16 BORDER_WIDTH = 10 SCREEN_HEIGHT = U_ROWS*GRID_SIZE + 1 + 2*BORDER_WIDTH + MENU_HEIGHT # + 1 allows for 1 pixel border on RHS of screen. SCREEN_WIDTH = U_COLS*GRID_SIZE + 1 + 2*BORDER_WIDTH def load(): print('Running load') def save(): print('Running save') def pause(): print('Running pause') def step(): print('Running step') def play(): print('Running play') def edit(): print('Running edit') def clear(): print('Running clear') def null(): print('Doing nothing') pygame.init() screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT)) screen.fill(BLACK) pygame.display.flip() live_cell = pygame.image.load(\"Aqua-Ball-icon.png\") # Define menu menu = [ [load, \"folder.png\"], [save, \"folder_add.png\"], [null, \"black_separator.png\"], [pause, \"control_pause_blue.png\"], [step, \"control_play_blue.png\"], [play, \"control_fastforward_blue.png\"], [null, \"black_separator.png\"], [edit, \"pencil.png\"], [clear, \"picture_empty.png\"] ] menu_area = Rectangle(BORDER_WIDTH, BORDER_WIDTH, BORDER_WIDTH + MENU_HEIGHT, SCREEN_WIDTH - BORDER_WIDTH) for i in range(len(menu)): menu[i].append(pygame.image.load(menu[i][1])) screen.blit(menu[i][2], (menu_area.left + i*GRID_SIZE + 1, menu_area.top)) game_area = Rectangle(BORDER_WIDTH + MENU_HEIGHT, BORDER_WIDTH, SCREEN_HEIGHT - BORDER_WIDTH - 1, SCREEN_WIDTH - BORDER_WIDTH - 1) # Draw horizontal lines. for y in range(0, U_ROWS+1): pygame.draw.line(screen, GREY, (game_area.left, game_area.top + y*GRID_SIZE), (game_area.right, game_area.top + y*GRID_SIZE)) # Draw vertical lines. for x in range(0, U_COLS+1): pygame.draw.line(screen, GREY, (game_area.left + x*GRID_SIZE, game_area.top ), (game_area.left + x*GRID_SIZE, game_area.bottom)) pygame.display.flip() for i in range(1,100): # + 1s below move past LH borderline, below upper borderline. screen.blit(live_cell, (game_area.left + random.randint(0, U_COLS-1)*GRID_SIZE+1, game_area.top + random.randint(0, U_ROWS-1)*GRID_SIZE+1)) pygame.display.flip() running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # checks for a MOUSEBUTTON event elif event.type == pygame.MOUSEBUTTONUP: # save the x and y position of the mouse click x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) pygame.quit() We've changed the code slightly so that we have defined x and y coordinate. Let's add an if-elif to detect clicks either in the menu or game area. We will do that by adding it as a method to our rectangle class. class Rectangle: ''' | | | top | | | bottom +--------+ - | | | | +--------+ - --------| left -----------------| right ''' def __init__(self, top, left, bottom, right): self.top = top self.left = left self.bottom = bottom self.right = right def inside(self, x, y): ''' Returns True is the x value is between the left and right value and the y value is between the top and bottom.''' return x >= self.left and x <= self.right and y >= self.top and y <= self.bottom Let's use this new method to find our menu icons. We only care about the x position if we are in the menu area, and we should be able to map each icon to its postion based on its index in the menu list. running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: # save the x and y position of the mouse click x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) # print Boolean if menu_area.inside(x,y): # make sure its in the menu are menu_position = (x - menu_area.left)//GRID_SIZE # map x coordinate to menu position print('Menu item: ', menu_position) # print menu item 1-9 menu[menu_position][0]() # run the function associated with the menu item pygame.quit() We can run the functions with menu[menu_position][0]() because we have the function object for each icon as the first index of each list. We tell python to run the function with the round parentheses. This works well to detect clicks on the icons, but it doesn't cope well when you click inside the menu to the right of the rightmost icon. We can solve this with another if statement. running = True while running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) if menu_area.inside(x,y): menu_position = (x - menu_area.left)//GRID_SIZE print('Menu item: ', menu_position) if menu_position < len(menu): menu[menu_position][0]() pygame.quit() Now it handles only calls the functions if their is a corresponding menu item.","title":"Step 7: Map mouse clicks to actions"},{"location":"07.2_CGoL_4_GUI/09_Step_8_Merge_ui_and_simulation/","text":"Step 8: Merge the UI and the simulation code The last step is to connect the menu to the actions. That is a job for the assignment, but we will do a little bit of planning to get you started. One important decision we need to figure out where to age the universe. The ageing happens inside the main event loop. The event loop will be divided into two parts one to handle events and the other to play the game of life. The ageing of the universe will have to respond to the game state which can be PAUSE , STEP , or PLAY . (PAUSE, STEP, PLAY) = list(range(3)) running = True while running: # Handles events (if any): for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) if menu_area.inside(x,y): menu_position = (x - menu_area.left)//GRID_SIZE print('Menu item: ', menu_position) if menu_position < len(menu): menu[menu_position][0]() # Simulates the Game of Life: if game_state != PAUSE: # Create the next universe: # Age the universe: # Replace the universe with next universe # Display the universe # if the game state is STEP it will age once and then switch state back to PAUSE # otherwise if the game state is PLAY it will stay PLAY and keep ageing the universe if game_state == STEP: game_state = PAUSE pygame.quit() Now let's think about what each of our functions has to do. #............................................................................... # XXX Game Functions # def load(): # Set state to PAUSE, # conduct a dialogue about what file to load, # and load it. # # What to do if the size of the universe in the file is not the same # as ours? If it is smaller? If it is larger? print('Running load') # For debugging. def save(): # Set state to PAUSE, # conduct a dialogue about what file to save to, # and save it. print('Running save') # For debugging. def pause(): # Set state to PAUSE. print('Running pause') # For debugging. def step(): # Set state to STEP. print('Running step') # For debugging. def play(): # Set state to PLAY. print('Running play') # For debugging. def edit(): # Set state to PAUSE. # Watch for mouse clicks in game region and kill and birth cells accordingly. # Get mouse click coords. # Convert to cell coords. # Flip state of cell in universe AND onscreen. print('Running edit') # For debugging. def clear(): # Set state to PAUSE. # Clear the universe, i.e. make all cells dead. # Clear the screen. print('Running clear') # For debugging. def null(): print('Doing nothing') # For debugging. pass # We also need to initialize our universe. You can use the code in life_gui_6.py as a starting point. Feel free to substitute your code in if you want to use a more recent (efficient) ageing algorithm.","title":"Step 8: Merge the UI and the simulation code"},{"location":"07.2_CGoL_4_GUI/09_Step_8_Merge_ui_and_simulation/#step-8-merge-the-ui-and-the-simulation-code","text":"The last step is to connect the menu to the actions. That is a job for the assignment, but we will do a little bit of planning to get you started. One important decision we need to figure out where to age the universe. The ageing happens inside the main event loop. The event loop will be divided into two parts one to handle events and the other to play the game of life. The ageing of the universe will have to respond to the game state which can be PAUSE , STEP , or PLAY . (PAUSE, STEP, PLAY) = list(range(3)) running = True while running: # Handles events (if any): for event in pygame.event.get(): if event.type == pygame.QUIT: running = False elif event.type == pygame.MOUSEBUTTONUP: x = event.pos[0] y = event.pos[1] print(\"mouse at \", (x,y)) print(menu_area.inside(x,y)) if menu_area.inside(x,y): menu_position = (x - menu_area.left)//GRID_SIZE print('Menu item: ', menu_position) if menu_position < len(menu): menu[menu_position][0]() # Simulates the Game of Life: if game_state != PAUSE: # Create the next universe: # Age the universe: # Replace the universe with next universe # Display the universe # if the game state is STEP it will age once and then switch state back to PAUSE # otherwise if the game state is PLAY it will stay PLAY and keep ageing the universe if game_state == STEP: game_state = PAUSE pygame.quit() Now let's think about what each of our functions has to do. #............................................................................... # XXX Game Functions # def load(): # Set state to PAUSE, # conduct a dialogue about what file to load, # and load it. # # What to do if the size of the universe in the file is not the same # as ours? If it is smaller? If it is larger? print('Running load') # For debugging. def save(): # Set state to PAUSE, # conduct a dialogue about what file to save to, # and save it. print('Running save') # For debugging. def pause(): # Set state to PAUSE. print('Running pause') # For debugging. def step(): # Set state to STEP. print('Running step') # For debugging. def play(): # Set state to PLAY. print('Running play') # For debugging. def edit(): # Set state to PAUSE. # Watch for mouse clicks in game region and kill and birth cells accordingly. # Get mouse click coords. # Convert to cell coords. # Flip state of cell in universe AND onscreen. print('Running edit') # For debugging. def clear(): # Set state to PAUSE. # Clear the universe, i.e. make all cells dead. # Clear the screen. print('Running clear') # For debugging. def null(): print('Doing nothing') # For debugging. pass # We also need to initialize our universe. You can use the code in life_gui_6.py as a starting point. Feel free to substitute your code in if you want to use a more recent (efficient) ageing algorithm.","title":"Step 8: Merge the UI and the simulation code"},{"location":"08.1_CGI/00_index/","text":"CGI: Give your Python application a web interface Introduction Software Distribution Web-based Computing Introduction to CGI Your first web server Testing static serving Testing CGI serving Toward a real CGI program The input form The processing script Unifying the form input file and the script file Support file: mi2km_input_v3.html Support file: mi2km_output_v3.html Fancier input HTML form controls demoform.py Fancier output","title":"Contents"},{"location":"08.1_CGI/00_index/#cgi-give-your-python-application-a-web-interface","text":"Introduction Software Distribution Web-based Computing Introduction to CGI Your first web server Testing static serving Testing CGI serving Toward a real CGI program The input form The processing script Unifying the form input file and the script file Support file: mi2km_input_v3.html Support file: mi2km_output_v3.html Fancier input HTML form controls demoform.py Fancier output","title":"CGI: Give your Python application a web interface"},{"location":"08.1_CGI/01_Introduction/","text":"Introduction Int this section we\u2019ll see how to provide access to our programs over the web. There will be no tricky programming involved, no subtle algorithms or complicated data structures. Instead the challenge is in lining up all the pieces so they play nice together. We get to wear our sysadmin hats instead of our programmer hats. It does of course have its own frustrations, but they are new frustrations, and they do say \u201ca change is as good as a rest\u201d so enjoy the change.","title":"Introduction"},{"location":"08.1_CGI/01_Introduction/#introduction","text":"Int this section we\u2019ll see how to provide access to our programs over the web. There will be no tricky programming involved, no subtle algorithms or complicated data structures. Instead the challenge is in lining up all the pieces so they play nice together. We get to wear our sysadmin hats instead of our programmer hats. It does of course have its own frustrations, but they are new frustrations, and they do say \u201ca change is as good as a rest\u201d so enjoy the change.","title":"Introduction"},{"location":"08.1_CGI/02_Software_distribution/","text":"Software Distribution So you\u2019ve written a clever program. How do you let others use it? The answer to this simple question has changed several times over the years. In the early days (1950s-1960s) computers were rare so they brought their data to you and you ran your program using their data on your computer and then gave them the (fanfold lineprinter) output. This was inconvenient for you, but it was so cool to be a computer person you put up with it. Later (1970s) more people began to have their own computers, and you would send them the program for them to run on their computer which took less of your time. Depending on their system you might send them a card deck, a magnetic tape, or even a paper tape, a bit later a floppy disk, but sometimes just a printout and they would type the program into their computer themselves. Originally it was mainly scientists doing this so you sent them the source code for the progam which they entered or loaded, compiled and then ran (because everyone who was a computer user had a compiler and knew how to use it). Still later though (1980s!) business people began to develop software which they felt had value so they did not want to share it, and while many people had computers few of them had the knowledge to compile a program, so shrink-wrapped software was developed. This was a stand-alone precompiled program. The benefit for the user was that they just had to load it on their computer and run it. The drawback was that they could not modify it to correct or improve it. Also a different shrink-wrapped version was required for every operating system (sometimes one for each of several versions of each operating system). With the advent of the web (1995+) there was a shift back to the old ways. People again use your software on your computer using their data, but they input the data themselves. This is what happens whenever you use software over the web: you are executing programs on a server somewhere else feeding it data through your system. There are numerous advantages in web computing for both parties. For the provider there is only one installation to monitor (instead of dealing with the problems that can arise as users try to install software on numerous different platforms and potential conflicts from other pieces of software), and for the business-people they still control (and thus can charge for) access to the source code. For the user they don\u2019t have to worry about an installation step. For both, updates and upgrades are easy and immediate. As soon as an update is made to the server all the users benefit from it. There are of course also drawbacks, mainly for the user. Still no access to source code. Often a limited ability to back up their data since it lives on someone else\u2019s server. For the provider, the main problem is that they must also become system administrators and when a machine fails it\u2019s their problem 24x7.","title":"Software Distribution"},{"location":"08.1_CGI/02_Software_distribution/#software-distribution","text":"So you\u2019ve written a clever program. How do you let others use it? The answer to this simple question has changed several times over the years. In the early days (1950s-1960s) computers were rare so they brought their data to you and you ran your program using their data on your computer and then gave them the (fanfold lineprinter) output. This was inconvenient for you, but it was so cool to be a computer person you put up with it. Later (1970s) more people began to have their own computers, and you would send them the program for them to run on their computer which took less of your time. Depending on their system you might send them a card deck, a magnetic tape, or even a paper tape, a bit later a floppy disk, but sometimes just a printout and they would type the program into their computer themselves. Originally it was mainly scientists doing this so you sent them the source code for the progam which they entered or loaded, compiled and then ran (because everyone who was a computer user had a compiler and knew how to use it). Still later though (1980s!) business people began to develop software which they felt had value so they did not want to share it, and while many people had computers few of them had the knowledge to compile a program, so shrink-wrapped software was developed. This was a stand-alone precompiled program. The benefit for the user was that they just had to load it on their computer and run it. The drawback was that they could not modify it to correct or improve it. Also a different shrink-wrapped version was required for every operating system (sometimes one for each of several versions of each operating system). With the advent of the web (1995+) there was a shift back to the old ways. People again use your software on your computer using their data, but they input the data themselves. This is what happens whenever you use software over the web: you are executing programs on a server somewhere else feeding it data through your system. There are numerous advantages in web computing for both parties. For the provider there is only one installation to monitor (instead of dealing with the problems that can arise as users try to install software on numerous different platforms and potential conflicts from other pieces of software), and for the business-people they still control (and thus can charge for) access to the source code. For the user they don\u2019t have to worry about an installation step. For both, updates and upgrades are easy and immediate. As soon as an update is made to the server all the users benefit from it. There are of course also drawbacks, mainly for the user. Still no access to source code. Often a limited ability to back up their data since it lives on someone else\u2019s server. For the provider, the main problem is that they must also become system administrators and when a machine fails it\u2019s their problem 24x7.","title":"Software Distribution"},{"location":"08.1_CGI/03_Web_computing/","text":"Web Computing What changes for the programmer with the move from local computing to web computing? The system for local programming can be visualized like this: The user and the program interact more or less directly and the basic I/O statements in most programming languages correspond to the devices that have historically been used, thus input for fetching input and print for displaying output (though the word print really harkens back to line printers of old). There is of course an OS mediating between the devices and the running program, but they are well developed enough that they are almost invisible in the background. The system for web programming on the other hand can be visualized like this, Now the program the user interacts with directly is the web browser which communicates over a network (not shown in all its frightening complexity here) with a server. The browser dispatches information to the server and waits for a response from it which it then processes and displays to the user. Why isn\u2019t there an analog to input and print for web programming? Because the model of the connection between devices and computer is quite different. On a local machine the user is assumed to have a continuous long-lived interaction with the running program. The program is always paying attention to the users actions waiting for its chance to respond: think back to the main event loop, or your Pygame based Game of Life progams with the menus. Doing so when one server has to tend to many running clients would be too bandwidth intensive so the web is built on a very different protocol. One where interaction between client and server takes place in discrete chunks with ideally no connection between them. The client sends a complete free-standing request to the server which processes it and returns a single one-time response and then forgets about the client. To do this the client and server need to agree on how they will communicate over that connection between computers in the diagram above. We can mostly forget about all the layers of network protocols that underlie the communcation because for application programmers the relevant fact is that both computers marshal and encode their information using the Common Gateway Protocl (CGI) about which more on the next page. Just before that though, the diagram above is too pedestrian to squeeze money out of investors so the term cloud computing has been coined. It rearranges the same elements in the following way and represents the current age of computing, the age if you will of Google and social media.","title":"Web Computing"},{"location":"08.1_CGI/03_Web_computing/#web-computing","text":"What changes for the programmer with the move from local computing to web computing? The system for local programming can be visualized like this: The user and the program interact more or less directly and the basic I/O statements in most programming languages correspond to the devices that have historically been used, thus input for fetching input and print for displaying output (though the word print really harkens back to line printers of old). There is of course an OS mediating between the devices and the running program, but they are well developed enough that they are almost invisible in the background. The system for web programming on the other hand can be visualized like this, Now the program the user interacts with directly is the web browser which communicates over a network (not shown in all its frightening complexity here) with a server. The browser dispatches information to the server and waits for a response from it which it then processes and displays to the user. Why isn\u2019t there an analog to input and print for web programming? Because the model of the connection between devices and computer is quite different. On a local machine the user is assumed to have a continuous long-lived interaction with the running program. The program is always paying attention to the users actions waiting for its chance to respond: think back to the main event loop, or your Pygame based Game of Life progams with the menus. Doing so when one server has to tend to many running clients would be too bandwidth intensive so the web is built on a very different protocol. One where interaction between client and server takes place in discrete chunks with ideally no connection between them. The client sends a complete free-standing request to the server which processes it and returns a single one-time response and then forgets about the client. To do this the client and server need to agree on how they will communicate over that connection between computers in the diagram above. We can mostly forget about all the layers of network protocols that underlie the communcation because for application programmers the relevant fact is that both computers marshal and encode their information using the Common Gateway Protocl (CGI) about which more on the next page. Just before that though, the diagram above is too pedestrian to squeeze money out of investors so the term cloud computing has been coined. It rearranges the same elements in the following way and represents the current age of computing, the age if you will of Google and social media.","title":"Web Computing"},{"location":"08.1_CGI/04_Introduction_to_CGI/","text":"Introduction to CGI The previous page showed the following diagram of web-based programming. Let\u2019s look at this as application developers and focus on the software components: You can see that I have now labelled the arrows with the protocols of immediate interest to us. HyperText Transport Protocol (HTTP) used to communicate from client to server and CGI used both to communicate between client and server and to communicate between programs on the server. CGI is commonly used as a shorthand for web programming. It actually only refers to the Common Gateway Interface which isn\u2019t a language or a platform but simply a specification that describes how data from a browser should be encoded to be sent to the server. Because that is a necessary component of web programming, and also perhaps because it was the first component to be favoured with an acronym, it is often used as an umbrella term for much of web programming. A decade ago one had to write one\u2019s own code to parse CGI encoded messages, but the standard has been around long enough that standard libraries have evolved to take care of it and it has become almost transparent to the programmer. Transparent enough that we can further simplify this diagram and write our programs (mostly) as though the situation was this: which is not so different from the console-based programs we had been writing: Conceptually all we have to do is replace our text print statements with ones that output HTML instead of plain text (since this is being sent to a web browser), and to replace input statements with ones that read in information from a web form. The first could be done just by using a lot more print statements, since HTML is a verbose format compared to plain text, but we will use string interpolation into triple-quoted strings to make it simpler. The second is easier than you might think since Python provides a module that will take the encoded data from an HTML input form and decode it into a dictionary whose keys are the names of the form elements. Before we can explore those however we need to set up a web server to use.","title":"Introduction to CGI"},{"location":"08.1_CGI/04_Introduction_to_CGI/#introduction-to-cgi","text":"The previous page showed the following diagram of web-based programming. Let\u2019s look at this as application developers and focus on the software components: You can see that I have now labelled the arrows with the protocols of immediate interest to us. HyperText Transport Protocol (HTTP) used to communicate from client to server and CGI used both to communicate between client and server and to communicate between programs on the server. CGI is commonly used as a shorthand for web programming. It actually only refers to the Common Gateway Interface which isn\u2019t a language or a platform but simply a specification that describes how data from a browser should be encoded to be sent to the server. Because that is a necessary component of web programming, and also perhaps because it was the first component to be favoured with an acronym, it is often used as an umbrella term for much of web programming. A decade ago one had to write one\u2019s own code to parse CGI encoded messages, but the standard has been around long enough that standard libraries have evolved to take care of it and it has become almost transparent to the programmer. Transparent enough that we can further simplify this diagram and write our programs (mostly) as though the situation was this: which is not so different from the console-based programs we had been writing: Conceptually all we have to do is replace our text print statements with ones that output HTML instead of plain text (since this is being sent to a web browser), and to replace input statements with ones that read in information from a web form. The first could be done just by using a lot more print statements, since HTML is a verbose format compared to plain text, but we will use string interpolation into triple-quoted strings to make it simpler. The second is easier than you might think since Python provides a module that will take the encoded data from an HTML input form and decode it into a dictionary whose keys are the names of the form elements. Before we can explore those however we need to set up a web server to use.","title":"Introduction to CGI"},{"location":"08.1_CGI/05_Your_first_web_server/","text":"Your first web server Python has libraries that make it easy to create and run a simple web server. This server is useful for testing and development, though not robust or secure enough to run a large web site with significant traffic. Still it\u2019s pretty neat to be able to run a little web server on your desktop. Here\u2019s the code for the one we\u2019ll use: # httpserver.py # # When run locally the script serves up HTML pages from the directory it # lives in or is launched from, and runs Python CGI scripts from the cgi-bin # directory located there, i.e. HTML files are in the same directory as the # script and CGI scripts are located in a subdirectory named cgi-bin. To visit # them use URLs like, # http://localhost/somepage.html # http://localhost/cgi-bin/somescript.py import os, sys from http.server import HTTPServer from http.server import CGIHTTPRequestHandler webdir = '.' port = 8080 print(f'web directory \"{webdir:s}\", port {port:d}') # Because Windows is brain dead ... if sys.platform[:3] == 'win': CGIHTTPRequestHandler.have_popen2 = False CGIHTTPRequestHandler.have_popen3 = False sys.path.append('cgi-bin') os.chdir(webdir) serveraddr = ('', port) server = HTTPServer( serveraddr, CGIHTTPRequestHandler) server.serve_forever() As you can see from the code it will serve over port 8080. Port numbers less than 1024 require admin access, so they won't work well on the University's computers.","title":"Your first web server"},{"location":"08.1_CGI/05_Your_first_web_server/#your-first-web-server","text":"Python has libraries that make it easy to create and run a simple web server. This server is useful for testing and development, though not robust or secure enough to run a large web site with significant traffic. Still it\u2019s pretty neat to be able to run a little web server on your desktop. Here\u2019s the code for the one we\u2019ll use: # httpserver.py # # When run locally the script serves up HTML pages from the directory it # lives in or is launched from, and runs Python CGI scripts from the cgi-bin # directory located there, i.e. HTML files are in the same directory as the # script and CGI scripts are located in a subdirectory named cgi-bin. To visit # them use URLs like, # http://localhost/somepage.html # http://localhost/cgi-bin/somescript.py import os, sys from http.server import HTTPServer from http.server import CGIHTTPRequestHandler webdir = '.' port = 8080 print(f'web directory \"{webdir:s}\", port {port:d}') # Because Windows is brain dead ... if sys.platform[:3] == 'win': CGIHTTPRequestHandler.have_popen2 = False CGIHTTPRequestHandler.have_popen3 = False sys.path.append('cgi-bin') os.chdir(webdir) serveraddr = ('', port) server = HTTPServer( serveraddr, CGIHTTPRequestHandler) server.serve_forever() As you can see from the code it will serve over port 8080. Port numbers less than 1024 require admin access, so they won't work well on the University's computers.","title":"Your first web server"},{"location":"08.1_CGI/06_Testing_static_serving/","text":"Testing static serving Go ahead: Put an HTML file in the same directory as httpserver.py . If you don\u2019t have an HTML file handy right-click on this page and save it to that directory. Double-click on httpserver.py to run it. We are running it by double-clicking because we don\u2019t want to run it interactively, since we want it to keep running daemon-style while we work on our other code. Double-clicking the icon for httpserver.py in Windows Explorer (NOT Internet Explorer) will start it running and display its log messages in a console window. Type the URL http://localhost:8080/yourhtmlfilename.html in your browser address bar. The contents of the HTML file should be displayed in your browser. If not, get in touch and we\u2019ll try to debug it. When you are finished, stop the program by closing the console window.","title":"Testing static serving"},{"location":"08.1_CGI/06_Testing_static_serving/#testing-static-serving","text":"Go ahead: Put an HTML file in the same directory as httpserver.py . If you don\u2019t have an HTML file handy right-click on this page and save it to that directory. Double-click on httpserver.py to run it. We are running it by double-clicking because we don\u2019t want to run it interactively, since we want it to keep running daemon-style while we work on our other code. Double-clicking the icon for httpserver.py in Windows Explorer (NOT Internet Explorer) will start it running and display its log messages in a console window. Type the URL http://localhost:8080/yourhtmlfilename.html in your browser address bar. The contents of the HTML file should be displayed in your browser. If not, get in touch and we\u2019ll try to debug it. When you are finished, stop the program by closing the console window.","title":"Testing static serving"},{"location":"08.1_CGI/07_Testing_CGI_serving/","text":"Testing CGI serving So far there isn\u2019t much to brag about here. We can after all open html files directly in our browser without servers getting in the way. But this server also supports CGI-based communication (see those CGI substrings sprinkled throughout?). To check that it is working as a CGI server we need to test it with a Python program not a static HTML file. The key thing to be aware of to make this work are the server\u2019s built-in assumptions about file layout. Files in the same directory as it (\u2019 . \u2019) will be served as static files. Files in its cgi-bin subdirectory (\u2019 ./cgi-bin \u2019) will be served dynamically, i.e. it will attempt to run them as Python programs and return the program\u2019s output to the client (i.e. browser). So things should be organized like this: Go ahead: Copy and paste this code into a file named testcgi.py and save it in the cgi-bin directory. ``` python print('''Content-type: text/html <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> Test file This is it! That's all. ''') ``` Navigate to http://localhost:8080/cgi-bin/testcgi.py . You should see this display in your browser:","title":"Testing CGI serving"},{"location":"08.1_CGI/07_Testing_CGI_serving/#testing-cgi-serving","text":"So far there isn\u2019t much to brag about here. We can after all open html files directly in our browser without servers getting in the way. But this server also supports CGI-based communication (see those CGI substrings sprinkled throughout?). To check that it is working as a CGI server we need to test it with a Python program not a static HTML file. The key thing to be aware of to make this work are the server\u2019s built-in assumptions about file layout. Files in the same directory as it (\u2019 . \u2019) will be served as static files. Files in its cgi-bin subdirectory (\u2019 ./cgi-bin \u2019) will be served dynamically, i.e. it will attempt to run them as Python programs and return the program\u2019s output to the client (i.e. browser). So things should be organized like this: Go ahead: Copy and paste this code into a file named testcgi.py and save it in the cgi-bin directory. ``` python print('''Content-type: text/html <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> Test file","title":"Testing CGI serving"},{"location":"08.1_CGI/08_Toward_a_real_CGI_program/","text":"Toward a real CGI program Well our test cgi program was the equivalent of a 'hello world' program. It sent some output so we could see that the system was working, but it didn\u2019t do any input or processing. That is by design of course. Your first program in any new system should be dead simple so that you can concentrate on getting the system bits outside your program connected together properly without having to worry about problems within your program. But having got those program-system interactions working it\u2019s time to tackle complete programs. Recall that we have two main things to sort out within our programs (as opposed to the myriad relations of our programs to things outside themselves like systems and server software): Producing HTML for the browser instead of text for the console. Getting our input from HTML forms instead of the console. We saw on the previous page that 1. could still be done using print statements since HTML is also a textual format. So let\u2019s turn our attention to 2.","title":"Toward a real CGI program"},{"location":"08.1_CGI/08_Toward_a_real_CGI_program/#toward-a-real-cgi-program","text":"Well our test cgi program was the equivalent of a 'hello world' program. It sent some output so we could see that the system was working, but it didn\u2019t do any input or processing. That is by design of course. Your first program in any new system should be dead simple so that you can concentrate on getting the system bits outside your program connected together properly without having to worry about problems within your program. But having got those program-system interactions working it\u2019s time to tackle complete programs. Recall that we have two main things to sort out within our programs (as opposed to the myriad relations of our programs to things outside themselves like systems and server software): Producing HTML for the browser instead of text for the console. Getting our input from HTML forms instead of the console. We saw on the previous page that 1. could still be done using print statements since HTML is also a textual format. So let\u2019s turn our attention to 2.","title":"Toward a real CGI program"},{"location":"08.1_CGI/09_The_input_form/","text":"The input form We\u2019ll need a pair of files: the original HTML file that presents a form to fill in with input values, and a Python program that processes the form values and returns some output. Here\u2019s our input form respond.html : <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <title>Input form for respond.py</title> </head> <body> <h2>Input form for respond.py</h2> <form method=\"post\" action=\"cgi-bin/respond.py\"> <p>Enter your name: <input type=\"text\" name=\"user\" /></p> <p><input type=\"submit\" /></p> </form> </body> </html> Viewed in the browser it will look something like this, Everything is set up by the lines of the form element: <form method=\"post\" action=\"cgi-bin/respond.py\"> This line says that when the Submit button is clicked the form data should be sent to the program cgi-bin/respond.py on the server. <p>Enter your name: <input type=\"text\" name=\"user\" /> This line gives a name to the contents of the input box. Within our program we will be able to identify it by the index \"user\" . <p><input type=\"submit\" /></p> This line places the Submit button on the screen. Nothing is sent to the server until this button is clicked, but as soon as it is clicked the form contents are encoded and forwarded to the server. The Submit button is the GUI counterpart to pressing the Enter key in the IDLE shell.","title":"The input form"},{"location":"08.1_CGI/09_The_input_form/#the-input-form","text":"We\u2019ll need a pair of files: the original HTML file that presents a form to fill in with input values, and a Python program that processes the form values and returns some output. Here\u2019s our input form respond.html : <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <title>Input form for respond.py</title> </head> <body> <h2>Input form for respond.py</h2> <form method=\"post\" action=\"cgi-bin/respond.py\"> <p>Enter your name: <input type=\"text\" name=\"user\" /></p> <p><input type=\"submit\" /></p> </form> </body> </html> Viewed in the browser it will look something like this, Everything is set up by the lines of the form element: <form method=\"post\" action=\"cgi-bin/respond.py\"> This line says that when the Submit button is clicked the form data should be sent to the program cgi-bin/respond.py on the server. <p>Enter your name: <input type=\"text\" name=\"user\" /> This line gives a name to the contents of the input box. Within our program we will be able to identify it by the index \"user\" . <p><input type=\"submit\" /></p> This line places the Submit button on the screen. Nothing is sent to the server until this button is clicked, but as soon as it is clicked the form contents are encoded and forwarded to the server. The Submit button is the GUI counterpart to pressing the Enter key in the IDLE shell.","title":"The input form"},{"location":"08.1_CGI/10_The_processing_script/","text":"The processing script What about the script that receives the form input: respond.py ? It looks like this, # respond.py import cgi template = '''<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <title>respond.py output</title> </head> <body> <p>Hi %s.</p> </body> </html>''' form = cgi.FieldStorage() print('Content-type: text/html') print() print(template % (form['user'].value)) There\u2019s not much to see. We import the cgi module so we can have it parse the communication from the server. This is done by the line: form = cgi.FieldStorage(). Then we just insert the value of the user field of the form input into the output template using string interpolation in the last line and send the string to the client by print ing it.. There are several things to note about this program and process: Triple quoted strings give us a nice way of creating a template (like a form letter) into which we can insert the relevant values using string interpolation. The first print statement sends a header line to the client. This is required . In real-world applications there may be many header lines (specifying language, cache controls, encodings, etc.) We\u2019ll see a little bit more about them in a couple weeks. The blank line sent after the header line is required . The HTTP protocol calls for the body of a messge to be separated from the header lines describing the message by a single blank line, i.e. everything before a blank line is assumed to be header lines, only what follows the first blank line is assumed to be message to be displayed by the browser. the FieldStorage method creates a dictionary-like object that we can access using the names given to the fields in the HTML input form. The output in the browser should look something like this, Still nothing to look at, but as programmers you realize that now we have input to our program, and output from it, we have all the tools we need to do anything !","title":"The processing script"},{"location":"08.1_CGI/10_The_processing_script/#the-processing-script","text":"What about the script that receives the form input: respond.py ? It looks like this, # respond.py import cgi template = '''<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <title>respond.py output</title> </head> <body> <p>Hi %s.</p> </body> </html>''' form = cgi.FieldStorage() print('Content-type: text/html') print() print(template % (form['user'].value)) There\u2019s not much to see. We import the cgi module so we can have it parse the communication from the server. This is done by the line: form = cgi.FieldStorage(). Then we just insert the value of the user field of the form input into the output template using string interpolation in the last line and send the string to the client by print ing it.. There are several things to note about this program and process: Triple quoted strings give us a nice way of creating a template (like a form letter) into which we can insert the relevant values using string interpolation. The first print statement sends a header line to the client. This is required . In real-world applications there may be many header lines (specifying language, cache controls, encodings, etc.) We\u2019ll see a little bit more about them in a couple weeks. The blank line sent after the header line is required . The HTTP protocol calls for the body of a messge to be separated from the header lines describing the message by a single blank line, i.e. everything before a blank line is assumed to be header lines, only what follows the first blank line is assumed to be message to be displayed by the browser. the FieldStorage method creates a dictionary-like object that we can access using the names given to the fields in the HTML input form. The output in the browser should look something like this, Still nothing to look at, but as programmers you realize that now we have input to our program, and output from it, we have all the tools we need to do anything !","title":"The processing script"},{"location":"08.1_CGI/11_Unifying_input_form_and_processing_script/","text":"Unifying the input form and the processing script At the moment we have to manage, and keep track of, and keep in sync, two different files: the HTML input form and the processing script. However taking advantage of the ability of programs to do selection we can combine these two into a single file that can select the appropriate response based on what is passed to the script. If the FieldStorage instance has content then it was the result of a user filling out the form and pressing Submit , and we should process the data. On the other hand if the FieldStorage instance is empty it means no form has been filled out (perhaps because they are coming directly to this URL from a link or a search result) and we should present the form to the user. In code this looks like this: # mi2km_v3.py # # Demonstrates unified cgi script that detects whether request # is: # 1) from a completed form, or # 2) a first time visit. import cgi # We read the templates in from external files because # that makes them easier to create. You, or your web designer, # can create complete HTML pages in your editor of choice # and then you just replace the values to be interpolated for # with appropriate format codes. output_template = open(\"mi2km_output_v3.html\",\"r\").read() input_template = open(\"mi2km_input_v3.html\",\"r\").read() # Parse the CGI request into dictionary-like FieldStorage. form = cgi.FieldStorage() if 'miles' in form: # If they filled in the miles field, convert miles to km, miles = float( form['miles'].value ) km = miles * 1.609 # and display the output. print('Content-type: text/html\\n') print(output_template % (miles, km)) elif 'km' in form: # If they filled in the km field, convert km to miles, km = float( form['km'].value ) miles = km / 1.609 # and display the output. print('Content-type: text/html\\n') print(output_template % (miles, km)) else: # They filled in neither field so give them an input form to fill out. print('Content-type: text/html\\n') print(input_template) Notes: If you look carefully at mi2km_output_v3.html you will see that one common hack is required. % signs in CSS need to escaped, i.e. replaced with %% so the Python string interpolation mechanism won\u2019t interpret them as formatting fields. This is usually avoided by importing the CSS file instead of inserting the styles into the HTML file (which is best practice, but I wanted to avoid a veritable explosion in the number of files we had to keep track of).","title":"Unifying the input form and the processing script"},{"location":"08.1_CGI/11_Unifying_input_form_and_processing_script/#unifying-the-input-form-and-the-processing-script","text":"At the moment we have to manage, and keep track of, and keep in sync, two different files: the HTML input form and the processing script. However taking advantage of the ability of programs to do selection we can combine these two into a single file that can select the appropriate response based on what is passed to the script. If the FieldStorage instance has content then it was the result of a user filling out the form and pressing Submit , and we should process the data. On the other hand if the FieldStorage instance is empty it means no form has been filled out (perhaps because they are coming directly to this URL from a link or a search result) and we should present the form to the user. In code this looks like this: # mi2km_v3.py # # Demonstrates unified cgi script that detects whether request # is: # 1) from a completed form, or # 2) a first time visit. import cgi # We read the templates in from external files because # that makes them easier to create. You, or your web designer, # can create complete HTML pages in your editor of choice # and then you just replace the values to be interpolated for # with appropriate format codes. output_template = open(\"mi2km_output_v3.html\",\"r\").read() input_template = open(\"mi2km_input_v3.html\",\"r\").read() # Parse the CGI request into dictionary-like FieldStorage. form = cgi.FieldStorage() if 'miles' in form: # If they filled in the miles field, convert miles to km, miles = float( form['miles'].value ) km = miles * 1.609 # and display the output. print('Content-type: text/html\\n') print(output_template % (miles, km)) elif 'km' in form: # If they filled in the km field, convert km to miles, km = float( form['km'].value ) miles = km / 1.609 # and display the output. print('Content-type: text/html\\n') print(output_template % (miles, km)) else: # They filled in neither field so give them an input form to fill out. print('Content-type: text/html\\n') print(input_template)","title":"Unifying the input form and the processing script"},{"location":"08.1_CGI/11_Unifying_input_form_and_processing_script/#notes","text":"If you look carefully at mi2km_output_v3.html you will see that one common hack is required. % signs in CSS need to escaped, i.e. replaced with %% so the Python string interpolation mechanism won\u2019t interpret them as formatting fields. This is usually avoided by importing the CSS file instead of inserting the styles into the HTML file (which is best practice, but I wanted to avoid a veritable explosion in the number of files we had to keep track of).","title":"Notes:"},{"location":"08.1_CGI/12_Fancier_input/","text":"Fancier input HTML forms allow for quite a bit more types of input than we have taken advantage of so far. Exploring the rest of them is easily done by self-study. The next two pages provide a sample form showing the most common form controls and a script that shows how to access its contents. Neither is rocket science. Enjoy!","title":"Fancier input"},{"location":"08.1_CGI/12_Fancier_input/#fancier-input","text":"HTML forms allow for quite a bit more types of input than we have taken advantage of so far. Exploring the rest of them is easily done by self-study. The next two pages provide a sample form showing the most common form controls and a script that shows how to access its contents. Neither is rocket science. Enjoy!","title":"Fancier input"},{"location":"08.1_CGI/14_Fancier_output/","text":"Fancier output Fancier output isn\u2019t really a concern for us in the context of this course. It\u2019s a matter for your project\u2019s graphic designers. But it\u2019s pretty unsatisfying to produce downright ugly interactions so feel free to indulge in some CSS wizardry to dress up the input and output. Because this, while no work of art, is nicer than this, If CSS is brand new to you, I\u2019ll provide some boilerplate cosmetic enhancements for your assignment programs.","title":"Fancier output"},{"location":"08.1_CGI/14_Fancier_output/#fancier-output","text":"Fancier output isn\u2019t really a concern for us in the context of this course. It\u2019s a matter for your project\u2019s graphic designers. But it\u2019s pretty unsatisfying to produce downright ugly interactions so feel free to indulge in some CSS wizardry to dress up the input and output. Because this, while no work of art, is nicer than this, If CSS is brand new to you, I\u2019ll provide some boilerplate cosmetic enhancements for your assignment programs.","title":"Fancier output"},{"location":"08.1_CGI/Mxx_Assignment/","text":"Assignment xx Problems Logistics Use the following naming scheme for your program files:, a assignment# p problem# v version# .py . Submit your assignment using the Dropbox link above.","title":"Assignment xx"},{"location":"08.1_CGI/Mxx_Assignment/#assignment-xx","text":"","title":"Assignment xx"},{"location":"08.1_CGI/Mxx_Assignment/#problems","text":"","title":"Problems"},{"location":"08.1_CGI/Mxx_Assignment/#logistics","text":"Use the following naming scheme for your program files:, a assignment# p problem# v version# .py . Submit your assignment using the Dropbox link above.","title":"Logistics"},{"location":"08.1_CGI/Stupid/","text":"Hi Tim Topper.","title":"Stupid"},{"location":"08.1_CGI/mi2km_input_v3/","text":"CPSC 129: Object-oriented programming II. Fall 2024. Convert miles to kilometres or vice versa! ::: {#content} You enter one value and I\u2019ll show you the other... miles kilometers =","title":"Mi2km input v3"},{"location":"08.1_CGI/mi2km_input_v3/#convert-miles-to-kilometres-or-vice-versa","text":"::: {#content} You enter one value and I\u2019ll show you the other... miles kilometers =","title":"Convert miles to kilometres or vice versa!"},{"location":"08.1_CGI/mi2km_output_v3/","text":"CPSC 129: Object-oriented programming II. Winter 2012. Convert miles to kilometres or vice versa! ::: {#content} miles kilometers %2.1f = %2.1f","title":"Mi2km output v3"},{"location":"08.1_CGI/mi2km_output_v3/#convert-miles-to-kilometres-or-vice-versa","text":"::: {#content} miles kilometers %2.1f = %2.1f","title":"Convert miles to kilometres or vice versa!"},{"location":"08.1_CGI/pWeatherServer-input/","text":"Whitehorse Weather Server ::: centered Year Month 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 January February March April May June July August September October November December Select the year and month for which you want data displayed","title":"Whitehorse Weather Server"},{"location":"08.1_CGI/pWeatherServer-input/#whitehorse-weather-server","text":"::: centered Year Month 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 January February March April May June July August September October November December Select the year and month for which you want data displayed","title":"Whitehorse Weather Server"},{"location":"08.1_CGI/pWeatherServer-output/","text":"Whitehorse Weather Server ::: centered Date Temperature 1 10.6 2 7.8 3 10.0 4 4.4 5 10.6 6 12.8 7 11.1 8 13.3 9 12.8 10 18.9 11 21.1 12 22.2 13 21.1 14 23.3 15 15.6 16 18.3 17 20.6 18 19.4 19 18.3 20 17.2 21 16.7 22 15.0 23 18.3 24 20.6 25 25.6 26 19.4 27 16.1 28 21.7 29 23.3 30 17.2 31 16.7 Daily Maximum Temperature (deg C) Whitehorse Airport May 1942","title":"Whitehorse Weather Server"},{"location":"08.1_CGI/pWeatherServer-output/#whitehorse-weather-server","text":"::: centered Date Temperature 1 10.6 2 7.8 3 10.0 4 4.4 5 10.6 6 12.8 7 11.1 8 13.3 9 12.8 10 18.9 11 21.1 12 22.2 13 21.1 14 23.3 15 15.6 16 18.3 17 20.6 18 19.4 19 18.3 20 17.2 21 16.7 22 15.0 23 18.3 24 20.6 25 25.6 26 19.4 27 16.1 28 21.7 29 23.3 30 17.2 31 16.7 Daily Maximum Temperature (deg C) Whitehorse Airport May 1942","title":"Whitehorse Weather Server"},{"location":"08.2_Mazes_2/00_index/","text":"Interactive Maze Interactive Maze","title":"Contents"},{"location":"08.2_Mazes_2/00_index/#interactive-maze","text":"Interactive Maze","title":"Interactive Maze"},{"location":"08.2_Mazes_2/01_Interactive_Maze/","text":"An Interactive Maze A couple of weeks ago we wrote code to create mazes. Let\u2019s add code so that people can try to solve them. We\u2019ll modify maze_6.py so that our users can try to solve it by moving an icon (perhaps our standby Aqua-Ball-icon.png: through it. They should be able to control the icon with either the mouse (by clicking in the cell they want it to move to) or the arrow keys (to try and move it up, down, left or right). The program should prevent them from moving the icon through walls, and should be able to tell when they have won and maybe play a triumphant sound --- or at least beep (cheerfully rather than gratingly!). The pseudocode is fairly straightforward: clock = pygame.time.Clock() # See Note 1. set the initial maze dimensions while the user is not finished playing generate a maze while the current cell is not the exit cell # Wait for an event: quit, mouse click or keypress. event = pygame.event.wait(): # See Note 2. if event.type == pygame.QUIT: pygame.quit() sys.exit() elif event.type == pygame.MOUSEBUTTONUP: Get mouse coords. Convert mouse coords to cell coords. (Hint: as in earlier Life GUI program). elif event.type == KEYUP: N.B. event contains keypress information Figure out what requested destination cell is. if the destination cell neighbours the current cell and if there is a door connecting them change the current cell location to be the destination cell move the player icon from the old cell to the new one else: beep chidingly # See Note 3. clock.tick(20) # Adjust parameter to suit. play the happy sound # See Note 3. make the maze fade/dissolve/crumble # See Note 4. increase the maze dimensions Notes: pygame.time.Clock() is used because this is not a fast action game where we want every CPU resource available going to monitor events from the user. Instead we\u2019d like this program to get along with the other programs running on our computer and give them a chance to get things done as well. We\u2019ll use the .tick() method to tell pygame to take timeouts during its processing. You\u2019ll want to adjust the parameter to tick() so that Pygame resource usage does not spike, while keeping the game responsive. Similarly, we\u2019ll use pygame.event.wait() both so that our program will get along well with others, and so that our program will only ever handle one event per main event loop. According to the pygame documentation it: \"Returns a single event from the queue. If the queue is empty this function will wait until one is created. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.\u201d You play a sound by loading it which creates a sound object and then invoking the object\u2019s play method, sound = pygame.mixer.Sound(filename) sound.play() This bit of code assumes filename exists, and can be opened, and interpreted as a sound file. You might be interested to see how the code changes if we add typical safety checks to it using Python exceptions , ``` python def load_sound(name): # Define a dummy class that behaves enough like a Sound object # that the rest of the game will still run. class NoneSound: def play(self): pass # Check that pygame.mixer was imported successfully. if not pygame.mixer: return NoneSound() # Now try loading the sound file. try: sound = pygame.mixer.Sound(name) except: print('Cannot load sound:', name) raise SystemExit return sound sound = load_sound(filename) ``` There are lots of sources for .wav files on the internet, but a small one with a decent selection for small programming projects for the undiscriminating user is http://www.mediacollege.com/downloads/sound-effects/ . I use it because it is small, and the sound effects are free to download. You can fade the maze away by redrawing it in increasingly dim colours. You could dissolve it by randomly removing walls until there are none left. Crumbling the maze is left as a challenge. Enhancements are possible and will be tested with great relish. For example, You could make it easier to solve (and more visually interesting) by highlighting the path the user has taken so far (this is simple until they back up, when you have to unhighlight the path you have previously highlighted). You can make it much harder by giving them a time limit and moving them back to the entrance when the time limit expires. You could provide a limited number of explosive charges so they can blast walls out of the way. Very cool, but very subtle to program, you could have walls change, that is replace some walls with doors and vice versa. The tricky business is changing things so that there always remains some path to the exit (it\u2019s easy to block your player in). ...your imagination is the only limit!","title":"An Interactive Maze"},{"location":"08.2_Mazes_2/01_Interactive_Maze/#an-interactive-maze","text":"A couple of weeks ago we wrote code to create mazes. Let\u2019s add code so that people can try to solve them. We\u2019ll modify maze_6.py so that our users can try to solve it by moving an icon (perhaps our standby Aqua-Ball-icon.png: through it. They should be able to control the icon with either the mouse (by clicking in the cell they want it to move to) or the arrow keys (to try and move it up, down, left or right). The program should prevent them from moving the icon through walls, and should be able to tell when they have won and maybe play a triumphant sound --- or at least beep (cheerfully rather than gratingly!). The pseudocode is fairly straightforward: clock = pygame.time.Clock() # See Note 1. set the initial maze dimensions while the user is not finished playing generate a maze while the current cell is not the exit cell # Wait for an event: quit, mouse click or keypress. event = pygame.event.wait(): # See Note 2. if event.type == pygame.QUIT: pygame.quit() sys.exit() elif event.type == pygame.MOUSEBUTTONUP: Get mouse coords. Convert mouse coords to cell coords. (Hint: as in earlier Life GUI program). elif event.type == KEYUP: N.B. event contains keypress information Figure out what requested destination cell is. if the destination cell neighbours the current cell and if there is a door connecting them change the current cell location to be the destination cell move the player icon from the old cell to the new one else: beep chidingly # See Note 3. clock.tick(20) # Adjust parameter to suit. play the happy sound # See Note 3. make the maze fade/dissolve/crumble # See Note 4. increase the maze dimensions Notes: pygame.time.Clock() is used because this is not a fast action game where we want every CPU resource available going to monitor events from the user. Instead we\u2019d like this program to get along with the other programs running on our computer and give them a chance to get things done as well. We\u2019ll use the .tick() method to tell pygame to take timeouts during its processing. You\u2019ll want to adjust the parameter to tick() so that Pygame resource usage does not spike, while keeping the game responsive. Similarly, we\u2019ll use pygame.event.wait() both so that our program will get along well with others, and so that our program will only ever handle one event per main event loop. According to the pygame documentation it: \"Returns a single event from the queue. If the queue is empty this function will wait until one is created. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.\u201d You play a sound by loading it which creates a sound object and then invoking the object\u2019s play method, sound = pygame.mixer.Sound(filename) sound.play() This bit of code assumes filename exists, and can be opened, and interpreted as a sound file. You might be interested to see how the code changes if we add typical safety checks to it using Python exceptions , ``` python def load_sound(name): # Define a dummy class that behaves enough like a Sound object # that the rest of the game will still run. class NoneSound: def play(self): pass # Check that pygame.mixer was imported successfully. if not pygame.mixer: return NoneSound() # Now try loading the sound file. try: sound = pygame.mixer.Sound(name) except: print('Cannot load sound:', name) raise SystemExit return sound sound = load_sound(filename) ``` There are lots of sources for .wav files on the internet, but a small one with a decent selection for small programming projects for the undiscriminating user is http://www.mediacollege.com/downloads/sound-effects/ . I use it because it is small, and the sound effects are free to download. You can fade the maze away by redrawing it in increasingly dim colours. You could dissolve it by randomly removing walls until there are none left. Crumbling the maze is left as a challenge. Enhancements are possible and will be tested with great relish. For example, You could make it easier to solve (and more visually interesting) by highlighting the path the user has taken so far (this is simple until they back up, when you have to unhighlight the path you have previously highlighted). You can make it much harder by giving them a time limit and moving them back to the entrance when the time limit expires. You could provide a limited number of explosive charges so they can blast walls out of the way. Very cool, but very subtle to program, you could have walls change, that is replace some walls with doors and vice versa. The tricky business is changing things so that there always remains some path to the exit (it\u2019s easy to block your player in). ...your imagination is the only limit!","title":"An Interactive Maze"},{"location":"09.1_Median/00_index/","text":"Two Approaches to Median Finding: An Algorithm Development Case Study Introduction Median by Partitioning v0 Median by Partitioning v1 Median by Partitioning v2 Median by Partitioning v3 Median by Bounding v0 Median by Bounding v1 Median by Bounding v2 Median by Bounding v3","title":"Contents"},{"location":"09.1_Median/00_index/#two-approaches-to-median-finding-an-algorithm-development-case-study","text":"Introduction Median by Partitioning v0 Median by Partitioning v1 Median by Partitioning v2 Median by Partitioning v3 Median by Bounding v0 Median by Bounding v1 Median by Bounding v2 Median by Bounding v3","title":"Two Approaches to Median Finding: An Algorithm Development Case Study"},{"location":"09.1_Median/01_Introduction/","text":"Introduction: median() The focus this week is on a single function: median() . median \u2019s job is to find the median value in a list of numbers. The median is defined to be the number in a set of numbers that separates the larger \u201chalf\u201d of the values from the lower \u201chalf\u201d of the values, i.e. if you take the set of numbers and sort them, the median will be the number in the middle position. For example if your set of numbers is [37, 61, 42, 21, 19, 86, 95, 78, 54] then the median is 54 because when you sort the list you get [19, 21, 37, 42, 54, 61, 78, 86, 95] and 54 is the middle entry in that list[^*]. This suggests one straightforward way of finding the median value: sort the list and extract the item at the middle index, def median(l): l.sort() return l[len(l)//2] This code is blessedly short, and since the good sorts, e.g. quicksort, Shellsort and heapsort, are O( n log n ) so is this algorithm. But can we do better? Can we find the median without sorting the entire list? Median by partition One possibility is to do just enough sorting to identify the median. The idea would be not to sort the whole list, but just to sort the area in the middle. But how can we identify that area before beginning? The quicksort provides one approach if we successively partition just the partitions that contain the median. For example, if our first partitioning of the list produces two ranges one with 60% of the list and other with the remaining 40% we know the median must be in 60% portion, so we then repartition just that \u201chalf\u201d and ignore the 40% portion. We continue in this way until we have worked our way down to a single element partition containing the median. Thus we very partially sort the entire list as we partition and only ever completely sort the tiny sublist that contains the median itself. Median by bounding Of course all that partitioning will involve a lot of element swapping which could take time, and it will scramble the list which might not be allowable in some applications. Perhaps the whole sorting approach was a wrong turn. Looking back to the original definition The median is defined to be the number in a set of numbers that separates the larger \u201chalf\u201d of the values from the lower \u201chalf\u201d of the values, so another possibility suggests itself. The median will be the value in the list that has the same number of values larger than it as smaller than it. So we could find the median by considering each value in the list and counting the number of values smaller than it and the number of values larger that it. If they are equal, then this value is the median. (Excluding temporarily the possibilities that there are an even number of items in the list, or that the median value may occur more than once in the list). If it is done just as described in the previous paragraph this approach is O( n 2 /2) . n 2 because we must scan the list of n values for each of the n values in it, thus making n \u00d7 n or n 2 operations. /2 because we will on average find the median halfway through the list. We can do better than n 2 /2 if we realize that each value we examine that fails to be the median provides some information about the actual median value. For example, if we check the value 72 and discover that there are 11 values smaller than it in the list and 18 values larger than it in the list, we know the median must be larger than 72. This means that if we later get to the value 58 we will not count smaller and larger values for it because we already know it cannot be the median because it is not larger than 72. This suggests that we maintain a pair of values (I will use lo and hi ) denoting the current range within which we know the median must lie. If a value is outside this range we will not consider it. If a value is inside this range, we will test it, but if it proves not to be the median, we will use it to refine the range, thus narrowing the range each time we count, and allowing us to consider even fewer values in the future. Next The remaining video resources will step you through the development of two modules median_by_partn.py and median_by_bounding.py that implement each of these approaches. On the assignment you will measure their performance and extend them to handle all possible lists. [^*] You may be wondering what happens if there an even number of values in the set, since then there may not be a middle value, e.g. [32, 19, 84, 56] sorted is [19, 32, 56, 84] and there is no middle value. Conventional practice is to take the mean (average) of the two values on either side of the \u201cmiddle\u201d, i.e. in this case we say the median is (32 + 56)/2 = 44, even though 44 isn\u2019t even a value in the set. Note that sets with an even number of values may have a median value that does occur in the set when it contains duplicate values, e.g. [42, 19, 84, 42] sorted is [19, 42, 42, 84] and we get a median of 42. For our development of median() we will begin by working with lists with odd numbers of values, and you will extend this to lists with even numbers of values on the assignment.","title":"Introduction: median()"},{"location":"09.1_Median/01_Introduction/#introduction-median","text":"The focus this week is on a single function: median() . median \u2019s job is to find the median value in a list of numbers. The median is defined to be the number in a set of numbers that separates the larger \u201chalf\u201d of the values from the lower \u201chalf\u201d of the values, i.e. if you take the set of numbers and sort them, the median will be the number in the middle position. For example if your set of numbers is [37, 61, 42, 21, 19, 86, 95, 78, 54] then the median is 54 because when you sort the list you get [19, 21, 37, 42, 54, 61, 78, 86, 95] and 54 is the middle entry in that list[^*]. This suggests one straightforward way of finding the median value: sort the list and extract the item at the middle index, def median(l): l.sort() return l[len(l)//2] This code is blessedly short, and since the good sorts, e.g. quicksort, Shellsort and heapsort, are O( n log n ) so is this algorithm. But can we do better? Can we find the median without sorting the entire list?","title":"Introduction: median()"},{"location":"09.1_Median/01_Introduction/#median-by-partition","text":"One possibility is to do just enough sorting to identify the median. The idea would be not to sort the whole list, but just to sort the area in the middle. But how can we identify that area before beginning? The quicksort provides one approach if we successively partition just the partitions that contain the median. For example, if our first partitioning of the list produces two ranges one with 60% of the list and other with the remaining 40% we know the median must be in 60% portion, so we then repartition just that \u201chalf\u201d and ignore the 40% portion. We continue in this way until we have worked our way down to a single element partition containing the median. Thus we very partially sort the entire list as we partition and only ever completely sort the tiny sublist that contains the median itself.","title":"Median by partition"},{"location":"09.1_Median/01_Introduction/#median-by-bounding","text":"Of course all that partitioning will involve a lot of element swapping which could take time, and it will scramble the list which might not be allowable in some applications. Perhaps the whole sorting approach was a wrong turn. Looking back to the original definition The median is defined to be the number in a set of numbers that separates the larger \u201chalf\u201d of the values from the lower \u201chalf\u201d of the values, so another possibility suggests itself. The median will be the value in the list that has the same number of values larger than it as smaller than it. So we could find the median by considering each value in the list and counting the number of values smaller than it and the number of values larger that it. If they are equal, then this value is the median. (Excluding temporarily the possibilities that there are an even number of items in the list, or that the median value may occur more than once in the list). If it is done just as described in the previous paragraph this approach is O( n 2 /2) . n 2 because we must scan the list of n values for each of the n values in it, thus making n \u00d7 n or n 2 operations. /2 because we will on average find the median halfway through the list. We can do better than n 2 /2 if we realize that each value we examine that fails to be the median provides some information about the actual median value. For example, if we check the value 72 and discover that there are 11 values smaller than it in the list and 18 values larger than it in the list, we know the median must be larger than 72. This means that if we later get to the value 58 we will not count smaller and larger values for it because we already know it cannot be the median because it is not larger than 72. This suggests that we maintain a pair of values (I will use lo and hi ) denoting the current range within which we know the median must lie. If a value is outside this range we will not consider it. If a value is inside this range, we will test it, but if it proves not to be the median, we will use it to refine the range, thus narrowing the range each time we count, and allowing us to consider even fewer values in the future.","title":"Median by bounding"},{"location":"09.1_Median/01_Introduction/#next","text":"The remaining video resources will step you through the development of two modules median_by_partn.py and median_by_bounding.py that implement each of these approaches. On the assignment you will measure their performance and extend them to handle all possible lists. [^*] You may be wondering what happens if there an even number of values in the set, since then there may not be a middle value, e.g. [32, 19, 84, 56] sorted is [19, 32, 56, 84] and there is no middle value. Conventional practice is to take the mean (average) of the two values on either side of the \u201cmiddle\u201d, i.e. in this case we say the median is (32 + 56)/2 = 44, even though 44 isn\u2019t even a value in the set. Note that sets with an even number of values may have a median value that does occur in the set when it contains duplicate values, e.g. [42, 19, 84, 42] sorted is [19, 42, 42, 84] and we get a median of 42. For our development of median() we will begin by working with lists with odd numbers of values, and you will extend this to lists with even numbers of values on the assignment.","title":"Next"},{"location":"09.1_Median/02_median_by_partn_0/","text":"Median by Partitioning: Version 0 Based on the insight that the median value will be in the middle of a list of sorted values, plus the hint that we may be able to find it without completely sorting the list, we find the median by successive partitions of the list. Our strategy will be to partition as in quicksort initially, but then to further partition only the portion that will contain the median. We could do this with indices or by building new lists. Let's start by building new lists, because it is much easier to write. Let's set our initial pivot value to index 0 and build the first two sublists: one with values smaller than the pivot and one with values larger than the pivot. # median_by_partn.py def median(lst): # Start by partitioning the list into a list of values smaller than # the pivot and a list of values larger than the pivot. pivot = lst[0] smaller = [] larger = [] for value in lst: if value < pivot: smaller.append(value) else: larger.append(value) return str(smaller) + ' + ' + str(larger) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) After implementing this algorithm we get a smaller list [19, 21] and the larger list [37, 61, 42, 86, 95, 78, 54] . The list larger list has more elements, so on the next iteration of our partitioning we will focus on that larger list.","title":"Median by Partitioning: Version 0"},{"location":"09.1_Median/02_median_by_partn_0/#median-by-partitioning-version-0","text":"Based on the insight that the median value will be in the middle of a list of sorted values, plus the hint that we may be able to find it without completely sorting the list, we find the median by successive partitions of the list. Our strategy will be to partition as in quicksort initially, but then to further partition only the portion that will contain the median. We could do this with indices or by building new lists. Let's start by building new lists, because it is much easier to write. Let's set our initial pivot value to index 0 and build the first two sublists: one with values smaller than the pivot and one with values larger than the pivot. # median_by_partn.py def median(lst): # Start by partitioning the list into a list of values smaller than # the pivot and a list of values larger than the pivot. pivot = lst[0] smaller = [] larger = [] for value in lst: if value < pivot: smaller.append(value) else: larger.append(value) return str(smaller) + ' + ' + str(larger) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) After implementing this algorithm we get a smaller list [19, 21] and the larger list [37, 61, 42, 86, 95, 78, 54] . The list larger list has more elements, so on the next iteration of our partitioning we will focus on that larger list.","title":"Median by Partitioning: Version 0"},{"location":"09.1_Median/03_median_by_partn_1/","text":"Median by Partitioning: Version 1 The next step of our median by partition approach is to call median again on one of the sub partitions. To do this we need to figure out which list contains the median value. To do this we want to check to see if the position of the median value would fall in the smaller or larger list. To do that we need a new variable posn to store the position of the list. Initially the position of the median will be len(lst)//2 , but that will change as we do recursive calls. ... # < < < < < < P > > # M if len(smaller) > posn: return median(smaller, posn) # < < P > > > > > > # M else: return median(larger, posn-len(smaller)) ... Because we don't want to include a position argument in our initial call to median , we are going to create a helper function _median with has two arguments. According to PEP 8 [http://www.python.org/dev/peps/pep-0008/] we should use one leading underscore in the names of non-public methods, i.e. ones that are for internal use only. Also notice that posn needs to be adjusted when larger is the longer list. This is because we have have to subtract the list positions that are in the smaller list. def median(lst): return _median(lst, len(lst)//2) def _median(lst, posn): print(lst, posn) # Debugging pivot = lst[0] smaller = [] larger = [] for value in lst: if value < pivot: smaller.append(value) else: larger.append(value) # If we are hunting for the value that will end up in posn 3 # and there are 5 elements in smaller, then we better look in smaller. if len(smaller) > posn: return _median(smaller, posn) # But if we are looking for position 8 and there are only 5 # elements in smaller, we better look in larger. # But we are no longer looking for position 8 in larger. # Since there are 5 elements in smaller we are now looking for # posn = 8 - 5 = 3 in larger. else: return _median(larger, posn-len(smaller)) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) If you run the above code you'll find that it gives an infinite loop. Looking at the print statement that we included for debugging we see that it gets stuck after the first partition. The problem seems to be that it is trying to partition with the same value it used in the first call (`[37, 61, 42, 86, 95, 78, 54] 2') This tells me that we should have removed our partition value from the list. We will do that in the next iteration of our solution.","title":"Median by Partitioning: Version 1"},{"location":"09.1_Median/03_median_by_partn_1/#median-by-partitioning-version-1","text":"The next step of our median by partition approach is to call median again on one of the sub partitions. To do this we need to figure out which list contains the median value. To do this we want to check to see if the position of the median value would fall in the smaller or larger list. To do that we need a new variable posn to store the position of the list. Initially the position of the median will be len(lst)//2 , but that will change as we do recursive calls. ... # < < < < < < P > > # M if len(smaller) > posn: return median(smaller, posn) # < < P > > > > > > # M else: return median(larger, posn-len(smaller)) ... Because we don't want to include a position argument in our initial call to median , we are going to create a helper function _median with has two arguments. According to PEP 8 [http://www.python.org/dev/peps/pep-0008/] we should use one leading underscore in the names of non-public methods, i.e. ones that are for internal use only. Also notice that posn needs to be adjusted when larger is the longer list. This is because we have have to subtract the list positions that are in the smaller list. def median(lst): return _median(lst, len(lst)//2) def _median(lst, posn): print(lst, posn) # Debugging pivot = lst[0] smaller = [] larger = [] for value in lst: if value < pivot: smaller.append(value) else: larger.append(value) # If we are hunting for the value that will end up in posn 3 # and there are 5 elements in smaller, then we better look in smaller. if len(smaller) > posn: return _median(smaller, posn) # But if we are looking for position 8 and there are only 5 # elements in smaller, we better look in larger. # But we are no longer looking for position 8 in larger. # Since there are 5 elements in smaller we are now looking for # posn = 8 - 5 = 3 in larger. else: return _median(larger, posn-len(smaller)) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) If you run the above code you'll find that it gives an infinite loop. Looking at the print statement that we included for debugging we see that it gets stuck after the first partition. The problem seems to be that it is trying to partition with the same value it used in the first call (`[37, 61, 42, 86, 95, 78, 54] 2') This tells me that we should have removed our partition value from the list. We will do that in the next iteration of our solution.","title":"Median by Partitioning: Version 1"},{"location":"09.1_Median/04_median_by_partn_2/","text":"Median by Partitioning: Version 2 Let's tackle the infinite loop in the previous version of our code. Because of our if-else structure the pivot is added to the larger list. One way to fix this would be to add an elif to collect the values that are equal to the pivot, this will of course include the pivot, but may also include duplicate values from elsewhere in the partition. def median(lst): return _median(lst, len(lst)//2) def _median(lst, posn): print(lst, posn) # Debugging pivot = lst[0] smaller = [] larger = [] equal = [] for value in lst: if value < pivot: smaller.append(value) elif value == pivot: equal.append(value) else: larger.append(value) # If we are hunting for the value that will end up in posn 3 # and there are 5 elements in smaller, then we better look in smaller. if len(smaller) > posn: return _median(smaller, posn) # On the other hand if we are looking for position 8 and there are # 5 in smaller and less than 9 values in smaller and equal together # then our value lies in equal and since all the values in equal are # the same we can return any of them, like equal[[0], and be done. # (N.B. this test assumes that we've already eliminated smaller above.) elif len(smaller) + len(equal) > posn: return equal[0] # But if we are looking for position 11 and there are only 9 # elements in smaller and equal together, we better look in larger. # But we are no longer looking for position 8 in larger. # Since there are 9 elements accounted for in smaller and equal # we are now looking for posn = 11 - 9 = 2 in larger. # (I had to draw a picture to sort that out -- you might need to too # to understand it). else: return _median(larger, posn-(len(smaller)+len(equal))) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) The new recursive call, that now takes the equal list into account, also gives us our stop condition for our recursion.","title":"Median by Partitioning: Version 2"},{"location":"09.1_Median/04_median_by_partn_2/#median-by-partitioning-version-2","text":"Let's tackle the infinite loop in the previous version of our code. Because of our if-else structure the pivot is added to the larger list. One way to fix this would be to add an elif to collect the values that are equal to the pivot, this will of course include the pivot, but may also include duplicate values from elsewhere in the partition. def median(lst): return _median(lst, len(lst)//2) def _median(lst, posn): print(lst, posn) # Debugging pivot = lst[0] smaller = [] larger = [] equal = [] for value in lst: if value < pivot: smaller.append(value) elif value == pivot: equal.append(value) else: larger.append(value) # If we are hunting for the value that will end up in posn 3 # and there are 5 elements in smaller, then we better look in smaller. if len(smaller) > posn: return _median(smaller, posn) # On the other hand if we are looking for position 8 and there are # 5 in smaller and less than 9 values in smaller and equal together # then our value lies in equal and since all the values in equal are # the same we can return any of them, like equal[[0], and be done. # (N.B. this test assumes that we've already eliminated smaller above.) elif len(smaller) + len(equal) > posn: return equal[0] # But if we are looking for position 11 and there are only 9 # elements in smaller and equal together, we better look in larger. # But we are no longer looking for position 8 in larger. # Since there are 9 elements accounted for in smaller and equal # we are now looking for posn = 11 - 9 = 2 in larger. # (I had to draw a picture to sort that out -- you might need to too # to understand it). else: return _median(larger, posn-(len(smaller)+len(equal))) if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(lst) print(median(lst)) The new recursive call, that now takes the equal list into account, also gives us our stop condition for our recursion.","title":"Median by Partitioning: Version 2"},{"location":"09.1_Median/05_median_by_partn_3/","text":"Median by Partitioning: Version 3 Let's make sure that our function works on a wider variety of lists. As always when picking tests make sure to consider some of the edge conditions our function might encounter. Here we're going to really think about duplicates. if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(median(lst)) print(median([1])) # lists of length 1 print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) We haven't yet handled the cases where there are an even number of elements in the list. That is an exercise for the assignment!","title":"Median by Partitioning: Version 3"},{"location":"09.1_Median/05_median_by_partn_3/#median-by-partitioning-version-3","text":"Let's make sure that our function works on a wider variety of lists. As always when picking tests make sure to consider some of the edge conditions our function might encounter. Here we're going to really think about duplicates. if __name__ == '__main__': lst = [37, 61, 42, 21, 19, 86, 95, 78, 54] print(median(lst)) print(median([1])) # lists of length 1 print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) We haven't yet handled the cases where there are an even number of elements in the list. That is an exercise for the assignment!","title":"Median by Partitioning: Version 3"},{"location":"09.1_Median/06_median_by_bounding_0/","text":"Median by Bounding: Version 0 Median by bounding is based on the insight that the median is the value that has the same number of values larger than it and smaller than it. We will assume for the moment that we don't need a wrapper/helper function for median. We don't know what the median value is, so we will need to check each element in the list. Then for each element we will count how many items are smaller and how many are larger. If the number of items that are smaller and larger are equal, then we have found the median. def median(lst): # It could be any item in the list, so we check each one. for item in lst: # Check if this item is the median. # Count smaller and larger values. count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 # Test: If it is the median then the same number of values # will be smaller than it as will be larger than it. if count_smaller == count_larger: return item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) This algorithm seems to work well on some of our test cases, but it fails on the last two tests. If you look closely at those two tests you can see that the smaller count and the larger count can't be equal because of the duplicate values.","title":"Median by Bounding: Version 0"},{"location":"09.1_Median/06_median_by_bounding_0/#median-by-bounding-version-0","text":"Median by bounding is based on the insight that the median is the value that has the same number of values larger than it and smaller than it. We will assume for the moment that we don't need a wrapper/helper function for median. We don't know what the median value is, so we will need to check each element in the list. Then for each element we will count how many items are smaller and how many are larger. If the number of items that are smaller and larger are equal, then we have found the median. def median(lst): # It could be any item in the list, so we check each one. for item in lst: # Check if this item is the median. # Count smaller and larger values. count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 # Test: If it is the median then the same number of values # will be smaller than it as will be larger than it. if count_smaller == count_larger: return item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) This algorithm seems to work well on some of our test cases, but it fails on the last two tests. If you look closely at those two tests you can see that the smaller count and the larger count can't be equal because of the duplicate values.","title":"Median by Bounding: Version 0"},{"location":"09.1_Median/07_median_by_bounding_1/","text":"Median by Bounding: Version 1 The previous version failed because the median won't always have exactly the same number of values smaller and larger than it. What is sufficient to be the median is for the values smaller and the values larger to each be less than or equal to half the length of the list. def median(lst): for item in lst: count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller = count_smaller + 1 elif value > item: count_larger = count_larger + 1 # Refined logic to account for duplicates. # Test: If it is the median then half or less of the values # will be smaller than it, and half or less will be larger than it, # i.e. the largest the \"halves\" could be is: # < < < < = > > > > # but it could also be # < < < = = = = > > # in which case the <s and >s each account for less than half # the values. if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: return item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 5, 42, 42, 42, 99])) print(median([42, 42, 42, 99])) This code looks like it works, but it is not very efficient. The order of this algorthm is n 2 . You can see that because of the nested for loop, where we need to consider each element in the list, and then consider each other element in relationship to it to get our counts. If we think of the list length as being n, then for each of n items we do n comparisons giving us nxn or n 2 . We can do better than n 2 by keeping track of a range that the median must fall in, so that we don't bother with values outside that range. Consider the first test case, after we get the smaller and larger counts for 37 we establish that there are more numbers that are larger than 37, so the median must be higher than 37. After this we do not need to count for any values less than 37.","title":"Median by Bounding: Version 1"},{"location":"09.1_Median/07_median_by_bounding_1/#median-by-bounding-version-1","text":"The previous version failed because the median won't always have exactly the same number of values smaller and larger than it. What is sufficient to be the median is for the values smaller and the values larger to each be less than or equal to half the length of the list. def median(lst): for item in lst: count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller = count_smaller + 1 elif value > item: count_larger = count_larger + 1 # Refined logic to account for duplicates. # Test: If it is the median then half or less of the values # will be smaller than it, and half or less will be larger than it, # i.e. the largest the \"halves\" could be is: # < < < < = > > > > # but it could also be # < < < = = = = > > # in which case the <s and >s each account for less than half # the values. if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: return item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 5, 42, 42, 42, 99])) print(median([42, 42, 42, 99])) This code looks like it works, but it is not very efficient. The order of this algorthm is n 2 . You can see that because of the nested for loop, where we need to consider each element in the list, and then consider each other element in relationship to it to get our counts. If we think of the list length as being n, then for each of n items we do n comparisons giving us nxn or n 2 . We can do better than n 2 by keeping track of a range that the median must fall in, so that we don't bother with values outside that range. Consider the first test case, after we get the smaller and larger counts for 37 we establish that there are more numbers that are larger than 37, so the median must be higher than 37. After this we do not need to count for any values less than 37.","title":"Median by Bounding: Version 1"},{"location":"09.1_Median/08_median_by_bounding_2/","text":"Median by Bounding: Version 2 Now let's update the code so that it can learn as it makes its way through the list about the bounds on the possible values of the median. We need to keep track of two values that act as bounds (boundaries) for the possible value of the median. For example, once we've made the counts for 37 in our first test we can use 37 as the lower bound for our median value. After that all items that are less than our lower bound (ie 19 and 21) do not need to be considered. We will want to keep track of this low value as well as a high value, to represent the upper bound. The median will always fall between the low and high value. The bounds will need initial values, we can't choose arbitrary values because we don't know the range of our list. The solution is computationally expensive, we are going to set them to the min and max values in the list. It is computationally expensive because we have to search the whole list twice to get the min and the max values (n+n). We also need to add a condition that only considers items inside our range between lo and hi. The final change we need to make is to update the value of lo or hi for each item that isn't the medium. def median(lst): lo = min(lst) hi = max(lst) for item in lst: # Check if this item is the median, # but don't bother if it is outside the possible range. if item >= lo and item <= hi: count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: return item # update our bounds elif count_smaller > count_larger: hi = item else: lo = item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) # < < < = = = > # M # < < < = > > > # < < < < < > > This looks good and still gives the right answer, but we should check to see if we are saving time.","title":"Median by Bounding: Version 2"},{"location":"09.1_Median/08_median_by_bounding_2/#median-by-bounding-version-2","text":"Now let's update the code so that it can learn as it makes its way through the list about the bounds on the possible values of the median. We need to keep track of two values that act as bounds (boundaries) for the possible value of the median. For example, once we've made the counts for 37 in our first test we can use 37 as the lower bound for our median value. After that all items that are less than our lower bound (ie 19 and 21) do not need to be considered. We will want to keep track of this low value as well as a high value, to represent the upper bound. The median will always fall between the low and high value. The bounds will need initial values, we can't choose arbitrary values because we don't know the range of our list. The solution is computationally expensive, we are going to set them to the min and max values in the list. It is computationally expensive because we have to search the whole list twice to get the min and the max values (n+n). We also need to add a condition that only considers items inside our range between lo and hi. The final change we need to make is to update the value of lo or hi for each item that isn't the medium. def median(lst): lo = min(lst) hi = max(lst) for item in lst: # Check if this item is the median, # but don't bother if it is outside the possible range. if item >= lo and item <= hi: count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: return item # update our bounds elif count_smaller > count_larger: hi = item else: lo = item if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) # < < < = = = > # M # < < < = > > > # < < < < < > > This looks good and still gives the right answer, but we should check to see if we are saving time.","title":"Median by Bounding: Version 2"},{"location":"09.1_Median/09_median_by_bounding_3/","text":"Median by Bounding: Version 3 To find out if it is saving us time let's instrument our code, or count the number of values we consider and the number of values we skip. We'll start by adding new variables to track the number considered and the number skipped . The value of considered should be incremented each time the item is within the bound. To track the number of skipped values we need to add an else block where skipped is incremented. A print statement before the the return statement tells us what we saved. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) What we see when we run it is the following... Considered = 4 Skipped = 5 54 Considered = 1 Skipped = 0 1 Considered = 2 Skipped = 0 42 Considered = 2 Skipped = 0 42 Considered = 3 Skipped = 0 42 Considered = 1 Skipped = 0 42 We seem to save a lot of time on our longer list, but less time on our shorter ordered lists. Let's build a longer list of values to try in on. We'll import random, and append values from a larger range to our list. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': # Build a big random list to get sense of how many computations # our bounding trick is saving us. import random lst = [] for i in range(1000): lst.append(random.randint(1,100000)) print(median(lst)) When I ran this I got the following result... Considered = 15 Skipped = 104 52562 So in a list with 1000 items, we only needed to consider 15 values, plus the overhead of finding the min and max (2 more times). This might be a bit lucky, because it found the median at position 119 of our list (15 + 104). Let's create a loop and test this more thoroughly. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': # Build a big random list to get sense of how many computations # our bounding trick is saving us. import random for _ in range(10): lst = [] for i in range(1000): lst.append(random.randint(1,100000)) print(median(lst)) That gives the following output... Considered = 13 Skipped = 563 48329 Considered = 11 Skipped = 590 49325 Considered = 8 Skipped = 52 46175 Considered = 13 Skipped = 261 48863 Considered = 12 Skipped = 490 49424 Considered = 9 Skipped = 385 48842 Considered = 12 Skipped = 602 48113 Considered = 4 Skipped = 0 45933 Considered = 10 Skipped = 12 50159 Considered = 14 Skipped = 770 49216 The number of values we consider in the list is never very large, even when the median is found later in the list and the number of skipped values is very large. It would be interesting to graph the number of items considered relative to the length of the list. If we did that we would see that this would look like a log(n) relationship. In the assignment you will have the opportunity to compare the partition approach to the bounding approach to see which one is faster.","title":"Median by Bounding: Version 3"},{"location":"09.1_Median/09_median_by_bounding_3/#median-by-bounding-version-3","text":"To find out if it is saving us time let's instrument our code, or count the number of values we consider and the number of values we skip. We'll start by adding new variables to track the number considered and the number skipped . The value of considered should be incremented each time the item is within the bound. To track the number of skipped values we need to add an else block where skipped is incremented. A print statement before the the return statement tells us what we saved. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': print(median([37, 61, 42, 21, 19, 86, 95, 78, 54])) print(median([1])) print(median([1, 42, 99])) print(median([1, 42, 42, 42, 99])) print(median([1, 5, 42, 42, 99])) print(median([42, 42, 42, 42, 99])) What we see when we run it is the following... Considered = 4 Skipped = 5 54 Considered = 1 Skipped = 0 1 Considered = 2 Skipped = 0 42 Considered = 2 Skipped = 0 42 Considered = 3 Skipped = 0 42 Considered = 1 Skipped = 0 42 We seem to save a lot of time on our longer list, but less time on our shorter ordered lists. Let's build a longer list of values to try in on. We'll import random, and append values from a larger range to our list. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': # Build a big random list to get sense of how many computations # our bounding trick is saving us. import random lst = [] for i in range(1000): lst.append(random.randint(1,100000)) print(median(lst)) When I ran this I got the following result... Considered = 15 Skipped = 104 52562 So in a list with 1000 items, we only needed to consider 15 values, plus the overhead of finding the min and max (2 more times). This might be a bit lucky, because it found the median at position 119 of our list (15 + 104). Let's create a loop and test this more thoroughly. def median(lst): lo = min(lst) hi = max(lst) considered = 0 skipped = 0 for item in lst: if item >= lo and item <= hi: considered += 1 count_smaller = 0 count_larger = 0 for value in lst: if value < item: count_smaller += 1 elif value > item: count_larger += 1 if count_smaller <= len(lst)//2 and count_larger <= len(lst)//2: print('Considered =', considered, 'Skipped =', skipped) return item elif count_smaller > count_larger: hi = item else: lo = item else: skipped += 1 if __name__ == '__main__': # Build a big random list to get sense of how many computations # our bounding trick is saving us. import random for _ in range(10): lst = [] for i in range(1000): lst.append(random.randint(1,100000)) print(median(lst)) That gives the following output... Considered = 13 Skipped = 563 48329 Considered = 11 Skipped = 590 49325 Considered = 8 Skipped = 52 46175 Considered = 13 Skipped = 261 48863 Considered = 12 Skipped = 490 49424 Considered = 9 Skipped = 385 48842 Considered = 12 Skipped = 602 48113 Considered = 4 Skipped = 0 45933 Considered = 10 Skipped = 12 50159 Considered = 14 Skipped = 770 49216 The number of values we consider in the list is never very large, even when the median is found later in the list and the number of skipped values is very large. It would be interesting to graph the number of items considered relative to the length of the list. If we did that we would see that this would look like a log(n) relationship. In the assignment you will have the opportunity to compare the partition approach to the bounding approach to see which one is faster.","title":"Median by Bounding: Version 3"},{"location":"09.2_Data_Processing/00_index/","text":"Data Processing Introduction Case Study: Spelling Bee Administration Data Processing View Potential Problems Python Exceptions EasyGUI","title":"Contents"},{"location":"09.2_Data_Processing/00_index/#data-processing","text":"Introduction Case Study: Spelling Bee Administration Data Processing View Potential Problems Python Exceptions EasyGUI","title":"Data Processing"},{"location":"09.2_Data_Processing/01_Introduction/","text":"Introduction Before there were smartphones and iPods, there were personal computers, and before that people didn\u2019t own computers. Instead there were minicomputers and mainframes owned by organizations that used them for data processing. Data processing programs generally involve taking some raw data and converting it into useful information. So for example a piece of medical equipment might take raw measurements of some bodily function and present a dynamic graph of it, or an accounting system might take a raw record of transactions and produce a series of summary documents like cash flow statements and balance sheets. From the programmer\u2019s point of view the challenges usually arise in handling the data and especially from its occasional absence (due to missing values) or format inconsistency rather than from tricky algorithms or complicated data structures. As one former student put it, \u201cit\u2019s a chance to just do good old-fashioned programming\u201d. There will be some new techniques to put to work, but they are straightforward. The first will be more emphasis than we have usually placed on recovering from errors. We have largely ignored problems with input to our programs because we have been emphasizing their algorithmics. Introducing a lot of error checking code, which can be verbose, would have obscured the algorithm details we needed to focus on. Since we were not trying hard to catch data-based errors we didn\u2019t have to tell anybody about them. Doing so however raises some issues in interacting with the user. This week and again in the coming weeks we\u2019ll consider a few real-world situations requiring data processing.","title":"Introduction"},{"location":"09.2_Data_Processing/01_Introduction/#introduction","text":"Before there were smartphones and iPods, there were personal computers, and before that people didn\u2019t own computers. Instead there were minicomputers and mainframes owned by organizations that used them for data processing. Data processing programs generally involve taking some raw data and converting it into useful information. So for example a piece of medical equipment might take raw measurements of some bodily function and present a dynamic graph of it, or an accounting system might take a raw record of transactions and produce a series of summary documents like cash flow statements and balance sheets. From the programmer\u2019s point of view the challenges usually arise in handling the data and especially from its occasional absence (due to missing values) or format inconsistency rather than from tricky algorithms or complicated data structures. As one former student put it, \u201cit\u2019s a chance to just do good old-fashioned programming\u201d. There will be some new techniques to put to work, but they are straightforward. The first will be more emphasis than we have usually placed on recovering from errors. We have largely ignored problems with input to our programs because we have been emphasizing their algorithmics. Introducing a lot of error checking code, which can be verbose, would have obscured the algorithm details we needed to focus on. Since we were not trying hard to catch data-based errors we didn\u2019t have to tell anybody about them. Doing so however raises some issues in interacting with the user. This week and again in the coming weeks we\u2019ll consider a few real-world situations requiring data processing.","title":"Introduction"},{"location":"09.2_Data_Processing/02_Spelling_bee_The_problem/","text":"Spelling Bee: The Problem Each year our local telco Northwestel sponsors French and English spelling bees in Whitehorse. A month or two before the bee students in the local schools are given word lists (one list per grade) to study. Later each school holds a spelling bee. The school champions get to compete in a territory-wide competition. The format of this competition is fairly straightforward. Students in each category are asked one at a time to spell a word. If they spell it correctly, they continue into later rounds. If they spell it incorrectly, they are eliminated. The process continues until only one speller is left. Sometimes the best spellers are quite good and the competition exhausts the words for that grade level. When that happens they use words from the next grade\u2019s list. The logistics of running the competition are fairly straightforward, but also time-consuming and error-prone to complete by hand. Since it is done manually and in real-time errors are inevitable and in recent years there have been some problems. It has happened that a word has been asked of more than one speller which is a problem because the second student to spell it may have heard it spelled by the first. It has even happened that a single student has been asked the same word twice. Computers are good where humans are weak (and vice versa of course): they are fast and systematic in their processing where we are slow and unreliable, so the suggestion has been made that the process be automated. You have been \u201cvoluntold\u201d to help them out. They have given you a text file of the test words ( spelling_list.txt ), a CSV (Comma Separated Value) formatted text file of the contestants generated from the Excel spreadsheet they are using for results ( spelling_contestants.txt ), and a sample of the output they would like for each contestant ( spelling_output.html ). Your job is to write a Python program that allows the user to specify the word and contestant files, and that will then generate an HTML word list for each contestant. The filenames for the contestants\u2019 word lists should be in the form firstinitial_lastname.html (so the example file name should really be named t_topper.html ). The words for each contestant should be selected randomly from the word list, and no word should be used twice either for a given contestant or across contestants.","title":"Spelling Bee: The Problem"},{"location":"09.2_Data_Processing/02_Spelling_bee_The_problem/#spelling-bee-the-problem","text":"Each year our local telco Northwestel sponsors French and English spelling bees in Whitehorse. A month or two before the bee students in the local schools are given word lists (one list per grade) to study. Later each school holds a spelling bee. The school champions get to compete in a territory-wide competition. The format of this competition is fairly straightforward. Students in each category are asked one at a time to spell a word. If they spell it correctly, they continue into later rounds. If they spell it incorrectly, they are eliminated. The process continues until only one speller is left. Sometimes the best spellers are quite good and the competition exhausts the words for that grade level. When that happens they use words from the next grade\u2019s list. The logistics of running the competition are fairly straightforward, but also time-consuming and error-prone to complete by hand. Since it is done manually and in real-time errors are inevitable and in recent years there have been some problems. It has happened that a word has been asked of more than one speller which is a problem because the second student to spell it may have heard it spelled by the first. It has even happened that a single student has been asked the same word twice. Computers are good where humans are weak (and vice versa of course): they are fast and systematic in their processing where we are slow and unreliable, so the suggestion has been made that the process be automated. You have been \u201cvoluntold\u201d to help them out. They have given you a text file of the test words ( spelling_list.txt ), a CSV (Comma Separated Value) formatted text file of the contestants generated from the Excel spreadsheet they are using for results ( spelling_contestants.txt ), and a sample of the output they would like for each contestant ( spelling_output.html ). Your job is to write a Python program that allows the user to specify the word and contestant files, and that will then generate an HTML word list for each contestant. The filenames for the contestants\u2019 word lists should be in the form firstinitial_lastname.html (so the example file name should really be named t_topper.html ). The words for each contestant should be selected randomly from the word list, and no word should be used twice either for a given contestant or across contestants.","title":"Spelling Bee: The Problem"},{"location":"09.2_Data_Processing/03_Spelling_bee_Data_processing_view/","text":"Data Processing View The overall processing flow then is: The processing steps are straightforward: get the name of the word list from the user get the name of contestant list from the user read in the word list read in the contestant list for each contestant select 10 words at random from the word list remove the words from the word list (so they will not be used more than once) write this contestant's html file write out the reduced word list (unused_words.txt)","title":"Data Processing View"},{"location":"09.2_Data_Processing/03_Spelling_bee_Data_processing_view/#data-processing-view","text":"The overall processing flow then is: The processing steps are straightforward: get the name of the word list from the user get the name of contestant list from the user read in the word list read in the contestant list for each contestant select 10 words at random from the word list remove the words from the word list (so they will not be used more than once) write this contestant's html file write out the reduced word list (unused_words.txt)","title":"Data Processing View"},{"location":"09.2_Data_Processing/04_Spelling_bee_Potential_problems/","text":"Potential Problems As mentioned in the introduction to this module the challenges in data processing are usually posed by the data rather than the processing algorithms. For example you will have to deal with the possibility that you cannot read one of the files. This could happen if you do not have permissions to read the file, if the file does not exist, etc. How could one of the files not exist? It could be because it actually doesn\u2019t exist (perhaps the volunteer forgot to copy it onto the flashdrive being used), or perhaps it appears to your program not to exist because they typed its name in incorrectly. At any rate you need to, at best, help them out, and, at least, fail gracefully with an explanation. Similarly you\u2019ll have to ensure that the files are properly formatted, for example that each record in the contestant file does contain the number fields you expect it to, not more, and not less. Let\u2019s say you opt to split a line to get the field values, e.g. running (number, last_name, first_name) = line.split(',') will produce an error if the value of line is \"Topper,Tim\" , >>> (number, first_name, last_name) = 'Topper,Tim'.split(',') Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> (number, last_name, first_name) = line.split(',') ValueError: not enough values to unpack (expected 3, got 2) >>> But a naive\u201d user should not be confronted with a Python error message. There are two programming approaches to dealing with potential error situations. One is anticipatory, the other is reactive. In the anticipatory approach you check that there is an object with the name you were given, that it is a file (not a directory, or link, etc.), that you have permisson to open it and so on. In the reactive approach you try to open it and then deal with an error if one results by catching exceptions\u201d. Which approach should be preferred is a subject of active debate in the programming community[^*], but one approach often dominates the other in particular languages. The anticipatory approach is prevalent in the C community, while the reactive approach is more common in the Python community. See the next page, Python Exceptions , for the syntactical details about working with Python\u2019s exceptions. [^*] A readable entry to the debate is Joel Spolsky\u2019 spiece titled simply Exceptions . Searching for reactions to the piece will lead you to the other side of the debate.","title":"Potential Problems"},{"location":"09.2_Data_Processing/04_Spelling_bee_Potential_problems/#potential-problems","text":"As mentioned in the introduction to this module the challenges in data processing are usually posed by the data rather than the processing algorithms. For example you will have to deal with the possibility that you cannot read one of the files. This could happen if you do not have permissions to read the file, if the file does not exist, etc. How could one of the files not exist? It could be because it actually doesn\u2019t exist (perhaps the volunteer forgot to copy it onto the flashdrive being used), or perhaps it appears to your program not to exist because they typed its name in incorrectly. At any rate you need to, at best, help them out, and, at least, fail gracefully with an explanation. Similarly you\u2019ll have to ensure that the files are properly formatted, for example that each record in the contestant file does contain the number fields you expect it to, not more, and not less. Let\u2019s say you opt to split a line to get the field values, e.g. running (number, last_name, first_name) = line.split(',') will produce an error if the value of line is \"Topper,Tim\" , >>> (number, first_name, last_name) = 'Topper,Tim'.split(',') Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> (number, last_name, first_name) = line.split(',') ValueError: not enough values to unpack (expected 3, got 2) >>> But a naive\u201d user should not be confronted with a Python error message. There are two programming approaches to dealing with potential error situations. One is anticipatory, the other is reactive. In the anticipatory approach you check that there is an object with the name you were given, that it is a file (not a directory, or link, etc.), that you have permisson to open it and so on. In the reactive approach you try to open it and then deal with an error if one results by catching exceptions\u201d. Which approach should be preferred is a subject of active debate in the programming community[^*], but one approach often dominates the other in particular languages. The anticipatory approach is prevalent in the C community, while the reactive approach is more common in the Python community. See the next page, Python Exceptions , for the syntactical details about working with Python\u2019s exceptions. [^*] A readable entry to the debate is Joel Spolsky\u2019 spiece titled simply Exceptions . Searching for reactions to the piece will lead you to the other side of the debate.","title":"Potential Problems"},{"location":"09.2_Data_Processing/05_Python_exceptions/","text":"Python Exceptions Python supports special statements to enable error handling. The key structure is the try ...except... block: try: # statements to try go here except: # code to handle exceptions (errors) goes here A try statement works a bit like an if statement. First the statements inside the try block are executed. If they all complete without an error (exception) occurring the except block is skipped. However if an exception is generated by any of the statements in the try block, then the remaining statements in the try block are skipped and Python looks for an except clause that handles that particular exception. Simple example: try: x = int(input(\"Please enter an integer value: \")) except ValueError: print(\"Give me an integer damnit!\") If I run it, Please enter an integer value: hello Give me an integer damnit! And here it is dressed up a bit, done = False while not done: try: x = int(input('Please enter an integer value: ')) done = True except ValueError: print('Give me an integer damnit!') print('Thanks!') and its output when run (by an idiot), >>> Please enter an integer value: hello Give me an integer damnit! Please enter an integer value: 4.5 Give me an integer damnit! Please enter an integer value: 3 Thanks! >>> Now how did I know to watch for a ValueError exception in that code? Because I\u2019d seen it when running the code without exception handling: >>> x = int(input('Please enter an integer value: ')) Please enter an integer value: 4.5 Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> x = int(input('Please enter an integer value: ')) ValueError: invalid literal for int() with base 10: '4.5' >>> We\u2019ve seen lots of error messages during CPSC 128 and CPSC 129, but perhaps never realized that every one of them was telling us what exception we\u2019d caused! Instead of nagging us, Python was reaching out to us and offering us a handle to deal with the problem we had (inadvertently) caused. Some more examples: >>> 'tim'.sort() Traceback (most recent call last): File \"<pyshell#1>\", line 1, in <module> 'tim'.sort() AttributeError: 'str' object has no attribute 'sort' >>> 10/0 Traceback (most recent call last): File \"<pyshell#2>\", line 1, in <module> 10/0 ZeroDivisionError: division by zero >>> '1' + 1 Traceback (most recent call last): File \"<pyshell#3>\", line 1, in <module> '1' + 1 TypeError: can only concatenate str (not \"int\") to str >>> The Python documentation provides a complete list of built-in exceptions . Back to try...except... syntax. Most try blocks will contain a few statements, several of which may be able to generate exceptions (and some of which may be capable of generating more than one). You can have as many except clauses as you need to catch and handle the errors you can recover from, >>> b = 0 >>> try: print(a/b) except NameError: print('Either a or b, or both, don\u2019t exist.') except ZeroDivisionError: print('Dang, b must be 0.') Either a or b, or both, don't exist. >>> a = 5 >>> try: print(a/b) except NameError: print('Either a or b, or both, don\u2019t exist.') except ZeroDivisionError: print('Dang, b must be 0.') Dang, b must be 0. >>> There is much more that can be learned about exceptions: Exceptions are first class objects, i.e. they are members of classes and can have both data (attributes) and methods. If there is no handler for an exception in the block where the exception occurred it will be passed to try statements in enclosing blocks. You aren\u2019t limited to using only the built-in exceptions, you can create, raise and handle your own exceptions that are specific to the kind of processing your program is doing. The Python tutorial provides a more gradual introduction to these advanced aspects of exceptions than the reference manual if you are interested, but we will not make use of them in CPSC 129.","title":"Python Exceptions"},{"location":"09.2_Data_Processing/05_Python_exceptions/#python-exceptions","text":"Python supports special statements to enable error handling. The key structure is the try ...except... block: try: # statements to try go here except: # code to handle exceptions (errors) goes here A try statement works a bit like an if statement. First the statements inside the try block are executed. If they all complete without an error (exception) occurring the except block is skipped. However if an exception is generated by any of the statements in the try block, then the remaining statements in the try block are skipped and Python looks for an except clause that handles that particular exception. Simple example: try: x = int(input(\"Please enter an integer value: \")) except ValueError: print(\"Give me an integer damnit!\") If I run it, Please enter an integer value: hello Give me an integer damnit! And here it is dressed up a bit, done = False while not done: try: x = int(input('Please enter an integer value: ')) done = True except ValueError: print('Give me an integer damnit!') print('Thanks!') and its output when run (by an idiot), >>> Please enter an integer value: hello Give me an integer damnit! Please enter an integer value: 4.5 Give me an integer damnit! Please enter an integer value: 3 Thanks! >>> Now how did I know to watch for a ValueError exception in that code? Because I\u2019d seen it when running the code without exception handling: >>> x = int(input('Please enter an integer value: ')) Please enter an integer value: 4.5 Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> x = int(input('Please enter an integer value: ')) ValueError: invalid literal for int() with base 10: '4.5' >>> We\u2019ve seen lots of error messages during CPSC 128 and CPSC 129, but perhaps never realized that every one of them was telling us what exception we\u2019d caused! Instead of nagging us, Python was reaching out to us and offering us a handle to deal with the problem we had (inadvertently) caused. Some more examples: >>> 'tim'.sort() Traceback (most recent call last): File \"<pyshell#1>\", line 1, in <module> 'tim'.sort() AttributeError: 'str' object has no attribute 'sort' >>> 10/0 Traceback (most recent call last): File \"<pyshell#2>\", line 1, in <module> 10/0 ZeroDivisionError: division by zero >>> '1' + 1 Traceback (most recent call last): File \"<pyshell#3>\", line 1, in <module> '1' + 1 TypeError: can only concatenate str (not \"int\") to str >>> The Python documentation provides a complete list of built-in exceptions . Back to try...except... syntax. Most try blocks will contain a few statements, several of which may be able to generate exceptions (and some of which may be capable of generating more than one). You can have as many except clauses as you need to catch and handle the errors you can recover from, >>> b = 0 >>> try: print(a/b) except NameError: print('Either a or b, or both, don\u2019t exist.') except ZeroDivisionError: print('Dang, b must be 0.') Either a or b, or both, don't exist. >>> a = 5 >>> try: print(a/b) except NameError: print('Either a or b, or both, don\u2019t exist.') except ZeroDivisionError: print('Dang, b must be 0.') Dang, b must be 0. >>> There is much more that can be learned about exceptions: Exceptions are first class objects, i.e. they are members of classes and can have both data (attributes) and methods. If there is no handler for an exception in the block where the exception occurred it will be passed to try statements in enclosing blocks. You aren\u2019t limited to using only the built-in exceptions, you can create, raise and handle your own exceptions that are specific to the kind of processing your program is doing. The Python tutorial provides a more gradual introduction to these advanced aspects of exceptions than the reference manual if you are interested, but we will not make use of them in CPSC 129.","title":"Python Exceptions"},{"location":"09.2_Data_Processing/06_EasyGUI/","text":"EasyGUI Earlier I said that a naive user should not be confronted with Python error messages. Similarly they shouldn\u2019t really be confronted by a Python shell to interact with, but should instead get to interact with the sorts of interface elements they are used to, e.g. message boxes, pick lists, file dialogs, etc. If you just need simple dialogues a library called EasyGUI is your friend. It makes it incredibly easy to use GUI components for user interaction instead of the Python console[^*]. EasyGUI is very easy to get started with. Its brief tutorial explains almost all the language features. Here\u2019s an artificial program ilustrating some of them. Copy and run it to see how it looks when it runs (don\u2019t forget to install EasyGUI with pip first). # easygui_eg.py # EasyGUI example for CPSC 129 W13. # # Check to see if a particular student is in the contestant file # for a spelling bee. import easygui # Greet the user. # (Maybe this would be better as a ccbox...) msg = '''This program will let you check that a student has registered for the spelling Bee.''' title = 'Check contestant registration' easygui.msgbox(msg, title) # Get the input data student name from the user. prompt = 'Enter the name of the student you want to check for:' title = 'Student name' fields = ['First name', 'Last name'] (first_name, last_name) = easygui.multenterbox(prompt, title, fields) # Get the filename from the user. msg = \"Select the contestants file to check:\" infile_name = easygui.fileopenbox(msg, title) # easygui.msgbox(infile_name) # Debug # Check the contestant file for the contestant. infile = open(infile_name, 'r') found = False for line in infile: (junk, last, first) = line.split(',') first = first.rstrip() # To remove trailing newline character. if first == first_name and last == last_name: found = True break # Prepare an appropriate output message... if found: msg = f'No worries {first_name:s} {last_name:s} is registered.' else: msg = f'{first_name:s} {last_name:s} hasn\u2019t registered yet.' # ...and output it. easygui.msgbox(msg) [^*]There is one possible hitch that sometimes arises: it can quarrel with IDLE (because both are TK-based tools, both running TK event loops which can conflict), so you may have to use some other text editor for composing your code, and then run it by double-clicking the python file.","title":"EasyGUI"},{"location":"09.2_Data_Processing/06_EasyGUI/#easygui","text":"Earlier I said that a naive user should not be confronted with Python error messages. Similarly they shouldn\u2019t really be confronted by a Python shell to interact with, but should instead get to interact with the sorts of interface elements they are used to, e.g. message boxes, pick lists, file dialogs, etc. If you just need simple dialogues a library called EasyGUI is your friend. It makes it incredibly easy to use GUI components for user interaction instead of the Python console[^*]. EasyGUI is very easy to get started with. Its brief tutorial explains almost all the language features. Here\u2019s an artificial program ilustrating some of them. Copy and run it to see how it looks when it runs (don\u2019t forget to install EasyGUI with pip first). # easygui_eg.py # EasyGUI example for CPSC 129 W13. # # Check to see if a particular student is in the contestant file # for a spelling bee. import easygui # Greet the user. # (Maybe this would be better as a ccbox...) msg = '''This program will let you check that a student has registered for the spelling Bee.''' title = 'Check contestant registration' easygui.msgbox(msg, title) # Get the input data student name from the user. prompt = 'Enter the name of the student you want to check for:' title = 'Student name' fields = ['First name', 'Last name'] (first_name, last_name) = easygui.multenterbox(prompt, title, fields) # Get the filename from the user. msg = \"Select the contestants file to check:\" infile_name = easygui.fileopenbox(msg, title) # easygui.msgbox(infile_name) # Debug # Check the contestant file for the contestant. infile = open(infile_name, 'r') found = False for line in infile: (junk, last, first) = line.split(',') first = first.rstrip() # To remove trailing newline character. if first == first_name and last == last_name: found = True break # Prepare an appropriate output message... if found: msg = f'No worries {first_name:s} {last_name:s} is registered.' else: msg = f'{first_name:s} {last_name:s} hasn\u2019t registered yet.' # ...and output it. easygui.msgbox(msg) [^*]There is one possible hitch that sometimes arises: it can quarrel with IDLE (because both are TK-based tools, both running TK event loops which can conflict), so you may have to use some other text editor for composing your code, and then run it by double-clicking the python file.","title":"EasyGUI"},{"location":"10.1_HTTP_REST/00_index/","text":"HTTP + OOP: Building an Object Server Introduction The problem with CGI How the web works: The World Wide Web The inner nature of HTTP HTTP on the wire\u201d Browsing without a browser CRUD = HTTP? Creating a specialized webserver: A minimal HTTP server in Python Testing object_server.py An ugly truth about browsers Translating MVC + CRUD to HTTP Our HTTP request-response cycles Interaction storyboard Code reuse Mapping to HTTP + URL pairs Actual Code ( Source files: quote_server.py , quote.py ) Towards an Object Server: 1. Identify couplings to quote.py 2. Object creation menu requirements 3. Object creation menu Python code 4. Final steps (A thing we\u2019re not doing.) Summary","title":"Contents"},{"location":"10.1_HTTP_REST/00_index/#http-oop-building-an-object-server","text":"Introduction The problem with CGI How the web works: The World Wide Web The inner nature of HTTP HTTP on the wire\u201d Browsing without a browser CRUD = HTTP? Creating a specialized webserver: A minimal HTTP server in Python Testing object_server.py An ugly truth about browsers Translating MVC + CRUD to HTTP Our HTTP request-response cycles Interaction storyboard Code reuse Mapping to HTTP + URL pairs Actual Code ( Source files: quote_server.py , quote.py ) Towards an Object Server: 1. Identify couplings to quote.py 2. Object creation menu requirements 3. Object creation menu Python code 4. Final steps (A thing we\u2019re not doing.) Summary","title":"HTTP + OOP: Building an Object Server"},{"location":"10.1_HTTP_REST/01_Introduction/","text":"Introduction In this module I will walk you through the development of a web server. Not just a CGI script, but a complete server. It\u2019s a long story, but I hope it will be interesting for you to see what there is to a modern REST architecture web server, and how objects can be made usable across a network. Specifically, to see that there is not that much to it! The final code produced isn\u2019t vast, though it is certainly longer than the recent algorithms we have been working on, but unlike them its logic is straightforward if the requirements it is meeting are understood before reading it. However providing enough background information for you to create that understanding makes it a long story.","title":"Introduction"},{"location":"10.1_HTTP_REST/01_Introduction/#introduction","text":"In this module I will walk you through the development of a web server. Not just a CGI script, but a complete server. It\u2019s a long story, but I hope it will be interesting for you to see what there is to a modern REST architecture web server, and how objects can be made usable across a network. Specifically, to see that there is not that much to it! The final code produced isn\u2019t vast, though it is certainly longer than the recent algorithms we have been working on, but unlike them its logic is straightforward if the requirements it is meeting are understood before reading it. However providing enough background information for you to create that understanding makes it a long story.","title":"Introduction"},{"location":"10.1_HTTP_REST/02_The_problem_with_CGI/","text":"The problem with CGI Why not just keep using CGI? Ease of programming . CGI is best suited to providing an interface to a program, and not so much to a site which might consist of a mix of static and dynamically generated resources. It can be done, but it\u2019s awkward, and you\u2019ll wish you hadn\u2019t. Efficiency . There\u2019s a lot of overhead in running a CGI program. The web server has to load the Python interpreter (which varies in size, but can be several megabytes, call it 4MB), execute the program, gather the results, and transfer them back to the client for every request that comes in. What could be better? There are a lot of schemes that keep the Python (or other scripting language) interpreter running instead of starting and stopping it, e.g. FastCGI and SCGI, and others that embed it into the web server itself, e.g. mod_python, mod_wsgi. But these are, finally, just halfway measures. If the issue is to avoid having two large-footprint pieces of software running why not just write a customized web server in Python so that we have complete control and good performance? Since Python will be running the whole time, the cost of running a script reduces from loading a 4+MB language interpreter to loading a (say) 2KB script. Furthermore, the code will be streamlined compared to a complete server because it will only contain code for things that it will actually do, and not code for anything that anyone, anywhere might conceivably want it to do (as a general purpose web server must provide).","title":"The problem with CGI"},{"location":"10.1_HTTP_REST/02_The_problem_with_CGI/#the-problem-with-cgi","text":"Why not just keep using CGI? Ease of programming . CGI is best suited to providing an interface to a program, and not so much to a site which might consist of a mix of static and dynamically generated resources. It can be done, but it\u2019s awkward, and you\u2019ll wish you hadn\u2019t. Efficiency . There\u2019s a lot of overhead in running a CGI program. The web server has to load the Python interpreter (which varies in size, but can be several megabytes, call it 4MB), execute the program, gather the results, and transfer them back to the client for every request that comes in. What could be better? There are a lot of schemes that keep the Python (or other scripting language) interpreter running instead of starting and stopping it, e.g. FastCGI and SCGI, and others that embed it into the web server itself, e.g. mod_python, mod_wsgi. But these are, finally, just halfway measures. If the issue is to avoid having two large-footprint pieces of software running why not just write a customized web server in Python so that we have complete control and good performance? Since Python will be running the whole time, the cost of running a script reduces from loading a 4+MB language interpreter to loading a (say) 2KB script. Furthermore, the code will be streamlined compared to a complete server because it will only contain code for things that it will actually do, and not code for anything that anyone, anywhere might conceivably want it to do (as a general purpose web server must provide).","title":"The problem with CGI"},{"location":"10.1_HTTP_REST/03_The_world_wide_web/","text":"The World Wide Web If we are going to add a server to the world wide web (hereafter just the \u201cweb\u201d) we will need to know how the web works. The web is a client-server network in which user-agents request resources from servers. You are used to doing this using a user-agent called a browser, to get resources you refer to as web pages. The web is more general than this though. Lots of web traffic, perhaps the majority, is generated by automated programs, e.g. spiders, requesting resources rather than humans using browsers, and the resources they request don\u2019t have to be web pages at all. They may be XML or JSON files or in fact any resource type the client can process. Servers provide resources to clients that request them. A typical webserver runs a tight loop to monitor port 80 (by convention, not necessity) for requests for resources. Upon receiving a request, it looks for the resource and sends it out to the client. The resource may be static, typically a file, or dynamic, typically the output of a program. Clients and servers communicate according to HTTP: the HyperText Transport Protocol. A resource is any chunk of information that can be identified by a URL ( r esource is the R in URL). The client and server sort out the details of their interaction using headers that specify the formats in which the resource is available (from the server\u2019s perspective) and acceptable (from the client\u2019s perspective), the encodings they will use, authorization to access the resource, and much more.","title":"The World Wide Web"},{"location":"10.1_HTTP_REST/03_The_world_wide_web/#the-world-wide-web","text":"If we are going to add a server to the world wide web (hereafter just the \u201cweb\u201d) we will need to know how the web works. The web is a client-server network in which user-agents request resources from servers. You are used to doing this using a user-agent called a browser, to get resources you refer to as web pages. The web is more general than this though. Lots of web traffic, perhaps the majority, is generated by automated programs, e.g. spiders, requesting resources rather than humans using browsers, and the resources they request don\u2019t have to be web pages at all. They may be XML or JSON files or in fact any resource type the client can process. Servers provide resources to clients that request them. A typical webserver runs a tight loop to monitor port 80 (by convention, not necessity) for requests for resources. Upon receiving a request, it looks for the resource and sends it out to the client. The resource may be static, typically a file, or dynamic, typically the output of a program. Clients and servers communicate according to HTTP: the HyperText Transport Protocol. A resource is any chunk of information that can be identified by a URL ( r esource is the R in URL). The client and server sort out the details of their interaction using headers that specify the formats in which the resource is available (from the server\u2019s perspective) and acceptable (from the client\u2019s perspective), the encodings they will use, authorization to access the resource, and much more.","title":"The World Wide Web"},{"location":"10.1_HTTP_REST/04_The_inner_nature_of_HTTP/","text":"The inner nature of HTTP We are most used to console-like interactions where a user has an extended conversation with a program. HTTP is different from this in some important ways. The differences were designed into HTTP to make it scalable. They are key to the fact that it became the world-wide web instead of the me-and-my-buddy-here\u2019s very local web (if you are old enough you might know those as BBS systems). The first is that HTTP is connectionless , unlike a console interaction which is one long continuous connection of user to program. After the client (browser) makes a request it disconnects from the server and waits for the server\u2019s response. If the connection has been broken how can the server send the information back? Because the client gave it it\u2019s return address. In this way the difference between connection and connectionless is a bit like the difference between a phone call and using old-fashioned postal mail. In a phone call you establish a connection and wait on the line (holding the line open) while the person on the other end finds the answer to your question. Using postal mail you mail a letter with your return address on it, and then do other things while you wait for the response to come back by return mail. A console interaction is like a phone conversation; HTTP is like postal mail. Why do this? Because for a server to keep thousands of connections open while it processes requests would waste bandwidth. HTTP is also stateless . The server has no memory. Using the mail metaphor it doesn\u2019t file any old correspondence. It processes the request, and on completion throws its details away. Why do this? Because it would take both storage and time (our two computaitinal resources, remember?) for the server to retrieve old correspondence each time it has to handle a request. Instead the client is supposed to include all necessary information in each request. This way the server can handle it, and then forget all about it. The final characteristic is that HTTP is media independent . Most people think of it as providing HTML pages and some rich media to place on those pages, but in fact HTML can serve any type of content. The server and client discuss what format would be best and the server provides the content in that form. The discussion is simple. The client sends a list of types it can handle in order of preference. The server consults a list of formats in which it can provide the resource and picks the one most favoured by the client. The MIME specification describes how this content negotiation takes place. Many media types are registered. These qualities enable HTTP to support several interrelated technologies that lead to the web\u2019s remarkable scalability (and it truly is a modern engineering triumph): Caching. The web is heavily cached. Ideally most requests never have to reach the server to be served, but instead can be handled by a cache somewhere along the way, perhaps in the client machine itself, or in a caching proxy along the way, or a cache on the server (so it doesn\u2019t have to recompute an expensive resource). Last-modified checking. The system doesn\u2019t know if it can trust a value from a cache unless it knows it hasn\u2019t been modified since going into the cache. Last-modified checking enables this. ETag checking. ETags are hashes (UIDs!) sent by the server that enable a client to determine if its copy of a resource is still up to date.","title":"The inner nature of HTTP"},{"location":"10.1_HTTP_REST/04_The_inner_nature_of_HTTP/#the-inner-nature-of-http","text":"We are most used to console-like interactions where a user has an extended conversation with a program. HTTP is different from this in some important ways. The differences were designed into HTTP to make it scalable. They are key to the fact that it became the world-wide web instead of the me-and-my-buddy-here\u2019s very local web (if you are old enough you might know those as BBS systems). The first is that HTTP is connectionless , unlike a console interaction which is one long continuous connection of user to program. After the client (browser) makes a request it disconnects from the server and waits for the server\u2019s response. If the connection has been broken how can the server send the information back? Because the client gave it it\u2019s return address. In this way the difference between connection and connectionless is a bit like the difference between a phone call and using old-fashioned postal mail. In a phone call you establish a connection and wait on the line (holding the line open) while the person on the other end finds the answer to your question. Using postal mail you mail a letter with your return address on it, and then do other things while you wait for the response to come back by return mail. A console interaction is like a phone conversation; HTTP is like postal mail. Why do this? Because for a server to keep thousands of connections open while it processes requests would waste bandwidth. HTTP is also stateless . The server has no memory. Using the mail metaphor it doesn\u2019t file any old correspondence. It processes the request, and on completion throws its details away. Why do this? Because it would take both storage and time (our two computaitinal resources, remember?) for the server to retrieve old correspondence each time it has to handle a request. Instead the client is supposed to include all necessary information in each request. This way the server can handle it, and then forget all about it. The final characteristic is that HTTP is media independent . Most people think of it as providing HTML pages and some rich media to place on those pages, but in fact HTML can serve any type of content. The server and client discuss what format would be best and the server provides the content in that form. The discussion is simple. The client sends a list of types it can handle in order of preference. The server consults a list of formats in which it can provide the resource and picks the one most favoured by the client. The MIME specification describes how this content negotiation takes place. Many media types are registered. These qualities enable HTTP to support several interrelated technologies that lead to the web\u2019s remarkable scalability (and it truly is a modern engineering triumph): Caching. The web is heavily cached. Ideally most requests never have to reach the server to be served, but instead can be handled by a cache somewhere along the way, perhaps in the client machine itself, or in a caching proxy along the way, or a cache on the server (so it doesn\u2019t have to recompute an expensive resource). Last-modified checking. The system doesn\u2019t know if it can trust a value from a cache unless it knows it hasn\u2019t been modified since going into the cache. Last-modified checking enables this. ETag checking. ETags are hashes (UIDs!) sent by the server that enable a client to determine if its copy of a resource is still up to date.","title":"The inner nature of HTTP"},{"location":"10.1_HTTP_REST/05_HTTP_on_the_wire/","text":"HTTP on the wire\u201d The HTTP protocol is a very simple one, a key to its widespread implementation and thus its eventual success. A request consists of a sequence of lines of text. The first one specifies the HTTP method (verb), the resource (by its URL, or, rarely, its URI) being requested and the HTTP protocol version, e.g. GET /index.html HTTP/1.0 There are four key HTTP methods ^* ^** , ( all of them ) GET \u201cThe GET method means retrieve whatever information ... is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response...\u201d PUT \u201cThe PUT method requests that the enclosed entity be stored under the supplied Request-URI.\u201d POST \u201cThe POST method is used to ... [provide] a block of data, such as the result of submitting a form, to a data-handling process; extend a database though an append operation.\u201d DELETE \u201cThe DELETE method requests that the origin server delete the resource identified by the Request-URI.\u201d The remaining lines, if any, are optional header lines that modify the processing of the request. The end of the header lines is signalled by a blank line. The format of each header line is a key or name followed by a colon, followed by a string value. Here is a sample set of headers ( all headers ) for a request for a page to give you an idea of the type of information that is sent. I have bolded the header names to make them stand out, but in the actual request it\u2019s all plain text. Host: www.w3.org User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5 Accept-Language: en-gb,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Connection: keep-alive Referer: http://www.google.ca/[long URL trimmed] The server puts together a similar package when it returns its response: a status line ( status codes ), then a set of header lines, followed by a blank line, followed by the content of the response. Here are the headers returned by the request above: Date: Wed, 06 Feb 2008 21:17:26 GMT Server: Apache/2 Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT Etag: \"40d7-3e3073913b100\" Accept-Ranges: bytes Content-Length: 16599 Cache-Control: max-age=21600 Expires: Thu, 07 Feb 2008 03:17:26 GMT P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\" Content-Type: text/html; charset=iso-8859-1 X-Cache: MISS from squid.yukoncollege.local X-Cache-Lookup: MISS from squid.yukoncollege.local:3128 Via: 1.0 squid.yukoncollege.local:3128 (squid/2.6.STABLE14) Connection: keep-alive For a very clear explanation of what happens between a client and server see: What really happens when you navigate to a URL","title":"HTTP on the wire\u201d"},{"location":"10.1_HTTP_REST/05_HTTP_on_the_wire/#http-on-the-wire","text":"The HTTP protocol is a very simple one, a key to its widespread implementation and thus its eventual success. A request consists of a sequence of lines of text. The first one specifies the HTTP method (verb), the resource (by its URL, or, rarely, its URI) being requested and the HTTP protocol version, e.g. GET /index.html HTTP/1.0 There are four key HTTP methods ^* ^** , ( all of them ) GET \u201cThe GET method means retrieve whatever information ... is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response...\u201d PUT \u201cThe PUT method requests that the enclosed entity be stored under the supplied Request-URI.\u201d POST \u201cThe POST method is used to ... [provide] a block of data, such as the result of submitting a form, to a data-handling process; extend a database though an append operation.\u201d DELETE \u201cThe DELETE method requests that the origin server delete the resource identified by the Request-URI.\u201d The remaining lines, if any, are optional header lines that modify the processing of the request. The end of the header lines is signalled by a blank line. The format of each header line is a key or name followed by a colon, followed by a string value. Here is a sample set of headers ( all headers ) for a request for a page to give you an idea of the type of information that is sent. I have bolded the header names to make them stand out, but in the actual request it\u2019s all plain text. Host: www.w3.org User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11 Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5 Accept-Language: en-gb,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Connection: keep-alive Referer: http://www.google.ca/[long URL trimmed] The server puts together a similar package when it returns its response: a status line ( status codes ), then a set of header lines, followed by a blank line, followed by the content of the response. Here are the headers returned by the request above: Date: Wed, 06 Feb 2008 21:17:26 GMT Server: Apache/2 Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT Etag: \"40d7-3e3073913b100\" Accept-Ranges: bytes Content-Length: 16599 Cache-Control: max-age=21600 Expires: Thu, 07 Feb 2008 03:17:26 GMT P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\" Content-Type: text/html; charset=iso-8859-1 X-Cache: MISS from squid.yukoncollege.local X-Cache-Lookup: MISS from squid.yukoncollege.local:3128 Via: 1.0 squid.yukoncollege.local:3128 (squid/2.6.STABLE14) Connection: keep-alive For a very clear explanation of what happens between a client and server see: What really happens when you navigate to a URL","title":"HTTP on the wire\u201d"},{"location":"10.1_HTTP_REST/06_Browsing_without_a_browser/","text":"Browsing without a browser The graphic displays provided by modern browsers can obscure the fact that behind the scenes it\u2019s all text. In case seeing helps you with believing you can still issue the requests by typing them and see the text responses. The trick is to talk to the server (webserver in our case, but this also works for others like email, ssh, ftp, time, etc.) directly (i.e. without invoking a client like a web browser or an email program) using a terminal program. All you need is to know the protocol. If you want to follow along you can use the free program PuTTYtel . Configure it as follows to access web servers, noting that connection type needs to be \u201craw\u201d not \u201ctelnet\u201d: Then you can fetch the server\u2019s index (or home) page by typing a GET request: [GET / HTTP/1.0]{.kbd} followed by two Enter\u2019s: the first to send the GET request, and the second to send a blank line signalling the end of the headers (even though there aren\u2019t any). The slash (/) indicates that you are asking for the root document on the server. Many servers will map this request to a file called index.html (and soon we will see how they do this!). This is all a browser does when you click a link: it issues a GET request for the resource identified by the link URL.","title":"Browsing without a browser"},{"location":"10.1_HTTP_REST/06_Browsing_without_a_browser/#browsing-without-a-browser","text":"The graphic displays provided by modern browsers can obscure the fact that behind the scenes it\u2019s all text. In case seeing helps you with believing you can still issue the requests by typing them and see the text responses. The trick is to talk to the server (webserver in our case, but this also works for others like email, ssh, ftp, time, etc.) directly (i.e. without invoking a client like a web browser or an email program) using a terminal program. All you need is to know the protocol. If you want to follow along you can use the free program PuTTYtel . Configure it as follows to access web servers, noting that connection type needs to be \u201craw\u201d not \u201ctelnet\u201d: Then you can fetch the server\u2019s index (or home) page by typing a GET request: [GET / HTTP/1.0]{.kbd} followed by two Enter\u2019s: the first to send the GET request, and the second to send a blank line signalling the end of the headers (even though there aren\u2019t any). The slash (/) indicates that you are asking for the root document on the server. Many servers will map this request to a file called index.html (and soon we will see how they do this!). This is all a browser does when you click a link: it issues a GET request for the resource identified by the link URL.","title":"Browsing without a browser"},{"location":"10.1_HTTP_REST/07_CRUD_vs_HTTP/","text":"CRUD vs HTTP We\u2019ve seen what the GET method does, but what about those other methods: POST, PUT and DELETE? Their existence points out that web servers can and do more than serve web pages. They can allow us to upload, edit and delete resources as well. Consider again the guidelines for using those methods: GET \u201cThe GET method means retrieve whatever information ... is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response...\u201d PUT \u201cThe PUT method requests that the enclosed entity be stored under the supplied Request-URI.\u201d POST \u201cThe POST method is used to ... [provide] a block of data, such as the result of submitting a form, to a data-handling process; extend a database though an append operation.\u201d DELETE \u201cThe DELETE method requests that the origin server delete the resource identified by the Request-URI.\u201d You\u2019ll notice that although the names differ these four operations map neatly onto the CRUD model of operations. CRUD HTTP Create POST Retrieve GET Update PUT Delete DELETE This is no accident; the engineers who designed HTTP knew what they were doing. Modern best practice in web development is to build servers that implement REST architecture. This stands for Representational State Transfer and is a topic unto itself, but you won\u2019t go far wrong if you think of it as treating HTTP as CRUD using other names, and that\u2019s what we will do.","title":"CRUD vs HTTP"},{"location":"10.1_HTTP_REST/07_CRUD_vs_HTTP/#crud-vs-http","text":"We\u2019ve seen what the GET method does, but what about those other methods: POST, PUT and DELETE? Their existence points out that web servers can and do more than serve web pages. They can allow us to upload, edit and delete resources as well. Consider again the guidelines for using those methods: GET \u201cThe GET method means retrieve whatever information ... is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response...\u201d PUT \u201cThe PUT method requests that the enclosed entity be stored under the supplied Request-URI.\u201d POST \u201cThe POST method is used to ... [provide] a block of data, such as the result of submitting a form, to a data-handling process; extend a database though an append operation.\u201d DELETE \u201cThe DELETE method requests that the origin server delete the resource identified by the Request-URI.\u201d You\u2019ll notice that although the names differ these four operations map neatly onto the CRUD model of operations. CRUD HTTP Create POST Retrieve GET Update PUT Delete DELETE This is no accident; the engineers who designed HTTP knew what they were doing. Modern best practice in web development is to build servers that implement REST architecture. This stands for Representational State Transfer and is a topic unto itself, but you won\u2019t go far wrong if you think of it as treating HTTP as CRUD using other names, and that\u2019s what we will do.","title":"CRUD vs HTTP"},{"location":"10.1_HTTP_REST/08_A_minimal_HTTP_server_in_python/","text":"A minimal HTTP server in Python Now how do we write a server in Python that can recognize and respond to these methods? Here\u2019s the code for a minimal server. It doesn\u2019t actually serve anything, but it does respond to all four request types (GET, PUT, POST and DELETE) and displays the type of the request it has received. # object_server.py # # HTTP server that provides CRUD operations for Python objects. # # Version 1 # # - Tidied up a bit. # # Version 0 (archived as object_server_0.py) # # - Initial roughing out to demonstrate HTTP concepts in practice. HTML5_template = '''<!DOCTYPE HTML> <!-- Minimal valid HTML5 document. Illustrates the necessary DOCTYPE declaration to be recognized as HTML5. --> <html> <head> <title>%s</title> </head> <body> %s </body> </html> ''' test_form = '''<!DOCTYPE HTML> <html> <head> <title>Test form</title> </head> <body> <form name=\"GET test\" action=\"\" method=\"GET\"> <fieldset><legend>GET</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> <input type=\"submit\" name=\"action\" value=\"GET\" /> </fieldset> </form> <form name=\"POST test\" action=\"\" method=\"POST\"> <fieldset><legend>POST</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> First name: <input type=\"text\" name=\"fname\" value=\"Mickey\" /><br /> Last name:<input type=\"text\" name=\"lname\" value=\"Mouse\" /><br /> <input type=\"submit\" value=\"POST\" /> </fieldset> </form> <form name=\"PUT test\" action=\"\" method=\"PUT\"> <fieldset><legend>PUT</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> First name: <input type=\"text\" name=\"fname\" value=\"Mickey\" /><br /> Last name:<input type=\"text\" name=\"lname\" value=\"Mouse\" /><br /> <input type=\"submit\" value=\"PUT\" /> </fieldset> </form> <form name=\"DELETE test\" action=\"\" method=\"DELETE\"> <fieldset><legend>DELETE</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> <input type=\"submit\" value=\"DELETE\" /> </fieldset> </form> </body> </html> ''' # This will not be a CGI app, but we will use the CGI module's # facilities for parsing incoming form data. import cgi # We will modify http.server to create our server. import http.server class HTTPHandler(http.server.BaseHTTPRequestHandler): # BaseHTTPRequestHandler will call do_XXX when receiving # a request specifying method XXX. # # The do_XXX methods do not take any arguments because # self contains all the request information in its instance attributes. def do_GET(self): title = 'GET response' if self.path != '/': body = '<h1>Got a GET request.</h1><p>' + self.path + '</p>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) else: self.wfile.write( test_form.encode('utf-8') ) def do_POST(self): title = 'POST response' body = '<h1>Got a POST request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) def do_PUT(self): title = 'PUT response' body = '<h1>Got a PUT request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) def do_DELETE(self): title = 'DELETE response' body = '<h1>Got a DELETE request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) if __name__ == '__main__': server_address= ('', 80) httpd = http.server.HTTPServer(server_address, HTTPHandler) httpd.serve_forever()","title":"A minimal HTTP server in Python"},{"location":"10.1_HTTP_REST/08_A_minimal_HTTP_server_in_python/#a-minimal-http-server-in-python","text":"Now how do we write a server in Python that can recognize and respond to these methods? Here\u2019s the code for a minimal server. It doesn\u2019t actually serve anything, but it does respond to all four request types (GET, PUT, POST and DELETE) and displays the type of the request it has received. # object_server.py # # HTTP server that provides CRUD operations for Python objects. # # Version 1 # # - Tidied up a bit. # # Version 0 (archived as object_server_0.py) # # - Initial roughing out to demonstrate HTTP concepts in practice. HTML5_template = '''<!DOCTYPE HTML> <!-- Minimal valid HTML5 document. Illustrates the necessary DOCTYPE declaration to be recognized as HTML5. --> <html> <head> <title>%s</title> </head> <body> %s </body> </html> ''' test_form = '''<!DOCTYPE HTML> <html> <head> <title>Test form</title> </head> <body> <form name=\"GET test\" action=\"\" method=\"GET\"> <fieldset><legend>GET</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> <input type=\"submit\" name=\"action\" value=\"GET\" /> </fieldset> </form> <form name=\"POST test\" action=\"\" method=\"POST\"> <fieldset><legend>POST</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> First name: <input type=\"text\" name=\"fname\" value=\"Mickey\" /><br /> Last name:<input type=\"text\" name=\"lname\" value=\"Mouse\" /><br /> <input type=\"submit\" value=\"POST\" /> </fieldset> </form> <form name=\"PUT test\" action=\"\" method=\"PUT\"> <fieldset><legend>PUT</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> First name: <input type=\"text\" name=\"fname\" value=\"Mickey\" /><br /> Last name:<input type=\"text\" name=\"lname\" value=\"Mouse\" /><br /> <input type=\"submit\" value=\"PUT\" /> </fieldset> </form> <form name=\"DELETE test\" action=\"\" method=\"DELETE\"> <fieldset><legend>DELETE</legend> UID: <input type=\"text\" name=\"fname\" value=\"123\" /><br /> <input type=\"submit\" value=\"DELETE\" /> </fieldset> </form> </body> </html> ''' # This will not be a CGI app, but we will use the CGI module's # facilities for parsing incoming form data. import cgi # We will modify http.server to create our server. import http.server class HTTPHandler(http.server.BaseHTTPRequestHandler): # BaseHTTPRequestHandler will call do_XXX when receiving # a request specifying method XXX. # # The do_XXX methods do not take any arguments because # self contains all the request information in its instance attributes. def do_GET(self): title = 'GET response' if self.path != '/': body = '<h1>Got a GET request.</h1><p>' + self.path + '</p>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) else: self.wfile.write( test_form.encode('utf-8') ) def do_POST(self): title = 'POST response' body = '<h1>Got a POST request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) def do_PUT(self): title = 'PUT response' body = '<h1>Got a PUT request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) def do_DELETE(self): title = 'DELETE response' body = '<h1>Got a DELETE request.</h1>' self.wfile.write((HTML5_template % (title, body)).encode('utf-8')) if __name__ == '__main__': server_address= ('', 80) httpd = http.server.HTTPServer(server_address, HTTPHandler) httpd.serve_forever()","title":"A minimal HTTP server in Python"},{"location":"10.1_HTTP_REST/09_Demo_Testing_object_server/","text":"Demo: Testing object_server.py We can test our object_server.py using an internet browser. If you enter http://localhost in the address bar it will display our page.","title":"Demo: Testing object_server.py"},{"location":"10.1_HTTP_REST/09_Demo_Testing_object_server/#demo-testing-object_serverpy","text":"We can test our object_server.py using an internet browser. If you enter http://localhost in the address bar it will display our page.","title":"Demo: Testing object_server.py"},{"location":"10.1_HTTP_REST/10_The_ugly_truth_about_browsers/","text":"The ugly truth about browsers Sadly (no, more than that, frustratingly, maddeningly, infuriatingly) we cannot use a browser to test object_server.py because current browsers only support the GET and POST methods. Change is coming, e.g. HTML5 forms will support all four methods, but at the moment everyone is forced to work around this painful browser limitation. There are several common work arounds: We could write our own client instead of using a browser. But this means more code to write, and then we\u2019d have to distribute our client to our users, and people don\u2019t want another client, they have browsers and want to keep using them. Note however that this is a common solution in vertical applications, e.g. library access to commercial databases, and in commercial applications generally where we can provide a custom client to our customers, e.g. iTunes. Modify our client to use Ajax to issue the calls. The browsers don\u2019t directly support PUT and DELETE, but they do all now support the XMLHttpRequest object . This enables programmers to use Javascript to issue PUT and DELETE requests and is my preferred solution in my own apps. I originally began these notes using this approach, but there was too much to explain about Javascript, and JSON or XML, and on and on. Modify our server so we can tunnel through POST for UPDATE and DELETE. This is probably the most common strategy and suits us since we don\u2019t have to add another language (Javascript), but unfortunately we do have to ugly up our HTML a bit.","title":"The ugly truth about browsers"},{"location":"10.1_HTTP_REST/10_The_ugly_truth_about_browsers/#the-ugly-truth-about-browsers","text":"Sadly (no, more than that, frustratingly, maddeningly, infuriatingly) we cannot use a browser to test object_server.py because current browsers only support the GET and POST methods. Change is coming, e.g. HTML5 forms will support all four methods, but at the moment everyone is forced to work around this painful browser limitation. There are several common work arounds: We could write our own client instead of using a browser. But this means more code to write, and then we\u2019d have to distribute our client to our users, and people don\u2019t want another client, they have browsers and want to keep using them. Note however that this is a common solution in vertical applications, e.g. library access to commercial databases, and in commercial applications generally where we can provide a custom client to our customers, e.g. iTunes. Modify our client to use Ajax to issue the calls. The browsers don\u2019t directly support PUT and DELETE, but they do all now support the XMLHttpRequest object . This enables programmers to use Javascript to issue PUT and DELETE requests and is my preferred solution in my own apps. I originally began these notes using this approach, but there was too much to explain about Javascript, and JSON or XML, and on and on. Modify our server so we can tunnel through POST for UPDATE and DELETE. This is probably the most common strategy and suits us since we don\u2019t have to add another language (Javascript), but unfortunately we do have to ugly up our HTML a bit.","title":"The ugly truth about browsers"},{"location":"10.1_HTTP_REST/11_Translating_MVC_CRUD_to_HTTP/","text":"Translating MVC+CRUD to HTTP Our MVC_controller.py supported the following actions: Actions ------- c - create an object to add to the collection r - retrieve an object from the collection and display it u - update an object in the collection d - delete an object from the collection l - list all the objects in the collection q - exit We want to support the same functionality using HTTP, with a browser as the client, and our same shelve as the back-end datastore. Now how exactly can we map these CRUD actions onto the HTTP methods? There are two issues we have to resolve. Remember that the form of an HTTP request is METHOD URL VERSION so we need to identify the URLs for each method, i.e. we have to say GET from somewhere , POST to somewhere etc. Some of these are easier to figure out than others: GET and DELETE will obviously be GET uid to retrieve the html representation of object uid, and DELETE uid to delete the object with UID uid. UPDATE is not so clear. Clearly we will want to issue UPDATE uid to update the object with UID uid, but we will have to send it the information to use in creating the updated object which presumes an earlier interaction. Remember that in our console-based controller we first got the modified values by interacting with the user and then called the update method in model.py. In an HTTP system the initial interaction will be achieved by presenting the user with an HTML form to fill in and then submitting this form to trigger the UPDATE. This highlights the second issue: Some of those actions invoked an interaction between the user and the controller, but HTTP is stateless, that is each request is handled alone without knowledge of previous requests. (Now lots of approaches to web apps try to get around this by managing sessions, but that adds complexity, fragility and makes many desirable performance features of the web unavailable, e.g. caching. ) So we will need to call one form to fill in the modified values and then PUT that form to trigger the actual update. Similarly using POST to create a new object will involve two steps, first requesting a form to use to specify the characteristics of the new object and second a POST request to actually trigger its creation. Now where do we post to to create a new object? To a special object creation URL. Finally there is listall to consider. We will do that by GETting the server root.","title":"Translating MVC+CRUD to HTTP"},{"location":"10.1_HTTP_REST/11_Translating_MVC_CRUD_to_HTTP/#translating-mvccrud-to-http","text":"Our MVC_controller.py supported the following actions: Actions ------- c - create an object to add to the collection r - retrieve an object from the collection and display it u - update an object in the collection d - delete an object from the collection l - list all the objects in the collection q - exit We want to support the same functionality using HTTP, with a browser as the client, and our same shelve as the back-end datastore. Now how exactly can we map these CRUD actions onto the HTTP methods? There are two issues we have to resolve. Remember that the form of an HTTP request is METHOD URL VERSION so we need to identify the URLs for each method, i.e. we have to say GET from somewhere , POST to somewhere etc. Some of these are easier to figure out than others: GET and DELETE will obviously be GET uid to retrieve the html representation of object uid, and DELETE uid to delete the object with UID uid. UPDATE is not so clear. Clearly we will want to issue UPDATE uid to update the object with UID uid, but we will have to send it the information to use in creating the updated object which presumes an earlier interaction. Remember that in our console-based controller we first got the modified values by interacting with the user and then called the update method in model.py. In an HTTP system the initial interaction will be achieved by presenting the user with an HTML form to fill in and then submitting this form to trigger the UPDATE. This highlights the second issue: Some of those actions invoked an interaction between the user and the controller, but HTTP is stateless, that is each request is handled alone without knowledge of previous requests. (Now lots of approaches to web apps try to get around this by managing sessions, but that adds complexity, fragility and makes many desirable performance features of the web unavailable, e.g. caching. ) So we will need to call one form to fill in the modified values and then PUT that form to trigger the actual update. Similarly using POST to create a new object will involve two steps, first requesting a form to use to specify the characteristics of the new object and second a POST request to actually trigger its creation. Now where do we post to to create a new object? To a special object creation URL. Finally there is listall to consider. We will do that by GETting the server root.","title":"Translating MVC+CRUD to HTTP"},{"location":"10.1_HTTP_REST/12_Our_HTTP_request_response_cycles/","text":"Our HTTP Request-Response Cycles So the flow of requests and responses looks like this. When the client indicates they want to, List all objects Request: GET http://localhost/ Response: HTML list of HTML representations of all objects in datastore. Retrieve an object, i.e. the HTML representation of an object Request: GET http://localhost/ uid Response: HTML representation of the object, i.e. a web page. Create a new object Request: GET http://localhost/ object_creation_form Response: HTML form to fill in with object details. Request: POST http://localhost/object_creation_url Response: HTML representation of newly created object. Delete an object Request: DELETE http://localhost/ uid Response: Homepage of site (Seems reasonable, but not the only possibility --- we could give them a successful deletion message --- but this seems reasonable because we need to send them somewhere, and since the \u201ccurrent object\u201d just got deleted we can\u2019t send them to view it.) Update an object Request: GET http://localhost/ uid/update_form Response: HTML form filled with object details ready to be modified. Request: PUT http://localhost/ uid Response: HTML representation of updated object.","title":"Our HTTP Request-Response Cycles"},{"location":"10.1_HTTP_REST/12_Our_HTTP_request_response_cycles/#our-http-request-response-cycles","text":"So the flow of requests and responses looks like this. When the client indicates they want to, List all objects Request: GET http://localhost/ Response: HTML list of HTML representations of all objects in datastore. Retrieve an object, i.e. the HTML representation of an object Request: GET http://localhost/ uid Response: HTML representation of the object, i.e. a web page. Create a new object Request: GET http://localhost/ object_creation_form Response: HTML form to fill in with object details. Request: POST http://localhost/object_creation_url Response: HTML representation of newly created object. Delete an object Request: DELETE http://localhost/ uid Response: Homepage of site (Seems reasonable, but not the only possibility --- we could give them a successful deletion message --- but this seems reasonable because we need to send them somewhere, and since the \u201ccurrent object\u201d just got deleted we can\u2019t send them to view it.) Update an object Request: GET http://localhost/ uid/update_form Response: HTML form filled with object details ready to be modified. Request: PUT http://localhost/ uid Response: HTML representation of updated object.","title":"Our HTTP Request-Response Cycles"},{"location":"10.1_HTTP_REST/13_Interaction_storyboard/","text":"Interaction Storyboard Depending on how visual you are you might prefer to see this in storyboard form. The arrows below show the possible paths from one display to another in response to HTML button clicks.","title":"Interaction Storyboard"},{"location":"10.1_HTTP_REST/13_Interaction_storyboard/#interaction-storyboard","text":"Depending on how visual you are you might prefer to see this in storyboard form. The arrows below show the possible paths from one display to another in response to HTML button clicks.","title":"Interaction Storyboard"},{"location":"10.1_HTTP_REST/14_Code_reuse/","text":"Code reuse OK now what do we have to work with to make this happen? Our earlier MVC controller obviously. What parts of it can we, reuse without modification? modify for reuse? replace with new code? Recall that our earlier application consisted of: MVC_model.py MVC_controller.py quote.py We had better be able to reuse the model (MVC_model.py) as-is, or it will be evidence that we missed the boat on the separation of responsibilities between M, V and C. Equally straightforward, the controller has to be reimplemented although much of its internal logic will survive intact since the logic of the operations is unchanged. For example updating required us to get the updated values, create a new object, save it, and delete the old object. The steps remain the same, but since our application now interacts with the user through a browser communicating across an HTTP connection, it\u2019s no surprise that little of our console-based code can be reused. Not as obvious is what to do about quote.py . Much of it remains relevant since we are still dealing with the same types of objects. On the other hand we we will now need HTML representations of the objects, and our current quote.py doesn\u2019t provide that. So our scorecard looks like this: MVC_model.py \u2192 Reuse without modification (we hope). MVC_controller.py \u2192 Replace with new HTTP server. quote.py \u2192 Modify by adding methods.","title":"Code reuse"},{"location":"10.1_HTTP_REST/14_Code_reuse/#code-reuse","text":"OK now what do we have to work with to make this happen? Our earlier MVC controller obviously. What parts of it can we, reuse without modification? modify for reuse? replace with new code? Recall that our earlier application consisted of: MVC_model.py MVC_controller.py quote.py We had better be able to reuse the model (MVC_model.py) as-is, or it will be evidence that we missed the boat on the separation of responsibilities between M, V and C. Equally straightforward, the controller has to be reimplemented although much of its internal logic will survive intact since the logic of the operations is unchanged. For example updating required us to get the updated values, create a new object, save it, and delete the old object. The steps remain the same, but since our application now interacts with the user through a browser communicating across an HTTP connection, it\u2019s no surprise that little of our console-based code can be reused. Not as obvious is what to do about quote.py . Much of it remains relevant since we are still dealing with the same types of objects. On the other hand we we will now need HTML representations of the objects, and our current quote.py doesn\u2019t provide that. So our scorecard looks like this: MVC_model.py \u2192 Reuse without modification (we hope). MVC_controller.py \u2192 Replace with new HTTP server. quote.py \u2192 Modify by adding methods.","title":"Code reuse"},{"location":"10.1_HTTP_REST/15_Mapping_actions_to_HTTP_method_URL_pairs/","text":"Mapping Actions to HTTP Method + URL pairs Looking carefully back at the request-response cycles we can see that deciding what to return to the client depends on both the HTTP method and the URL specified. Action HTTP Method URL Python Methods and Actions List all objects GET / model.listall() + display entries as HTML Retrieve an object GET /uid obj = model.retrieve(uid) + display as HTML, i.e. obj.HTML() Create a new object GET /object_creation_form new: but just return a static HTML page containing the form POST /create/objtype obj = Quote() + model.create(obj) + display new object as HTML, i.e. obj.HTML() Delete an object DELETE /uid model.delete(uid) + model.listall() + display entries as HTML Update an object GET /uid/HTML_update_form new: return uid's update_form(), i.e. obj = model.retrieve(uid) + return obj.HTML_update_form() PUT /uid new_uid = model.update(uid, obj) followed by obj = model.retrieve(new_uid) + display as HTML, i.e. obj.HTML() There are only three new methods in the rightmost column of this table: obj.HTML() The Quote class will have to add an HTML method that returns an HTML representation of an object (similar to the way __str__ returns a plain text representation). something that returns an object creation form, i.e. Quote.``object_creation_form() obj.HTML_update_form() which has to return an HTML form for an object that is suitable to use in updating it. This should be identical to the object creation form except with values filled in.","title":"Mapping Actions to HTTP Method + URL pairs"},{"location":"10.1_HTTP_REST/15_Mapping_actions_to_HTTP_method_URL_pairs/#mapping-actions-to-http-method-url-pairs","text":"Looking carefully back at the request-response cycles we can see that deciding what to return to the client depends on both the HTTP method and the URL specified. Action HTTP Method URL Python Methods and Actions List all objects GET / model.listall() + display entries as HTML Retrieve an object GET /uid obj = model.retrieve(uid) + display as HTML, i.e. obj.HTML() Create a new object GET /object_creation_form new: but just return a static HTML page containing the form POST /create/objtype obj = Quote() + model.create(obj) + display new object as HTML, i.e. obj.HTML() Delete an object DELETE /uid model.delete(uid) + model.listall() + display entries as HTML Update an object GET /uid/HTML_update_form new: return uid's update_form(), i.e. obj = model.retrieve(uid) + return obj.HTML_update_form() PUT /uid new_uid = model.update(uid, obj) followed by obj = model.retrieve(new_uid) + display as HTML, i.e. obj.HTML() There are only three new methods in the rightmost column of this table: obj.HTML() The Quote class will have to add an HTML method that returns an HTML representation of an object (similar to the way __str__ returns a plain text representation). something that returns an object creation form, i.e. Quote.``object_creation_form() obj.HTML_update_form() which has to return an HTML form for an object that is suitable to use in updating it. This should be identical to the object creation form except with values filled in.","title":"Mapping Actions to HTTP Method + URL pairs"},{"location":"10.1_HTTP_REST/16_Actual_code/","text":"Actual code The code logic flows quite cleanly from the HTTP Method column. We can see that ideally we only have any logic with GET requests (since four actions use GET requests), but that with POST, PUT and DELETE we always follow a single course of action. I say ideally because the ugly truth about browsers means that POST will actually correspond to three possibilities: a true POST, a tunneled UPDATE, or a tunneled DELETE. This is handled by including a hidden field in the input forms giving the actual intended method. This requires modifications to the forms which are provided by quote.py (see below). # quote_server.py # # HTTP server that provides CRUD operations for Quote objects. # # Version 5 # # - Tidied up substantially. # # Version 4 # # - Implemented PUT and DELETE by tunneling them through POST. # # Version 3 # # - Implement all GETs and POSTs pending decision on how to proceed # with PUTs and DELETEs. # # Version 1 # # - Tidied up a bit. # # Version 0 (archived as object_server_0.py) # # - Initial roughing out to demonstrate HTTP concepts in practice. # - Tries to send genuine PUT and DELETE. import quote import model # Was named MVC_model HTML5_template = open('HTML5_template.html','r').read() # We will modify http.server to create our server. import http.server # Needed to parse the arguments import urllib.parse class myHTTPHandler(http.server.BaseHTTPRequestHandler): # BaseHTTPRequestHandler will call do_XXX when receiving # a request specifying method XXX. # # The do_XXX methods do not take any arguments because # self contains all the request information in its instance attributes. def do_GET(self): print('GET for', self.path) # HTML forms will append a ? to the URL, # remove it when present to standardize URLs. self.path = self.path.rstrip('?') # There are four possible uses of GET we have to distinguish between. # 1) GET / # => return a page displaying all objects in the datastore. # 2) GET /object_creation_form # => return the form for creating objects. # 3) GET /uid/HTML_update_form # => return the update form for object uid. # 4) GET /uid # => return HTML representation of object uid. # 1) GET / # => return a page displaying all objects in the datastore. if self.path == '/': print('Handling /') # Open the datastore and get a list of all the objects in it. m = model.Model('test_model') obj_set = m.listall() m.close() # Build the output page: title = 'Quoteserver Home Page' title_block = ''' <h1>QuoteServer Home Page</h1> <form method=\"GET\" action=\"/object_creation_form\"> <input type=\"submit\" value=\"Add a new Quote\" /> </form> <h2>Current Quotes:</h2> ''' # Build a list of HTML representations of the objects. obj_set_HTML = [] for obj in obj_set: obj_set_HTML.append(obj.HTML()) # Assemble the body of the page. body = '\\n'.join([title_block,'\\n'.join(obj_set_HTML)]) # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) # 2) GET /object_creation_form # => return the form for creating objects. elif self.path == '/object_creation_form': # Build the output page: title = 'Quote creation form' body = quote.CREATION_FORM # Because at the moment we only have Quotes. # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) # 3) GET /uid/HTML_update_form # => return the update form for object uid. elif self.path.endswith('/HTML_update_form'): uid = self.path[1:-len('/HTML_update_form')] m = model.Model('test_model') obj = m.retrieve(uid) m.close() if obj: title = 'Update form for object %s', body = obj.HTML_update_form() page = HTML5_template % (title, body) self.send_response(200) self.end_headers() self.wfile.write(page.encode('utf-8')) else: self.send_response(404) # Not found. self.end_headers() print('Error: Object %s not found!' % (uid)) # 4) GET /uid # => return HTML representation of object uid. else: # (The request may not be for /uid but we can safely assume it is # since if it isn't not such object will be found and we'll # just return an error.) uid = self.path[1:] # Trim the leading / from the URL to get a uid. m = model.Model('test_model') obj = m.retrieve(uid) # Retrieve the obejct from the datastore. m.close() if obj: title = 'Object %s' % (uid) body = obj.HTML() # Call its HTML method. page = HTML5_template % (title, body) self.send_response(200) self.end_headers() self.wfile.write(page.encode('utf-8')) else: self.send_response(404) # Not found. self.end_headers() print('Error: Object %s not found!' % (uid)) def do_POST(self): # There are three legitimate possible uses of POST we have to # distinguish between. # # The first is the genuine POST: # # 1) POST /create/objtype # => Create an obj of class objtype, and # return a page displaying the newly created object. # # The other two are when we tunnel PUT and DELETE through POST. # # 2) POST /uid with method field == 'PUT' # => Modify object uid, and # return a page displaying the modified object. # # 3) POST /uid with method field == 'DELETE' # => Delete object uid, and # redirect to the home page. # # We could detect the true POST by looking at the URL POSTed to, # but this would not extend to tunneled PUTs and DELETEs because they # both use the same URL. # # Instead, for similarity of processing, we will test the hidden method # field in all three cases and react appropriately. # Parse the query string to get method field which means first # parsing the form arguments into a dictionary. self.query_string = self.rfile.read(int(self.headers['Content-Length'])) self.args = dict(urllib.parse.parse_qsl(self.query_string)) # 1) Is it a genuine POST? if self.args[b'_method'] == b'POST': print('Got a genuine POST') # Check that it is posting to a credible URL, # i.e. one with form /create/obj_type, # i.e. one that at least begins with /create/ if self.path.startswith('/create/'): # The type of object to create is given by the suffix after /create/ obj_type = self.path[len('/create/'):] # Now try to create the object, e.g. quote.HTML_factory(self.args) obj = eval(obj_type + '.HTML_factory(self.args)') # If creation was successful: if obj: m = model.Model('test_model') m.create(obj) m.close() # Now return a view of the newly created object by redirecting # to its URL. self.send_response(301) self.send_header('Location', '/%s' % obj.uid) self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('POST Error: obj not created!') # Otherwise POSTing to a disallowed URL. else: self.send_response(405) # Method not allowed by that resource. self.end_headers() print('Error: Tried to POST to %s!' % (self.path)) # 2) Is this POST tunneling a PUT? elif self.args[b'_method'] == b'PUT': self.do_PUT() # 3) Is this POST tunneling a DELETE? elif self.args[b'_method'] == b'DELETE': self.do_DELETE() # 4) Got a bogus method. else: self.send_response(405) # Method not allowed. self.end_headers() print('POST Error: method %s not recognized!' % (self.args[b'_method'])) def do_PUT(self): # Check if the query string has already been parsed # i.e. if this request was tunneled through a POST. # If it wasn't then parse it now. if not self.args: self.query_string = self.rfile.read(int(self.headers['Content-Length'])) self.args = dict(urllib.parse.parse_qsl(self.query_string)) # Get the uid. old_uid = self.path[1:] # Ignore the initial / # Fetch the object. m = model.Model('test_model') old_obj = m.retrieve(old_uid) m.close() # Determine the object type... obj_type = old_obj.__module__ # ...and create a new object based on the updated attributes. new_obj = eval(obj_type + '.HTML_factory(self.args)') # If creation was successful: if new_obj: # Store the new object in the model and delete the old one. m = model.Model('test_model') new_uid = m.update(old_uid, new_obj) m.close() # Now return a view of the newly created object by redirecting # to its URL. self.send_response(301) self.send_header('Location', '/%s' % new_obj.uid) self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('UPDATE Error: obj not created!') def do_DELETE(self): # Get the uid of the object to delete. uid = self.path[1:] # Trim the leading / from the URL to get a uid. # Access the datastore. m = model.Model('test_model') # If we delete the object successfully... if m.delete(uid): # ...redirect the browser to the home page. self.send_response(301) self.send_header('Location', '/') self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('DELETE failed') # In any event close the datastore. m.close() if __name__ == '__main__': PORT = 80 server_address= ('', PORT) httpd = http.server.HTTPServer(server_address, myHTTPHandler) print('Serving on port', PORT, '...') httpd.serve_forever() # quote.py # # Version 3 # # Changes: # # - Adding HTML methods. # - Rename factory to be console_factory # - Rename update to be console_update # # Version 2 (archived as quote_2.py) # # Changes: # # - Implemented Quote.update() method. # # Version 1 (archived as quote_1.py) # # Changes: # # - Changed naming convention to initial lower case to ease importing. # # - Added creation method to be called from controller when new Quote # object is required. # # - Changed name of object creation routine from \"create\" to \"factory\" # to avoid confusion with Model.create and to follow common practice # of Factory patterns # (see e.g. http://en.wikipedia.org/wiki/Factory_method_pattern). # # Version 0 (archived as Quote_0.py) # # - Initial roughing out. def console_factory(): '''Handles console interaction required to create a new Quote object.''' author = input('Who is the author of the quote? ') text = input('What did they say or write? ') return Quote(author, text) def HTML_factory(form_dict): '''Builds a Quote from the data returned in the form CREATION_FORM.''' author = form_dict[b'author'].decode('utf-8') text = form_dict[b'text'].decode('utf-8') return Quote(author, text) # Use this template for both creation via POST and update via PUT. CREATION_FORM = ''' <h1>Create form</h1> <div> <form method=\"POST\" action=\"http://localhost/create/quote\"> <input type=\"hidden\" name=\"_method\" value=\"POST\" /> <label for=\"text\">Text:</label><textarea id=\"text\" name=\"text\" rows=\"3\" cols=\"50\">Enter the quote here...</textarea><br /> <label for=\"author\">Author:</label><input type=\"text\" id=\"author\" name=\"author\" size=\"50\" /><br /> <label for=\"method\">&nbsp;</label> <input type=\"submit\" value=\"Create\" /> </form> </div> ''' UPDATE_TEMPLATE = ''' <h1>Update form</h1> <div> <form method=\"POST\" action=\"http://localhost/%s\"> <input type=\"hidden\" name=\"_method\" value=\"PUT\" /> <label for=\"text\">Text:</label><textarea id=\"text\" name=\"text\" rows=\"3\" cols=\"50\">%s</textarea><br /> <label for=\"author\">Author:</label><input type=\"text\" id=\"author\" name=\"author\" size=\"50\" value=\"%s\"/><br /> <label for=\"method\">&nbsp;</label> <input type=\"submit\" value=\"Update\" /> </form> </div> ''' HTML_TEMPLATE = ''' <div> <blockquote> <p><span class=\"quote-text\">%s</span> ~ <span class=\"quote-author\">%s</span></p> </blockquote> <!-- View this quote alone. --> <form method=\"GET\" action=\"http://localhost/%s\" class=\"view\"> <input type=\"submit\" value=\"View\" /> </form> <!-- Request the update form for this quote. --> <form method=\"GET\" action=\"http://localhost/%s/HTML_update_form\" class=\"update\"> <input type=\"submit\" value=\"Update\" /> </form> <!-- Delete this quote. --> <form method=\"POST\" action=\"http://localhost/%s\" class=\"delete\"> <input type=\"hidden\" name=\"_method\" value=\"DELETE\" /> <input type=\"submit\" value=\"Delete\" /> </form> </div> ''' class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return '[%s] %s said \"%s\"' % (self.uid, self.author, self.text) def HTML(self): return HTML_TEMPLATE % (self.text, self.author, self.uid, self.uid, self.uid) def HTML_update_form(self): return UPDATE_TEMPLATE % (self.uid, self.text, self.author) def console_update(self): '''Handles the console interaction required to modify a Quote object.''' print('The current author is:', self.author) change = input('Modify author (y/n)? ') if change in ['y', 'Y']: self.author = input('Enter modified author: ') print('The current text is:', self.text) change = input('Modify text (y/n)? ') if change in ['y', 'Y']: self.text = input('Enter modified text: ') self.uid = str(hash('Quote' + self.author + self.text)) if __name__ == '__main__': def bordered(s): return len(s)*'='+'\\n'+s+'\\n'+len(s)*'-' print(bordered('Testing __init__() and __str__()')) q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') print('The Quote q is:') print('\\t', q) print('The Quote r is:') print('\\t', r) print() print(bordered('Testing HTML()')) print('Here\u2019s the HTMl representation of q:') print(q.HTML()) ## print(bordered('Testing console_factory()')) ## s = console_factory() ## print('Here\u2019s the new Quote object:') ## print('\\t', s) ## print('Did factory create a Quote object?',) ## print(type(s) == type(q)) # Checks that factory is returning a Quote object. ## print() ## ## print(bordered('Testing console_update()')) ## print('The Quote q before:') ## print('\\t', q) ## print() ## print('Calling console_update():') ## print() ## q.console_update() ## print() ## print('The Quote q after:') ## print('\\t', q) ## print()","title":"Actual code"},{"location":"10.1_HTTP_REST/16_Actual_code/#actual-code","text":"The code logic flows quite cleanly from the HTTP Method column. We can see that ideally we only have any logic with GET requests (since four actions use GET requests), but that with POST, PUT and DELETE we always follow a single course of action. I say ideally because the ugly truth about browsers means that POST will actually correspond to three possibilities: a true POST, a tunneled UPDATE, or a tunneled DELETE. This is handled by including a hidden field in the input forms giving the actual intended method. This requires modifications to the forms which are provided by quote.py (see below). # quote_server.py # # HTTP server that provides CRUD operations for Quote objects. # # Version 5 # # - Tidied up substantially. # # Version 4 # # - Implemented PUT and DELETE by tunneling them through POST. # # Version 3 # # - Implement all GETs and POSTs pending decision on how to proceed # with PUTs and DELETEs. # # Version 1 # # - Tidied up a bit. # # Version 0 (archived as object_server_0.py) # # - Initial roughing out to demonstrate HTTP concepts in practice. # - Tries to send genuine PUT and DELETE. import quote import model # Was named MVC_model HTML5_template = open('HTML5_template.html','r').read() # We will modify http.server to create our server. import http.server # Needed to parse the arguments import urllib.parse class myHTTPHandler(http.server.BaseHTTPRequestHandler): # BaseHTTPRequestHandler will call do_XXX when receiving # a request specifying method XXX. # # The do_XXX methods do not take any arguments because # self contains all the request information in its instance attributes. def do_GET(self): print('GET for', self.path) # HTML forms will append a ? to the URL, # remove it when present to standardize URLs. self.path = self.path.rstrip('?') # There are four possible uses of GET we have to distinguish between. # 1) GET / # => return a page displaying all objects in the datastore. # 2) GET /object_creation_form # => return the form for creating objects. # 3) GET /uid/HTML_update_form # => return the update form for object uid. # 4) GET /uid # => return HTML representation of object uid. # 1) GET / # => return a page displaying all objects in the datastore. if self.path == '/': print('Handling /') # Open the datastore and get a list of all the objects in it. m = model.Model('test_model') obj_set = m.listall() m.close() # Build the output page: title = 'Quoteserver Home Page' title_block = ''' <h1>QuoteServer Home Page</h1> <form method=\"GET\" action=\"/object_creation_form\"> <input type=\"submit\" value=\"Add a new Quote\" /> </form> <h2>Current Quotes:</h2> ''' # Build a list of HTML representations of the objects. obj_set_HTML = [] for obj in obj_set: obj_set_HTML.append(obj.HTML()) # Assemble the body of the page. body = '\\n'.join([title_block,'\\n'.join(obj_set_HTML)]) # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) # 2) GET /object_creation_form # => return the form for creating objects. elif self.path == '/object_creation_form': # Build the output page: title = 'Quote creation form' body = quote.CREATION_FORM # Because at the moment we only have Quotes. # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) # 3) GET /uid/HTML_update_form # => return the update form for object uid. elif self.path.endswith('/HTML_update_form'): uid = self.path[1:-len('/HTML_update_form')] m = model.Model('test_model') obj = m.retrieve(uid) m.close() if obj: title = 'Update form for object %s', body = obj.HTML_update_form() page = HTML5_template % (title, body) self.send_response(200) self.end_headers() self.wfile.write(page.encode('utf-8')) else: self.send_response(404) # Not found. self.end_headers() print('Error: Object %s not found!' % (uid)) # 4) GET /uid # => return HTML representation of object uid. else: # (The request may not be for /uid but we can safely assume it is # since if it isn't not such object will be found and we'll # just return an error.) uid = self.path[1:] # Trim the leading / from the URL to get a uid. m = model.Model('test_model') obj = m.retrieve(uid) # Retrieve the obejct from the datastore. m.close() if obj: title = 'Object %s' % (uid) body = obj.HTML() # Call its HTML method. page = HTML5_template % (title, body) self.send_response(200) self.end_headers() self.wfile.write(page.encode('utf-8')) else: self.send_response(404) # Not found. self.end_headers() print('Error: Object %s not found!' % (uid)) def do_POST(self): # There are three legitimate possible uses of POST we have to # distinguish between. # # The first is the genuine POST: # # 1) POST /create/objtype # => Create an obj of class objtype, and # return a page displaying the newly created object. # # The other two are when we tunnel PUT and DELETE through POST. # # 2) POST /uid with method field == 'PUT' # => Modify object uid, and # return a page displaying the modified object. # # 3) POST /uid with method field == 'DELETE' # => Delete object uid, and # redirect to the home page. # # We could detect the true POST by looking at the URL POSTed to, # but this would not extend to tunneled PUTs and DELETEs because they # both use the same URL. # # Instead, for similarity of processing, we will test the hidden method # field in all three cases and react appropriately. # Parse the query string to get method field which means first # parsing the form arguments into a dictionary. self.query_string = self.rfile.read(int(self.headers['Content-Length'])) self.args = dict(urllib.parse.parse_qsl(self.query_string)) # 1) Is it a genuine POST? if self.args[b'_method'] == b'POST': print('Got a genuine POST') # Check that it is posting to a credible URL, # i.e. one with form /create/obj_type, # i.e. one that at least begins with /create/ if self.path.startswith('/create/'): # The type of object to create is given by the suffix after /create/ obj_type = self.path[len('/create/'):] # Now try to create the object, e.g. quote.HTML_factory(self.args) obj = eval(obj_type + '.HTML_factory(self.args)') # If creation was successful: if obj: m = model.Model('test_model') m.create(obj) m.close() # Now return a view of the newly created object by redirecting # to its URL. self.send_response(301) self.send_header('Location', '/%s' % obj.uid) self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('POST Error: obj not created!') # Otherwise POSTing to a disallowed URL. else: self.send_response(405) # Method not allowed by that resource. self.end_headers() print('Error: Tried to POST to %s!' % (self.path)) # 2) Is this POST tunneling a PUT? elif self.args[b'_method'] == b'PUT': self.do_PUT() # 3) Is this POST tunneling a DELETE? elif self.args[b'_method'] == b'DELETE': self.do_DELETE() # 4) Got a bogus method. else: self.send_response(405) # Method not allowed. self.end_headers() print('POST Error: method %s not recognized!' % (self.args[b'_method'])) def do_PUT(self): # Check if the query string has already been parsed # i.e. if this request was tunneled through a POST. # If it wasn't then parse it now. if not self.args: self.query_string = self.rfile.read(int(self.headers['Content-Length'])) self.args = dict(urllib.parse.parse_qsl(self.query_string)) # Get the uid. old_uid = self.path[1:] # Ignore the initial / # Fetch the object. m = model.Model('test_model') old_obj = m.retrieve(old_uid) m.close() # Determine the object type... obj_type = old_obj.__module__ # ...and create a new object based on the updated attributes. new_obj = eval(obj_type + '.HTML_factory(self.args)') # If creation was successful: if new_obj: # Store the new object in the model and delete the old one. m = model.Model('test_model') new_uid = m.update(old_uid, new_obj) m.close() # Now return a view of the newly created object by redirecting # to its URL. self.send_response(301) self.send_header('Location', '/%s' % new_obj.uid) self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('UPDATE Error: obj not created!') def do_DELETE(self): # Get the uid of the object to delete. uid = self.path[1:] # Trim the leading / from the URL to get a uid. # Access the datastore. m = model.Model('test_model') # If we delete the object successfully... if m.delete(uid): # ...redirect the browser to the home page. self.send_response(301) self.send_header('Location', '/') self.end_headers() # Otherwise something went wrong. else: self.send_response(500) # Internal server error. self.end_headers() print('DELETE failed') # In any event close the datastore. m.close() if __name__ == '__main__': PORT = 80 server_address= ('', PORT) httpd = http.server.HTTPServer(server_address, myHTTPHandler) print('Serving on port', PORT, '...') httpd.serve_forever() # quote.py # # Version 3 # # Changes: # # - Adding HTML methods. # - Rename factory to be console_factory # - Rename update to be console_update # # Version 2 (archived as quote_2.py) # # Changes: # # - Implemented Quote.update() method. # # Version 1 (archived as quote_1.py) # # Changes: # # - Changed naming convention to initial lower case to ease importing. # # - Added creation method to be called from controller when new Quote # object is required. # # - Changed name of object creation routine from \"create\" to \"factory\" # to avoid confusion with Model.create and to follow common practice # of Factory patterns # (see e.g. http://en.wikipedia.org/wiki/Factory_method_pattern). # # Version 0 (archived as Quote_0.py) # # - Initial roughing out. def console_factory(): '''Handles console interaction required to create a new Quote object.''' author = input('Who is the author of the quote? ') text = input('What did they say or write? ') return Quote(author, text) def HTML_factory(form_dict): '''Builds a Quote from the data returned in the form CREATION_FORM.''' author = form_dict[b'author'].decode('utf-8') text = form_dict[b'text'].decode('utf-8') return Quote(author, text) # Use this template for both creation via POST and update via PUT. CREATION_FORM = ''' <h1>Create form</h1> <div> <form method=\"POST\" action=\"http://localhost/create/quote\"> <input type=\"hidden\" name=\"_method\" value=\"POST\" /> <label for=\"text\">Text:</label><textarea id=\"text\" name=\"text\" rows=\"3\" cols=\"50\">Enter the quote here...</textarea><br /> <label for=\"author\">Author:</label><input type=\"text\" id=\"author\" name=\"author\" size=\"50\" /><br /> <label for=\"method\">&nbsp;</label> <input type=\"submit\" value=\"Create\" /> </form> </div> ''' UPDATE_TEMPLATE = ''' <h1>Update form</h1> <div> <form method=\"POST\" action=\"http://localhost/%s\"> <input type=\"hidden\" name=\"_method\" value=\"PUT\" /> <label for=\"text\">Text:</label><textarea id=\"text\" name=\"text\" rows=\"3\" cols=\"50\">%s</textarea><br /> <label for=\"author\">Author:</label><input type=\"text\" id=\"author\" name=\"author\" size=\"50\" value=\"%s\"/><br /> <label for=\"method\">&nbsp;</label> <input type=\"submit\" value=\"Update\" /> </form> </div> ''' HTML_TEMPLATE = ''' <div> <blockquote> <p><span class=\"quote-text\">%s</span> ~ <span class=\"quote-author\">%s</span></p> </blockquote> <!-- View this quote alone. --> <form method=\"GET\" action=\"http://localhost/%s\" class=\"view\"> <input type=\"submit\" value=\"View\" /> </form> <!-- Request the update form for this quote. --> <form method=\"GET\" action=\"http://localhost/%s/HTML_update_form\" class=\"update\"> <input type=\"submit\" value=\"Update\" /> </form> <!-- Delete this quote. --> <form method=\"POST\" action=\"http://localhost/%s\" class=\"delete\"> <input type=\"hidden\" name=\"_method\" value=\"DELETE\" /> <input type=\"submit\" value=\"Delete\" /> </form> </div> ''' class Quote: def __init__(self, author='', text=''): self.author = author self.text = text self.uid = str(hash('Quote' + self.author + self.text)) def __str__(self): return '[%s] %s said \"%s\"' % (self.uid, self.author, self.text) def HTML(self): return HTML_TEMPLATE % (self.text, self.author, self.uid, self.uid, self.uid) def HTML_update_form(self): return UPDATE_TEMPLATE % (self.uid, self.text, self.author) def console_update(self): '''Handles the console interaction required to modify a Quote object.''' print('The current author is:', self.author) change = input('Modify author (y/n)? ') if change in ['y', 'Y']: self.author = input('Enter modified author: ') print('The current text is:', self.text) change = input('Modify text (y/n)? ') if change in ['y', 'Y']: self.text = input('Enter modified text: ') self.uid = str(hash('Quote' + self.author + self.text)) if __name__ == '__main__': def bordered(s): return len(s)*'='+'\\n'+s+'\\n'+len(s)*'-' print(bordered('Testing __init__() and __str__()')) q = Quote( 'Kent Beck', 'Optimism is an occupational hazard of programming: testing is the treatment.') r = Quote( 'Brian Kernighan', 'Controlling complexity is the essence of computer programming.') print('The Quote q is:') print('\\t', q) print('The Quote r is:') print('\\t', r) print() print(bordered('Testing HTML()')) print('Here\u2019s the HTMl representation of q:') print(q.HTML()) ## print(bordered('Testing console_factory()')) ## s = console_factory() ## print('Here\u2019s the new Quote object:') ## print('\\t', s) ## print('Did factory create a Quote object?',) ## print(type(s) == type(q)) # Checks that factory is returning a Quote object. ## print() ## ## print(bordered('Testing console_update()')) ## print('The Quote q before:') ## print('\\t', q) ## print() ## print('Calling console_update():') ## print() ## q.console_update() ## print() ## print('The Quote q after:') ## print('\\t', q) ## print()","title":"Actual code"},{"location":"10.1_HTTP_REST/17_To_object_server_1/","text":"Towards an object server: #1 Identify couplings to quote class We would like to generalize our quote server to handle any type of object. To do that we are going to walk through the quote server to identify places where we have tightly coupled our code to the quote object. If you search for the word quote in quote_server_5.py you will find around a dozen places where the word quote is used. Many of these are in the comments or the html, in these cases we can simply change the word quote to the word object. We can also leave the import statement alone, we still want to import our quote object, in the future we will want to add other object types as well. In the do_POST method we need to call the HTML_factory method for our quote. This code already works for any object because it looks up the object type based on the path, and then uses eval to call the HTML_factory specific to that object type. As long as our new objects have working HTML factories, this code is good to go. # The type of object to create is given by the suffix after /create/ obj_type = self.path[len('/create/'):] # Now try to create the object, e.g. quote.HTML_factory(self.args) obj = eval(obj_type + '.HTML_factory(self.args)') The other change is related to the object creation form. Currently, when you indicate that you want to make a new object it displays the object_creation_form. This form is specific to quote objects, and won't work for a general object server. # 2) GET /object_creation_form # => return the form for creating objects. elif self.path == '/object_creation_form': # Build the output page: title = 'Object creation form' body = quote.CREATION_FORM # Because at the moment we only have Quotes. # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) In the future we will want that to display a drop down menu so that we can pick which type of object we would like to add.","title":"Towards an object server: #1 Identify couplings to quote class"},{"location":"10.1_HTTP_REST/17_To_object_server_1/#towards-an-object-server-1-identify-couplings-to-quote-class","text":"We would like to generalize our quote server to handle any type of object. To do that we are going to walk through the quote server to identify places where we have tightly coupled our code to the quote object. If you search for the word quote in quote_server_5.py you will find around a dozen places where the word quote is used. Many of these are in the comments or the html, in these cases we can simply change the word quote to the word object. We can also leave the import statement alone, we still want to import our quote object, in the future we will want to add other object types as well. In the do_POST method we need to call the HTML_factory method for our quote. This code already works for any object because it looks up the object type based on the path, and then uses eval to call the HTML_factory specific to that object type. As long as our new objects have working HTML factories, this code is good to go. # The type of object to create is given by the suffix after /create/ obj_type = self.path[len('/create/'):] # Now try to create the object, e.g. quote.HTML_factory(self.args) obj = eval(obj_type + '.HTML_factory(self.args)') The other change is related to the object creation form. Currently, when you indicate that you want to make a new object it displays the object_creation_form. This form is specific to quote objects, and won't work for a general object server. # 2) GET /object_creation_form # => return the form for creating objects. elif self.path == '/object_creation_form': # Build the output page: title = 'Object creation form' body = quote.CREATION_FORM # Because at the moment we only have Quotes. # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) In the future we will want that to display a drop down menu so that we can pick which type of object we would like to add.","title":"Towards an object server: #1 Identify couplings to quote class"},{"location":"10.1_HTTP_REST/18_To_object_server_2/","text":"Towards an object server: #2 Object creation menu requirements The new version of our object creation page should have a dropdown to allow the user to select the creation form of the object they want to add. This will change the mapping of our actions. We are going to have to add a new step when we create a new object. We are going to have a new GET method to generate the object_creation_menu . We will also need the object_creation_form to detect the object type being asked for. Action HTTP Method URL Python Methods and Actions List all objects GET / model.listall() + display entries as HTML Retrieve an object GET /uid obj = model.retrieve(uid) + display as HTML, i.e. obj.HTML() Create a new object GET /object_creation_menu New code: to return menu form GET /object_creation_form new: detect objtype being requested and then return a static HTML page containing the form for that object type POST /create/objtype obj = Quote() + model.create(obj) + display new object as HTML, i.e. obj.HTML() Delete an object DELETE /uid model.delete(uid) + model.listall() + display entries as HTML Update an object GET /uid/HTML_update_form new: return uid's update_form(), i.e. obj = model.retrieve(uid) + return obj.HTML_update_form() PUT /uid new_uid = model.update(uid, obj) followed by obj = model.retrieve(new_uid) + display as HTML, i.e. obj.HTML() So what does the code need to look like to incorporate these changes?","title":"Towards an object server: #2 Object creation menu requirements"},{"location":"10.1_HTTP_REST/18_To_object_server_2/#towards-an-object-server-2-object-creation-menu-requirements","text":"The new version of our object creation page should have a dropdown to allow the user to select the creation form of the object they want to add. This will change the mapping of our actions. We are going to have to add a new step when we create a new object. We are going to have a new GET method to generate the object_creation_menu . We will also need the object_creation_form to detect the object type being asked for. Action HTTP Method URL Python Methods and Actions List all objects GET / model.listall() + display entries as HTML Retrieve an object GET /uid obj = model.retrieve(uid) + display as HTML, i.e. obj.HTML() Create a new object GET /object_creation_menu New code: to return menu form GET /object_creation_form new: detect objtype being requested and then return a static HTML page containing the form for that object type POST /create/objtype obj = Quote() + model.create(obj) + display new object as HTML, i.e. obj.HTML() Delete an object DELETE /uid model.delete(uid) + model.listall() + display entries as HTML Update an object GET /uid/HTML_update_form new: return uid's update_form(), i.e. obj = model.retrieve(uid) + return obj.HTML_update_form() PUT /uid new_uid = model.update(uid, obj) followed by obj = model.retrieve(new_uid) + display as HTML, i.e. obj.HTML() So what does the code need to look like to incorporate these changes?","title":"Towards an object server: #2 Object creation menu requirements"},{"location":"10.1_HTTP_REST/19_To_object_server_3/","text":"Towards an object server: #3 Object creation menu Python code The first change we want to make to our object server is that it needs to detect when someone asks for an object creation menu and give them the appropriate menu form. It also needs to detect, when it is asked for the object creation form, what the value of that form variable object type is. This will be added to our do_GET method. First I updated the commenting to insert the menu as the second elif , this involved some fiddly updating of the numbering in the comments too. # There are five possible uses of GET we have to distinguish between. # 1) GET / # => return a page displaying all objects in the datastore. # 2) GET /object_creation_menu # => return the menu for selecting objects. # 3) GET /object_creation_form # => return the form for creating objects. # 4) GET /uid/HTML_update_form # => return the update form for object uid. # 5) GET /uid # => return HTML representation of object uid. Now it is time to start creating our menu. All I need to do is adjust the path, change the title, and change the body. The body of the page is no longer created by a function, instead we've replaced it with a static variable called CREATION_MENU . # 2) GET /object_creation_menu # => return the menu for selecting object type to create. elif self.path == '/object_creation_menu': # Build the output page: title = 'Object creation menu' body = CREATION_MENU # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) The next step is to write the html for the menu. The place for a static variable is at the top of our code. It will be a triple quoted string with the html page. The new element is the dropdown list, which we haven't used before. The dropdown gets implemented using a select object. This menu will send the user to the object creation form. CREATION_MENU = ''' <h1>Object Creation Menu</h1> <div> <p style=\"text-align: center;\">Select the type of object you would like to create:</p> <form method=\"get\" action=\"http://localhost/object_creation_form\" style=\"text-align: center;\"> <select name=\"obj_type\"> <option value=\"quote\" selected=\"selected\">Quote</option> <option value=\"hockey_player\">Hockey Player</option> </select> <br /> <input type=\"submit\" value=\"Continue\" /> </form> </div> ''' We also need to change the button to select an object to point to our selection menu, instead of the quote creation form. This is in the title block of the homepage, which is handled in the GET method. if self.path == '/': print('Handling /') # Open the datastore and get a list of all the objects in it. m = model.Model('test_model') obj_set = m.listall() m.close() # Build the output page: title = 'Ojectserver Home Page' title_block = ''' <h1>ObjectServer Home Page</h1> <form method=\"GET\" action=\"/object_creation_menu\"> #CHANGE to _menu <input type=\"submit\" value=\"Add a new Object\" /> </form> <h2>Current Objects:</h2> ''' # Build a list of HTML representations of the objects. obj_set_HTML = [] for obj in obj_set: obj_set_HTML.append(obj.HTML()) # Assemble the body of the page. body = '\\n'.join([title_block,'\\n'.join(obj_set_HTML)]) # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) Next we need to object creation form to detect the object type.","title":"Towards an object server: #3 Object creation menu Python code"},{"location":"10.1_HTTP_REST/19_To_object_server_3/#towards-an-object-server-3-object-creation-menu-python-code","text":"The first change we want to make to our object server is that it needs to detect when someone asks for an object creation menu and give them the appropriate menu form. It also needs to detect, when it is asked for the object creation form, what the value of that form variable object type is. This will be added to our do_GET method. First I updated the commenting to insert the menu as the second elif , this involved some fiddly updating of the numbering in the comments too. # There are five possible uses of GET we have to distinguish between. # 1) GET / # => return a page displaying all objects in the datastore. # 2) GET /object_creation_menu # => return the menu for selecting objects. # 3) GET /object_creation_form # => return the form for creating objects. # 4) GET /uid/HTML_update_form # => return the update form for object uid. # 5) GET /uid # => return HTML representation of object uid. Now it is time to start creating our menu. All I need to do is adjust the path, change the title, and change the body. The body of the page is no longer created by a function, instead we've replaced it with a static variable called CREATION_MENU . # 2) GET /object_creation_menu # => return the menu for selecting object type to create. elif self.path == '/object_creation_menu': # Build the output page: title = 'Object creation menu' body = CREATION_MENU # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) The next step is to write the html for the menu. The place for a static variable is at the top of our code. It will be a triple quoted string with the html page. The new element is the dropdown list, which we haven't used before. The dropdown gets implemented using a select object. This menu will send the user to the object creation form. CREATION_MENU = ''' <h1>Object Creation Menu</h1> <div> <p style=\"text-align: center;\">Select the type of object you would like to create:</p> <form method=\"get\" action=\"http://localhost/object_creation_form\" style=\"text-align: center;\"> <select name=\"obj_type\"> <option value=\"quote\" selected=\"selected\">Quote</option> <option value=\"hockey_player\">Hockey Player</option> </select> <br /> <input type=\"submit\" value=\"Continue\" /> </form> </div> ''' We also need to change the button to select an object to point to our selection menu, instead of the quote creation form. This is in the title block of the homepage, which is handled in the GET method. if self.path == '/': print('Handling /') # Open the datastore and get a list of all the objects in it. m = model.Model('test_model') obj_set = m.listall() m.close() # Build the output page: title = 'Ojectserver Home Page' title_block = ''' <h1>ObjectServer Home Page</h1> <form method=\"GET\" action=\"/object_creation_menu\"> #CHANGE to _menu <input type=\"submit\" value=\"Add a new Object\" /> </form> <h2>Current Objects:</h2> ''' # Build a list of HTML representations of the objects. obj_set_HTML = [] for obj in obj_set: obj_set_HTML.append(obj.HTML()) # Assemble the body of the page. body = '\\n'.join([title_block,'\\n'.join(obj_set_HTML)]) # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) Next we need to object creation form to detect the object type.","title":"Towards an object server: #3 Object creation menu Python code"},{"location":"10.1_HTTP_REST/20_To_object_server_4/","text":"Towards an object server: #4 Final steps The object creation form now has to parse the query string a little differently than when it came in as a post because the browser formats them differently. When the query string is submitted by GET it has the url, followed by a question mark, followed by key/value pairs (e.g. /object_creation_form?obj_type=quote). The keys and values are separated by equal signs (=) and the pairs are separated by ampersands (&). What we want to do is pull the value of the quote and we can do this using the split method. Once we have the object type then we know which creation form to run. In our example it is a quote creation form, but it will change depending what the user selects. # 3) GET /object_creation_form # => return the form for creating objects. elif self.path.startswith('/object_creation_form'): # Parse query string (e.g. /object_creation_form?obj_type=quote) # to get value of obj_type. self.path, self.query_string = self.path.split('?', 1) dummy, obj_type = self.query_string.split('=', 1) # Build the output page: title = '%s creation form' % (obj_type) body = eval(obj_type + '.CREATION_FORM') # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) This code will work if we import hockey_player as well as quote.","title":"Towards an object server: #4 Final steps"},{"location":"10.1_HTTP_REST/20_To_object_server_4/#towards-an-object-server-4-final-steps","text":"The object creation form now has to parse the query string a little differently than when it came in as a post because the browser formats them differently. When the query string is submitted by GET it has the url, followed by a question mark, followed by key/value pairs (e.g. /object_creation_form?obj_type=quote). The keys and values are separated by equal signs (=) and the pairs are separated by ampersands (&). What we want to do is pull the value of the quote and we can do this using the split method. Once we have the object type then we know which creation form to run. In our example it is a quote creation form, but it will change depending what the user selects. # 3) GET /object_creation_form # => return the form for creating objects. elif self.path.startswith('/object_creation_form'): # Parse query string (e.g. /object_creation_form?obj_type=quote) # to get value of obj_type. self.path, self.query_string = self.path.split('?', 1) dummy, obj_type = self.query_string.split('=', 1) # Build the output page: title = '%s creation form' % (obj_type) body = eval(obj_type + '.CREATION_FORM') # Inject the page body into the page template. page = HTML5_template % (title, body) # Send the response and any header lines. self.send_response(200) self.end_headers() # Return the page. self.wfile.write(page.encode('utf-8')) This code will work if we import hockey_player as well as quote.","title":"Towards an object server: #4 Final steps"},{"location":"10.1_HTTP_REST/21_Something_we_re_not_doing/","text":"Something we\u2019re not doing... ...but I thought you might notice, and so should explain. The eagle-eyed among you with good memories as well might recall seeing earlier a placeholder labelled Automatically building the object creation form\u201d. It seemed like a good idea at the time (programmers always want to automate things!), but it\u2019s gone now. It would be nice in a production system to automate the object creation menu so that when a new object type is added to the system the form is automatically updated, but it would mean organizing the object classes into a subdirectory, and using some new import mechanisms, and writing some detailed code. Nothing tricky, but too many fussy details to deal with. Meanwhile we don\u2019t have much to change manually in our system when we add a new object type. In fact there are only two places near the top of the file and near each other, where we need to make additions: Given the ease of the edits it doesn\u2019t seem worth the effort to automate this particular task.","title":"Something we\u2019re not doing... ...but I thought you might notice, and so should explain."},{"location":"10.1_HTTP_REST/21_Something_we_re_not_doing/#something-were-not-doing-but-i-thought-you-might-notice-and-so-should-explain","text":"The eagle-eyed among you with good memories as well might recall seeing earlier a placeholder labelled Automatically building the object creation form\u201d. It seemed like a good idea at the time (programmers always want to automate things!), but it\u2019s gone now. It would be nice in a production system to automate the object creation menu so that when a new object type is added to the system the form is automatically updated, but it would mean organizing the object classes into a subdirectory, and using some new import mechanisms, and writing some detailed code. Nothing tricky, but too many fussy details to deal with. Meanwhile we don\u2019t have much to change manually in our system when we add a new object type. In fact there are only two places near the top of the file and near each other, where we need to make additions: Given the ease of the edits it doesn\u2019t seem worth the effort to automate this particular task.","title":"Something we\u2019re not doing... ...but I thought you might notice, and so should explain."},{"location":"10.1_HTTP_REST/22_Summary/","text":"Summary The big picture: We were able to produce an MVC CRUD controller that operated across HTTP by writing our own web server to handle the interactions with the client. This meant translating the CRUD operations into their equivalent HTTP (REST) methods: POST, GET, PUT and DELETE. HTTP design consists largely of mapping actions onto Method+URL pairs. Because our server follows the principles of REST it will be a good web citizen, and lends itself to high performance by enabling caching at all points between and inside client and server. Because we designed our earlier system using an MVC architecture: We were able to reuse model.py without any changes(!). Our changes to quote.py were localized and only added functionality without removing any existing functionality, or requiring us to rewrite any existing code. We did have to rewrite our controller, object_server.py , but we were able to retain its logic, just reimplementing it to deal with intermittent stateless HTTP interactions instead of continuous console interactions. We ignored security issues, which would obviously not be reasonable for a production system! Noteworthy details: We built our web server by subclassing the server the Python Standard Library provides, a classic example of OOP enabling reuse. It turns out the web is just built on computers throwing strings (plain old strings!) back and forth across a network. Faced with browser limitations we had to choose between modifying the client (the browser via Ajax), or modifying our server (via tunneling) to handle PUT and DELETE requests. The web is still new enough that web progamming involves a lot of working around limitations. Tunneling means to enclose one kind of message inside another (an envelope inside an envelope if you will). We tunneled the HTTP methods PUT and DELETE inside POSTs because current browsers don\u2019t support them directly. We made heavy use of templates to simplify the generation of the HTML responses. In an industrial-strength system we would probably store our templates as complete HTML files so they could be created by a graphic or interaction designer. We could then extract the portion of the entire page we require. HTTP application design can benefit from: Explicitly identifying the request-response cycles it will enable. A graphic interaction storyboard showing the transitions between pages\u201d in the application. The final source code: object_server.py The custom web server. model.py The model, unchanged from before(!). quote.py Sample object class that knows how to display, and update itself through HTML. hockey_player.py Sample object class that knows how to display, and update itself through HTML. HTML5_template.html Minimal, generic HTML5 template. It looks like it\u2019s just a %s, but do a view source, or save as, to see what\u2019s really there.","title":"Summary"},{"location":"10.1_HTTP_REST/22_Summary/#summary","text":"The big picture: We were able to produce an MVC CRUD controller that operated across HTTP by writing our own web server to handle the interactions with the client. This meant translating the CRUD operations into their equivalent HTTP (REST) methods: POST, GET, PUT and DELETE. HTTP design consists largely of mapping actions onto Method+URL pairs. Because our server follows the principles of REST it will be a good web citizen, and lends itself to high performance by enabling caching at all points between and inside client and server. Because we designed our earlier system using an MVC architecture: We were able to reuse model.py without any changes(!). Our changes to quote.py were localized and only added functionality without removing any existing functionality, or requiring us to rewrite any existing code. We did have to rewrite our controller, object_server.py , but we were able to retain its logic, just reimplementing it to deal with intermittent stateless HTTP interactions instead of continuous console interactions. We ignored security issues, which would obviously not be reasonable for a production system! Noteworthy details: We built our web server by subclassing the server the Python Standard Library provides, a classic example of OOP enabling reuse. It turns out the web is just built on computers throwing strings (plain old strings!) back and forth across a network. Faced with browser limitations we had to choose between modifying the client (the browser via Ajax), or modifying our server (via tunneling) to handle PUT and DELETE requests. The web is still new enough that web progamming involves a lot of working around limitations. Tunneling means to enclose one kind of message inside another (an envelope inside an envelope if you will). We tunneled the HTTP methods PUT and DELETE inside POSTs because current browsers don\u2019t support them directly. We made heavy use of templates to simplify the generation of the HTML responses. In an industrial-strength system we would probably store our templates as complete HTML files so they could be created by a graphic or interaction designer. We could then extract the portion of the entire page we require. HTTP application design can benefit from: Explicitly identifying the request-response cycles it will enable. A graphic interaction storyboard showing the transitions between pages\u201d in the application. The final source code: object_server.py The custom web server. model.py The model, unchanged from before(!). quote.py Sample object class that knows how to display, and update itself through HTML. hockey_player.py Sample object class that knows how to display, and update itself through HTML. HTML5_template.html Minimal, generic HTML5 template. It looks like it\u2019s just a %s, but do a view source, or save as, to see what\u2019s really there.","title":"Summary"},{"location":"10.1_HTTP_REST/HTML5_template/","text":"%s","title":"HTML5 template"},{"location":"10.1_HTTP_REST/create_a_Quote/","text":"Create form Text: Author:","title":"Create form"},{"location":"10.1_HTTP_REST/create_a_Quote/#create-form","text":"Text: Author:","title":"Create form"},{"location":"10.1_HTTP_REST/home/","text":"QuoteServer Home Page Current Quotes: > [Optimism is an occupational hazard of programming: testing is the > treatment.]{.quote-text} ~ [Kent Beck]{.quote-author} > [Controlling complexity is the essence of computer > programming.]{.quote-text} ~ [Brian Kernighan]{.quote-author} > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"QuoteServer Home Page"},{"location":"10.1_HTTP_REST/home/#quoteserver-home-page","text":"","title":"QuoteServer Home Page"},{"location":"10.1_HTTP_REST/home/#current-quotes","text":"> [Optimism is an occupational hazard of programming: testing is the > treatment.]{.quote-text} ~ [Kent Beck]{.quote-author} > [Controlling complexity is the essence of computer > programming.]{.quote-text} ~ [Brian Kernighan]{.quote-author} > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"Current Quotes:"},{"location":"10.1_HTTP_REST/page_Object_Creation_Menu/","text":"Object Creation Menu Select the type of object you would like to create: Quote Hockey Player","title":"Object Creation Menu"},{"location":"10.1_HTTP_REST/page_Object_Creation_Menu/#object-creation-menu","text":"Select the type of object you would like to create: Quote Hockey Player","title":"Object Creation Menu"},{"location":"10.1_HTTP_REST/page_create_form/","text":"Create form Text: Author:","title":"Create form"},{"location":"10.1_HTTP_REST/page_create_form/#create-form","text":"Text: Author:","title":"Create form"},{"location":"10.1_HTTP_REST/page_home/","text":"QuoteServer Home Page Current Quotes: > [Optimism is an occupational hazard of programming: testing is the > treatment.]{.quote-text} ~ [Kent Beck]{.quote-author} > [Controlling complexity is the essence of computer > programming.]{.quote-text} ~ [Brian Kernighan]{.quote-author} > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"QuoteServer Home Page"},{"location":"10.1_HTTP_REST/page_home/#quoteserver-home-page","text":"","title":"QuoteServer Home Page"},{"location":"10.1_HTTP_REST/page_home/#current-quotes","text":"> [Optimism is an occupational hazard of programming: testing is the > treatment.]{.quote-text} ~ [Kent Beck]{.quote-author} > [Controlling complexity is the essence of computer > programming.]{.quote-text} ~ [Brian Kernighan]{.quote-author} > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"Current Quotes:"},{"location":"10.1_HTTP_REST/page_update_form/","text":"Update form Text: Author:","title":"Update form"},{"location":"10.1_HTTP_REST/page_update_form/#update-form","text":"Text: Author:","title":"Update form"},{"location":"10.1_HTTP_REST/page_view/","text":"View Quote > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"View Quote"},{"location":"10.1_HTTP_REST/page_view/#view-quote","text":"> [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"View Quote"},{"location":"10.1_HTTP_REST/test/","text":"![](http://www.doubleextrapoint.com/images/stories/gordie-howe-puck.jpg){style=\"float: left; padding-right: 20px;\" width=\"100\"} [*Gordie Howe*]{.player-name} [1071 career goals (regular season plus playoffs).]{.goals}","title":"Test"},{"location":"10.1_HTTP_REST/test_form/","text":"First name: Last name:","title":"Test form"},{"location":"10.1_HTTP_REST/update_form/","text":"Update form Text: Author:","title":"Update form"},{"location":"10.1_HTTP_REST/update_form/#update-form","text":"Text: Author:","title":"Update form"},{"location":"10.1_HTTP_REST/view/","text":"View Quote > [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"View Quote"},{"location":"10.1_HTTP_REST/view/#view-quote","text":"> [Yabba-Dabba-Doo!]{.quote-text} ~ [Fred Flintstone]{.quote-author}","title":"View Quote"},{"location":"10.2_IP_1/00_index/","text":"Image Processing 1 Introduction PIL: The Python Imaging Library Test Images IPO Programming Point vs Neighbourhood Processes Edge Detection","title":"Contents"},{"location":"10.2_IP_1/00_index/#image-processing-1","text":"Introduction PIL: The Python Imaging Library Test Images IPO Programming Point vs Neighbourhood Processes Edge Detection","title":"Image Processing 1"},{"location":"10.2_IP_1/01_Introduction/","text":"Introduction For our last problem domain of the term, we\u2019ll take a look at image processing. Not a formal introduction to digital image processing, since to do that justice would take more mathematical background that you have at the moment. Instead we\u2019ll cherry pick a few interesting problems that are also accessible. A digital image is a two-dimensional array of pixels. Pixel stands for \u201cpicture element\u201d, and each pixel represents one point of light. There a lot of possible ways of describing a point of light. Physics students might think of wavelength and amplitude, but digital systems have taken their lead from the human visual system which has receptors for different wavelengths of light, and commonly represents them using the magnitudes of their red, green and blue components. Thus each pixel can be represented by a three-tuple: (R, G, B). We\u2019ll simplify things further and only work with \u201cblack and white\u201d (actually grey scale, or monochrome) images, so our pixels will be represented by a single number giving their brightness or luminance.","title":"Introduction"},{"location":"10.2_IP_1/01_Introduction/#introduction","text":"For our last problem domain of the term, we\u2019ll take a look at image processing. Not a formal introduction to digital image processing, since to do that justice would take more mathematical background that you have at the moment. Instead we\u2019ll cherry pick a few interesting problems that are also accessible. A digital image is a two-dimensional array of pixels. Pixel stands for \u201cpicture element\u201d, and each pixel represents one point of light. There a lot of possible ways of describing a point of light. Physics students might think of wavelength and amplitude, but digital systems have taken their lead from the human visual system which has receptors for different wavelengths of light, and commonly represents them using the magnitudes of their red, green and blue components. Thus each pixel can be represented by a three-tuple: (R, G, B). We\u2019ll simplify things further and only work with \u201cblack and white\u201d (actually grey scale, or monochrome) images, so our pixels will be represented by a single number giving their brightness or luminance.","title":"Introduction"},{"location":"10.2_IP_1/02_PIL/","text":"pillow: The Python Imaging Library If we want to work with an image the first job is to read it in. Thinking back to the Game of Life you can probably imagine that there are multiple ways of storing an image on disk, and you\u2019d be right. Common formats include PNG, JPEG, BMP, and GIF but there are many more (e.g. Wikipedia list ). We don\u2019t want to write low level code to read the format, so we\u2019ll use a library to do that for us. Python has more than one option, but we\u2019ll use the Python Imaging Library (pillow) . This means you\u2019ll need to install it using pip: pip install pillow . You\u2019ll know you have successfully installed it when this one-line program runs without error: from PIL import Image These notes will show you the subset of pillow operations we\u2019ll be using but if you want to explore the Python Imaging Library Handbook is quite thorough. PIL is a \u201csmall\u201d library, but we\u2019ll barely scratch the surface of what it offers.","title":"pillow: The Python Imaging Library"},{"location":"10.2_IP_1/02_PIL/#pillow-the-python-imaging-library","text":"If we want to work with an image the first job is to read it in. Thinking back to the Game of Life you can probably imagine that there are multiple ways of storing an image on disk, and you\u2019d be right. Common formats include PNG, JPEG, BMP, and GIF but there are many more (e.g. Wikipedia list ). We don\u2019t want to write low level code to read the format, so we\u2019ll use a library to do that for us. Python has more than one option, but we\u2019ll use the Python Imaging Library (pillow) . This means you\u2019ll need to install it using pip: pip install pillow . You\u2019ll know you have successfully installed it when this one-line program runs without error: from PIL import Image These notes will show you the subset of pillow operations we\u2019ll be using but if you want to explore the Python Imaging Library Handbook is quite thorough. PIL is a \u201csmall\u201d library, but we\u2019ll barely scratch the surface of what it offers.","title":"pillow: The Python Imaging Library"},{"location":"10.2_IP_1/03_Test_images/","text":"Test Images We\u2019ll also need some images to work with. Here are a few (you can also use photographs you have taken, or images you find on the web): Blocks world: 3blks1.png , shapes2.png , allblcks.png , bcrbohsp.png . Textures: 512test2.png . Nature: boulder.png , wave-cld.png . Misc: calcium.png , fngrprnt.png , Bikesgray.png . People: Che_GS.png , faces1.png . Animals: zebras.png , penguins.png . 3blks1.png\\ shapes2.png\\ allblcks.png\\ bcrbohsp.png\\ 512test2.png\\ boulder.png\\ wave-cld.png\\ calcium.png\\ fngrprnt.png\\ Bikesgray.png\\ Che_GS.png\\ faces1.png\\ zebras.png\\ penguins.png\\","title":"Test Images"},{"location":"10.2_IP_1/03_Test_images/#test-images","text":"We\u2019ll also need some images to work with. Here are a few (you can also use photographs you have taken, or images you find on the web): Blocks world: 3blks1.png , shapes2.png , allblcks.png , bcrbohsp.png . Textures: 512test2.png . Nature: boulder.png , wave-cld.png . Misc: calcium.png , fngrprnt.png , Bikesgray.png . People: Che_GS.png , faces1.png . Animals: zebras.png , penguins.png . 3blks1.png\\ shapes2.png\\ allblcks.png\\ bcrbohsp.png\\ 512test2.png\\ boulder.png\\ wave-cld.png\\ calcium.png\\ fngrprnt.png\\ Bikesgray.png\\ Che_GS.png\\ faces1.png\\ zebras.png\\ penguins.png\\","title":"Test Images"},{"location":"10.2_IP_1/04_IPO/","text":"IPO Programming With pillow installed and some test images to play with we can move on to image processing. In its overall structure image processing turns out to be a throwback to the beginning of CPSC 128 where we did IPO or Input, Processing, Output, programming. We\u2019ll need to input images, process them, and then output the processed result. Input Reading in an image: from PIL import Image im = Image.open(\"penguins.png\") # Opens the file and returns an image object. im = im.convert(\"L\") # Convert to a greyscale image. Processing Now to work with the image we\u2019ll need to be able to manipulate the pixel values. To do this PIL provides pixel map access objects\u201d. # pix is a \"pixel map access object\" for the image named im. pix = im.load() pix gives us direct access to the pixel values in the image similar to the way u.cells gave us acess to the cell values in a life universe. For a greyscale image the values in pix will range from 0 for black, to 255 for white, with numbers in between representing shades of grey. The notation we use with pix is slightly differently from u.cells though, e.g. to display the pixel values of the 10 \u00d7 10 region of pixels in the upper left corner of the image: # pix coordinate system is [x, y], # with [0, 0] in the upper left corner of the image, # x measuring across the image, and y down the image. for x in range(10): for y in range(10): print(pix[x,y], end= ' ') print() The key thing to notice is that we have to use the notation pix[x, y] not pix[x][y] . Other than that we can treat our pixel map access objects\u201d like pix as though they were lists of lists. The output from the code above is: 162 155 155 162 164 158 136 107 86 125 168 168 164 164 166 162 142 109 88 123 171 164 164 175 179 171 144 109 94 133 181 171 169 182 179 166 153 125 90 127 181 184 188 190 182 168 153 131 105 145 177 186 186 184 181 173 158 136 110 145 181 186 186 182 177 169 153 131 112 147 182 184 182 179 175 175 168 149 116 134 173 175 177 175 173 173 173 160 129 142 160 158 158 164 168 171 177 168 140 145 (This might remind you of the topography problem in CPSC 128 , and indeed in mathematical terms it is the same.) Output Having read our image in, let\u2019s process it and output the result. print(im.size) # im.size is a tuple giving the size of image (cols,rows) for x in range(im.size[0]): for y in range(im.size[1]): pix[x,y] = tuple(num//2 for num in pix[x,y]) im.save(\"dkpenguins.png\") print('Done.') Note that pillow will try to guess the file format to write based on the filename suffix (in this case png). You can also provide a format argument to specify the desired format. Here are the before and after images: As you can see, the effect of dividing each pixel value by 2 was to decrease all the pixel values and thus darken the image.","title":"IPO Programming"},{"location":"10.2_IP_1/04_IPO/#ipo-programming","text":"With pillow installed and some test images to play with we can move on to image processing. In its overall structure image processing turns out to be a throwback to the beginning of CPSC 128 where we did IPO or Input, Processing, Output, programming. We\u2019ll need to input images, process them, and then output the processed result.","title":"IPO Programming"},{"location":"10.2_IP_1/04_IPO/#input","text":"Reading in an image: from PIL import Image im = Image.open(\"penguins.png\") # Opens the file and returns an image object. im = im.convert(\"L\") # Convert to a greyscale image.","title":"Input"},{"location":"10.2_IP_1/04_IPO/#processing","text":"Now to work with the image we\u2019ll need to be able to manipulate the pixel values. To do this PIL provides pixel map access objects\u201d. # pix is a \"pixel map access object\" for the image named im. pix = im.load() pix gives us direct access to the pixel values in the image similar to the way u.cells gave us acess to the cell values in a life universe. For a greyscale image the values in pix will range from 0 for black, to 255 for white, with numbers in between representing shades of grey. The notation we use with pix is slightly differently from u.cells though, e.g. to display the pixel values of the 10 \u00d7 10 region of pixels in the upper left corner of the image: # pix coordinate system is [x, y], # with [0, 0] in the upper left corner of the image, # x measuring across the image, and y down the image. for x in range(10): for y in range(10): print(pix[x,y], end= ' ') print() The key thing to notice is that we have to use the notation pix[x, y] not pix[x][y] . Other than that we can treat our pixel map access objects\u201d like pix as though they were lists of lists. The output from the code above is: 162 155 155 162 164 158 136 107 86 125 168 168 164 164 166 162 142 109 88 123 171 164 164 175 179 171 144 109 94 133 181 171 169 182 179 166 153 125 90 127 181 184 188 190 182 168 153 131 105 145 177 186 186 184 181 173 158 136 110 145 181 186 186 182 177 169 153 131 112 147 182 184 182 179 175 175 168 149 116 134 173 175 177 175 173 173 173 160 129 142 160 158 158 164 168 171 177 168 140 145 (This might remind you of the topography problem in CPSC 128 , and indeed in mathematical terms it is the same.)","title":"Processing"},{"location":"10.2_IP_1/04_IPO/#output","text":"Having read our image in, let\u2019s process it and output the result. print(im.size) # im.size is a tuple giving the size of image (cols,rows) for x in range(im.size[0]): for y in range(im.size[1]): pix[x,y] = tuple(num//2 for num in pix[x,y]) im.save(\"dkpenguins.png\") print('Done.') Note that pillow will try to guess the file format to write based on the filename suffix (in this case png). You can also provide a format argument to specify the desired format. Here are the before and after images: As you can see, the effect of dividing each pixel value by 2 was to decrease all the pixel values and thus darken the image.","title":"Output"},{"location":"10.2_IP_1/05_Point_vs_neighbourhood/","text":"Point vs Neighbourhood Processes Darkening the penguin image was an example of a point operation . Point operations depend only a single pixel value and affect only that same pixel\u2019s value. That means that point operations can process each pixel individually without worrying about their neighbours. (It also makes them ideal candidates for parallelization if have a computer with thousands of processors). In contrast many image processing operations work on neighbourhoods of pixels. Edge detection is an example of this.","title":"Point vs Neighbourhood Processes"},{"location":"10.2_IP_1/05_Point_vs_neighbourhood/#point-vs-neighbourhood-processes","text":"Darkening the penguin image was an example of a point operation . Point operations depend only a single pixel value and affect only that same pixel\u2019s value. That means that point operations can process each pixel individually without worrying about their neighbours. (It also makes them ideal candidates for parallelization if have a computer with thousands of processors). In contrast many image processing operations work on neighbourhoods of pixels. Edge detection is an example of this.","title":"Point vs Neighbourhood Processes"},{"location":"10.2_IP_1/06_Edge_detection/","text":"Edge Detection Edge detection is a first step in many machine vision systems. The idea is to identify the edges in the image and to use these edges as the basis for object recognition algorithms. What does \u201cedge\u201d mean in this context? It means the visual edge between two regions of an image. Thinking back to the topography assignment in CPSC 128, edges are cliffs. At the visual boundary of a penguin\u2019s back against the background we will have a patch of black pixels next to a patch of light grey ones. The strength of the edge is like the height of the cliff. This suggests that we can measure the strength of the edge at a point by finding the difference between the pixel values on its left and those on its right. In order to get at the idea that an edge has a length to it, we will subtract not just the immediately adjacent pixel values but also the ones above and below. In image processing these operations are often described using a mask . In this case the mask corresponding to measuring vertical edge strength would be: -1 0 1 -1 0 1 -1 0 1 If the pixel in the center of the mask is pix[x,y] then this mask tells us to perform this calculation in Python: dx = -1 * pix[x-1, y-1] + 0 * pix[x, y-1] + 1 * pix[x+1, y-1] \\ -1 * pix[x-1, y ] + 0 * pix[x, y ] + 1 * pix[x+1, y ] \\ -1 * pix[x-1, y+1] + 0 * pix[x, y+1] + 1 * pix[x+1, y+1] The 0s and 1s are only included for clarity and wouldn\u2019t be included in an actual program. A similar mask can be used to measure horizontal edge strength: -1 -1 -1 0 0 0 1 1 1 Now as in the game of life where we couldn\u2019t change cell states as we ran through the universe aging cells, we can\u2019t change pixel values as we go through the image because those changes would affect the results for the neighbouring cells we haven\u2019t reached yet. The solution is the same here as it was in the game of life: we write the new values into a ~~parallel universe~~ new image. Here\u2019s the Python code to do this: from PIL import Image im = Image.open(\"Bikesgray.png\") # Open the file and returns an image object. im = im.convert(\"L\") # Convert to a greyscale image. pix = im.load() # Load the image pixel map for easy access # Create new images to hold horizontal and vertical edge strength values. # dx for horizontal edge strengths. dx = Image.new(\"L\", im.size) # On creation dx is filled with 0s. dxpix = dx.load() # dy for vertical edge strengths. dy = Image.new(\"L\", im.size) dypix = dy.load() for x in range(1, im.size[0]-1): # Q: Why does this start at 1 and not 0? for y in range(1, im.size[1]-1): # Q: Why does this go to im.size[1]-1 and not im.size[1]? dxpix[x,y] = pix[x+1, y-1]+ pix[x+1, y] + pix[x+1, y+1] \\ - pix[x-1, y] - pix[x-1, y-1] - pix[x-1,y+1] dypix[x,y] = pix[x-1, y+1]+ pix[x, y+1] + pix[x+1, y+1] \\ - pix[x-1, y-1] - pix[x, y-1] - pix[x+1,y-1] dx.save('dx.png') dy.save('dy.png') print('Done.') And here\u2019s the result for a new image (chosen because it has strong horizontal and vertical edges). First the new image: And now the output, dx on the left and dy on the right (scaled down in size so you can see them side-by-side): You can see that each mask favours (or detects) edges in the specific orientations we would expect, e.g. either the tops or the bottoms of the bricks, and either the top or the sides of the curved metal bike rack.","title":"Edge Detection"},{"location":"10.2_IP_1/06_Edge_detection/#edge-detection","text":"Edge detection is a first step in many machine vision systems. The idea is to identify the edges in the image and to use these edges as the basis for object recognition algorithms. What does \u201cedge\u201d mean in this context? It means the visual edge between two regions of an image. Thinking back to the topography assignment in CPSC 128, edges are cliffs. At the visual boundary of a penguin\u2019s back against the background we will have a patch of black pixels next to a patch of light grey ones. The strength of the edge is like the height of the cliff. This suggests that we can measure the strength of the edge at a point by finding the difference between the pixel values on its left and those on its right. In order to get at the idea that an edge has a length to it, we will subtract not just the immediately adjacent pixel values but also the ones above and below. In image processing these operations are often described using a mask . In this case the mask corresponding to measuring vertical edge strength would be: -1 0 1 -1 0 1 -1 0 1 If the pixel in the center of the mask is pix[x,y] then this mask tells us to perform this calculation in Python: dx = -1 * pix[x-1, y-1] + 0 * pix[x, y-1] + 1 * pix[x+1, y-1] \\ -1 * pix[x-1, y ] + 0 * pix[x, y ] + 1 * pix[x+1, y ] \\ -1 * pix[x-1, y+1] + 0 * pix[x, y+1] + 1 * pix[x+1, y+1] The 0s and 1s are only included for clarity and wouldn\u2019t be included in an actual program. A similar mask can be used to measure horizontal edge strength: -1 -1 -1 0 0 0 1 1 1 Now as in the game of life where we couldn\u2019t change cell states as we ran through the universe aging cells, we can\u2019t change pixel values as we go through the image because those changes would affect the results for the neighbouring cells we haven\u2019t reached yet. The solution is the same here as it was in the game of life: we write the new values into a ~~parallel universe~~ new image. Here\u2019s the Python code to do this: from PIL import Image im = Image.open(\"Bikesgray.png\") # Open the file and returns an image object. im = im.convert(\"L\") # Convert to a greyscale image. pix = im.load() # Load the image pixel map for easy access # Create new images to hold horizontal and vertical edge strength values. # dx for horizontal edge strengths. dx = Image.new(\"L\", im.size) # On creation dx is filled with 0s. dxpix = dx.load() # dy for vertical edge strengths. dy = Image.new(\"L\", im.size) dypix = dy.load() for x in range(1, im.size[0]-1): # Q: Why does this start at 1 and not 0? for y in range(1, im.size[1]-1): # Q: Why does this go to im.size[1]-1 and not im.size[1]? dxpix[x,y] = pix[x+1, y-1]+ pix[x+1, y] + pix[x+1, y+1] \\ - pix[x-1, y] - pix[x-1, y-1] - pix[x-1,y+1] dypix[x,y] = pix[x-1, y+1]+ pix[x, y+1] + pix[x+1, y+1] \\ - pix[x-1, y-1] - pix[x, y-1] - pix[x+1,y-1] dx.save('dx.png') dy.save('dy.png') print('Done.') And here\u2019s the result for a new image (chosen because it has strong horizontal and vertical edges). First the new image: And now the output, dx on the left and dy on the right (scaled down in size so you can see them side-by-side): You can see that each mask favours (or detects) edges in the specific orientations we would expect, e.g. either the tops or the bottoms of the bricks, and either the top or the sides of the curved metal bike rack.","title":"Edge Detection"},{"location":"11.1_Pitcher_Problems/00_index/","text":"Pitcher Problems: A Case Study in Using Search Trees The problem First: Do it by hand Second: Notice what you did Third: Identify the problem type Formalize the Algorithm Pseudocode An edge case leads to a refinement Towards Python: A little OOP Further towards Python: Pseudocode translation Debugging is_goal() Interlude: Bitwise operations (really just & ) Back to our program: is_goal() Final program","title":"Contents"},{"location":"11.1_Pitcher_Problems/00_index/#pitcher-problems-a-case-study-in-using-search-trees","text":"The problem First: Do it by hand Second: Notice what you did Third: Identify the problem type Formalize the Algorithm Pseudocode An edge case leads to a refinement Towards Python: A little OOP Further towards Python: Pseudocode translation Debugging is_goal() Interlude: Bitwise operations (really just & ) Back to our program: is_goal() Final program","title":"Pitcher Problems: A Case Study in Using Search Trees"},{"location":"11.1_Pitcher_Problems/01_The_problem/","text":"Pitcher problems Simple : You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d Simple : You are at the side of a river. You have a two-litre pitcher, a five-litre pitcher, and a ten-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need one litre of water. How can you measure one litre?\u201d Medium : You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need two liters of water. How can you measure two liters?\u201d","title":"Pitcher problems"},{"location":"11.1_Pitcher_Problems/01_The_problem/#pitcher-problems","text":"Simple : You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d Simple : You are at the side of a river. You have a two-litre pitcher, a five-litre pitcher, and a ten-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need one litre of water. How can you measure one litre?\u201d Medium : You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need two liters of water. How can you measure two liters?\u201d","title":"Pitcher problems"},{"location":"11.1_Pitcher_Problems/02_By_hand/","text":"First: Do it by hand Thinking back to CPSC 128 the first step in writing a program to solve a problem is to be sure we know how to solve it ourselves. A good way to ensure we do is to do the problem by hand first, so let\u2019s try solving some pitcher problems. (Hopefully the pitcher problems tweaked your interest and you tried solving one or more of them already.) The first one is, You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d The answer to this one pops out to most people because they notice that the difference between seven and three is four, so: Fill the seven-litre pitcher from the river. Fill the three-litre pitcher form the seven-litre pitcher. This leaves four liters of water in the seven-litre pitcher. The second problem is, You are at the side of a river. You have a two-litre pitcher, a five-litre pitcher, and a ten-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need one litre of water. How can you measure one litre?\u201d We can use the same strategy as before, i.e. fill a big pitcher and then pour out known amounts leaving the amount we are after: Fill the five-litre pitcher from the river. Fill the two-litre pitcher from the five-litre pitcher. Empty the two-litre pitcher into the river. Fill the two-litre pitcher from the five-litre pitcher (again). Now there is one litre of water left in the five-litre pitcher. What about the third problem? You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need two liters of water. How can you measure two liters?\u201d The exact same strategy won\u2019t work this time because if we fill the larger seven-litre pitcher we can only empty by three liters at a time enabling us to get four liters (after one emptying) or one litre (after the second emptying). So how do we get two liters? A little trial and error should lead us to a solution: Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Now there are two liters left in the three-litre pitcher.","title":"First: Do it by hand"},{"location":"11.1_Pitcher_Problems/02_By_hand/#first-do-it-by-hand","text":"Thinking back to CPSC 128 the first step in writing a program to solve a problem is to be sure we know how to solve it ourselves. A good way to ensure we do is to do the problem by hand first, so let\u2019s try solving some pitcher problems. (Hopefully the pitcher problems tweaked your interest and you tried solving one or more of them already.) The first one is, You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d The answer to this one pops out to most people because they notice that the difference between seven and three is four, so: Fill the seven-litre pitcher from the river. Fill the three-litre pitcher form the seven-litre pitcher. This leaves four liters of water in the seven-litre pitcher. The second problem is, You are at the side of a river. You have a two-litre pitcher, a five-litre pitcher, and a ten-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need one litre of water. How can you measure one litre?\u201d We can use the same strategy as before, i.e. fill a big pitcher and then pour out known amounts leaving the amount we are after: Fill the five-litre pitcher from the river. Fill the two-litre pitcher from the five-litre pitcher. Empty the two-litre pitcher into the river. Fill the two-litre pitcher from the five-litre pitcher (again). Now there is one litre of water left in the five-litre pitcher. What about the third problem? You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need two liters of water. How can you measure two liters?\u201d The exact same strategy won\u2019t work this time because if we fill the larger seven-litre pitcher we can only empty by three liters at a time enabling us to get four liters (after one emptying) or one litre (after the second emptying). So how do we get two liters? A little trial and error should lead us to a solution: Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Fill the three-litre pitcher from the river. Pour from the three-litre pitcher into the seven-litre pitcher. Now there are two liters left in the three-litre pitcher.","title":"First: Do it by hand"},{"location":"11.1_Pitcher_Problems/03_Notice_what_you_did/","text":"Second: Notice what you did Hopefully you have noticed some characteristics of these problems: The number of steps it takes to get to a solution varies. There are only a few actions that can be taken: filling a pitcher, pouring from one pitcher to another, and emptying a pitcher into the river. A few less obvious characteristics: There may be more than one way to solve the problem, e.g. problem two could also be solved like this: 1) Fill the ten-litre pitcher, 2) pour from it into the five-litre pitcher, 3) pour from it into the two-litre pitcher, 4) empty the two-litre pitcher into the river, 5) pour from the ten-litre pitcher again into the two-litre pitcher. Now there is one litre of water left in the ten-litre pitcher. This solution is longer than the one we saw before, and we naturally prefer shorter solutions, so let\u2019s agree that we would like the shortest solution possible. There may be no solution, e.g. Given a five-litre pitcher and a ten-litre pitcher measure one litre of water.\u201d A solution may involve more than one pitcher, e.g. the problem You have a three-litre pitcher and a seven-litre pitcher. You need ten litres of water.\u201d The solution is to fill them both, and now have you have the required ten liters of water in both pitchers combined.","title":"Second: Notice what you did"},{"location":"11.1_Pitcher_Problems/03_Notice_what_you_did/#second-notice-what-you-did","text":"Hopefully you have noticed some characteristics of these problems: The number of steps it takes to get to a solution varies. There are only a few actions that can be taken: filling a pitcher, pouring from one pitcher to another, and emptying a pitcher into the river. A few less obvious characteristics: There may be more than one way to solve the problem, e.g. problem two could also be solved like this: 1) Fill the ten-litre pitcher, 2) pour from it into the five-litre pitcher, 3) pour from it into the two-litre pitcher, 4) empty the two-litre pitcher into the river, 5) pour from the ten-litre pitcher again into the two-litre pitcher. Now there is one litre of water left in the ten-litre pitcher. This solution is longer than the one we saw before, and we naturally prefer shorter solutions, so let\u2019s agree that we would like the shortest solution possible. There may be no solution, e.g. Given a five-litre pitcher and a ten-litre pitcher measure one litre of water.\u201d A solution may involve more than one pitcher, e.g. the problem You have a three-litre pitcher and a seven-litre pitcher. You need ten litres of water.\u201d The solution is to fill them both, and now have you have the required ten liters of water in both pitchers combined.","title":"Second: Notice what you did"},{"location":"11.1_Pitcher_Problems/04_Identify_the_problem_type/","text":"Third: Identify the problem type What kind of problem is this? Put another way, what problem we have seen before is this one like? Well it\u2019s not a calculation or formula problem. We find the answer not by using some equations, but by trying out different operations. In this way it is like brute-force problems we have seen where our approach has been to try all possible combinations of filling and pouring, and checking after each one to see if we have solved the problem yet. So it\u2019s a bit like the cryptarithm problem, and a bit like maze carving, but not exactly like either of them.","title":"Third: Identify the problem type"},{"location":"11.1_Pitcher_Problems/04_Identify_the_problem_type/#third-identify-the-problem-type","text":"What kind of problem is this? Put another way, what problem we have seen before is this one like? Well it\u2019s not a calculation or formula problem. We find the answer not by using some equations, but by trying out different operations. In this way it is like brute-force problems we have seen where our approach has been to try all possible combinations of filling and pouring, and checking after each one to see if we have solved the problem yet. So it\u2019s a bit like the cryptarithm problem, and a bit like maze carving, but not exactly like either of them.","title":"Third: Identify the problem type"},{"location":"11.1_Pitcher_Problems/05_Formalize_the_algorithm/","text":"Formalize the Algorithm Let\u2019s think a bit about how the process of trying all combinations\u201d of actions might play out. We\u2019ll start with the first problem, You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d Remember our possible actions are: fill , pour and empty . Since the pitchers are empty we can\u2019t pour from or empty them, but we can fill them, so we have two possible actions: fill the three-litre pitcher, or fill the seven-litre pitcher. Each of those results in a new state of the pitchers: You can see I\u2019ve introduced some notation here. The pairs of numbers in the ovals represent the number of litres of water in each pitcher, listed in order of pitcher size, smaller pitcher first. Now neither of those ovals features a 4, the amount we are aiming for, so we are not done. Let\u2019s consider our next possible actions. From the state 3,0 we could; empty the three-litre pitcher, pour from the three-litre pitcher into the seven-litre pitcher, or fill the seven-litre pitcher. And now you can see what we\u2019ve got! We\u2019re building a tree of possibilities. From each state, taking each of the possible actions extends the tree downwards into new states. We\u2019ll be done when one of those states contains a 4 (or thinking back to our earlier observation of multi-pitcher solutions when a subset of our states adds to 4). There\u2019s no 4 in any of the states we\u2019ve reached so far so we\u2019re not done. But now the question arises, how shall we grow our tree? Should we continue down the left-hand side and expand on the 0,0 state, or move over to the right branch and continue from the 0,7 state? The first strategy is called a depth-first search while the second is a breadth-first search . Depth-first means you grow as deep as it is possible to grow along one route and then if it dead-ends and is not a solution, back up and try growing another path. We\u2019ve used that approach before. For example our maze-carving algorithm grew each path until it couldn\u2019t grow any more, and then it backed up the list of visited cells and grew another path. The problem with depth-first explorations in some problems is that the path might be infinite, i.e. you might be able to grow it forever without reaching the solution. That could happen here where we could become stuck in a loop of filling then emptying then filling then emptying a pitcher (we know that\u2019s not going anywhere, but the algorithm might not). In most game-playing situations (like this one) breadth-first is the way to go. In this case that means our next step is to grow down from the 0,7 state: and we reach the solution in the state 3, 4 !","title":"Formalize the Algorithm"},{"location":"11.1_Pitcher_Problems/05_Formalize_the_algorithm/#formalize-the-algorithm","text":"Let\u2019s think a bit about how the process of trying all combinations\u201d of actions might play out. We\u2019ll start with the first problem, You are at the side of a river. You have a three-litre pitcher and a seven-litre pitcher. The pitchers do not have markings to allow measuring smaller quantities. You need four liters of water. How can you measure four liters?\u201d Remember our possible actions are: fill , pour and empty . Since the pitchers are empty we can\u2019t pour from or empty them, but we can fill them, so we have two possible actions: fill the three-litre pitcher, or fill the seven-litre pitcher. Each of those results in a new state of the pitchers: You can see I\u2019ve introduced some notation here. The pairs of numbers in the ovals represent the number of litres of water in each pitcher, listed in order of pitcher size, smaller pitcher first. Now neither of those ovals features a 4, the amount we are aiming for, so we are not done. Let\u2019s consider our next possible actions. From the state 3,0 we could; empty the three-litre pitcher, pour from the three-litre pitcher into the seven-litre pitcher, or fill the seven-litre pitcher. And now you can see what we\u2019ve got! We\u2019re building a tree of possibilities. From each state, taking each of the possible actions extends the tree downwards into new states. We\u2019ll be done when one of those states contains a 4 (or thinking back to our earlier observation of multi-pitcher solutions when a subset of our states adds to 4). There\u2019s no 4 in any of the states we\u2019ve reached so far so we\u2019re not done. But now the question arises, how shall we grow our tree? Should we continue down the left-hand side and expand on the 0,0 state, or move over to the right branch and continue from the 0,7 state? The first strategy is called a depth-first search while the second is a breadth-first search . Depth-first means you grow as deep as it is possible to grow along one route and then if it dead-ends and is not a solution, back up and try growing another path. We\u2019ve used that approach before. For example our maze-carving algorithm grew each path until it couldn\u2019t grow any more, and then it backed up the list of visited cells and grew another path. The problem with depth-first explorations in some problems is that the path might be infinite, i.e. you might be able to grow it forever without reaching the solution. That could happen here where we could become stuck in a loop of filling then emptying then filling then emptying a pitcher (we know that\u2019s not going anywhere, but the algorithm might not). In most game-playing situations (like this one) breadth-first is the way to go. In this case that means our next step is to grow down from the 0,7 state: and we reach the solution in the state 3, 4 !","title":"Formalize the Algorithm"},{"location":"11.1_Pitcher_Problems/06_Pseudocode/","text":"Pseudocode Now how do we code this tree exploration process? Let\u2019s focus first on the process of extending the tree downward from one node or state: # Given a state: for every pitcher in the state take every possible action or to be more explicit about those possible actions: # Given a state: for every pitcher in the state empty the pitcher --> new state Pour from the pitcher into the other pitcher --> new state fill the pitcher --> new state I hear you, you\u2019re already thinking some of those will be pointless, e.g. emptying an empty pitcher, or filling a full one (and indeed those pointless actions weren\u2019t included in the tree diagram above). Let\u2019s add some logic so we avoid them, # Given a state: for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> new state If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> new state If the pitcher isn't full: fill the pitcher --> new state The notation --> new state indicates that the action produces a new state of the pitchers. What do we do with that new state? Well we need to hold on to it until it\u2019s time to grow downward from it, so we\u2019ll save it in a list. # Given a state: for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist To manage a breadth-first search we\u2019ll add states to the end of the list, and remove them from the front. If we added and removed from the end we\u2019d get a depth-first search instead of breadth-first. In coding terms the two are very close. The whole process begins with a starting state 0,0 representing two empty pitchers. When we consider this state we\u2019ll add more states to the statelist, and considering them will in turn add more states to the list, and so on until we find the solution. statelist = [(0,0)] while len(statelist) > 0: state = statelist.pop(0) # remove first state from statelist for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> add new state to statelist Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist Wait a second, what about noticing when we\u2019ve got the solution? goal = 4 statelist = [(0,0)] while len(statelist) > 0 and 4 not in statelist[0]: # BUG! # BUG above: misses multi-pitcher solutions! state = statelist.pop(0) # remove first state from statelist for every pitcher in state If the pitcher isn't empty: empty the pitcher --> add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist","title":"Pseudocode"},{"location":"11.1_Pitcher_Problems/06_Pseudocode/#pseudocode","text":"Now how do we code this tree exploration process? Let\u2019s focus first on the process of extending the tree downward from one node or state: # Given a state: for every pitcher in the state take every possible action or to be more explicit about those possible actions: # Given a state: for every pitcher in the state empty the pitcher --> new state Pour from the pitcher into the other pitcher --> new state fill the pitcher --> new state I hear you, you\u2019re already thinking some of those will be pointless, e.g. emptying an empty pitcher, or filling a full one (and indeed those pointless actions weren\u2019t included in the tree diagram above). Let\u2019s add some logic so we avoid them, # Given a state: for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> new state If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> new state If the pitcher isn't full: fill the pitcher --> new state The notation --> new state indicates that the action produces a new state of the pitchers. What do we do with that new state? Well we need to hold on to it until it\u2019s time to grow downward from it, so we\u2019ll save it in a list. # Given a state: for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist To manage a breadth-first search we\u2019ll add states to the end of the list, and remove them from the front. If we added and removed from the end we\u2019d get a depth-first search instead of breadth-first. In coding terms the two are very close. The whole process begins with a starting state 0,0 representing two empty pitchers. When we consider this state we\u2019ll add more states to the statelist, and considering them will in turn add more states to the list, and so on until we find the solution. statelist = [(0,0)] while len(statelist) > 0: state = statelist.pop(0) # remove first state from statelist for every pitcher in the state If the pitcher isn't empty: empty the pitcher --> add new state to statelist Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist Wait a second, what about noticing when we\u2019ve got the solution? goal = 4 statelist = [(0,0)] while len(statelist) > 0 and 4 not in statelist[0]: # BUG! # BUG above: misses multi-pitcher solutions! state = statelist.pop(0) # remove first state from statelist for every pitcher in state If the pitcher isn't empty: empty the pitcher --> add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher --> add new state to statelist If the pitcher isn't full: fill the pitcher --> add new state to statelist","title":"Pseudocode"},{"location":"11.1_Pitcher_Problems/07_Refinement/","text":"An edge case leads to a refinement This is the basic algorithm, but we have to watch out for edge cases. One important edge case is problems that don\u2019t have a solution, like the aforementioned problem of measuring one litre given a five-litre and a ten-litre pitcher. Consider the search tree that results: After three rounds of actions we have seen all the possible states. All the new states we generate are ones we have seen before, and we know they are not solutions, so the process will not terminate and we will have an infinite loop. The solution? Remember the states we have tried, and don\u2019t add tried states to statelist . If we do that then statelist will be emptied and that will terminate the program. goal = 4 statelist = [(0,0)] tried_states = [] while len(statelist) > 0 and 4 not in statelist[0]: # BUG! # BUG above: misses multi-pitcher solutions! state = statelist.pop(0) # remove first state from statelist add state to tried_states for every pitcher in state If the pitcher isn't empty: empty the pitcher --> new state if new state not in tried_states: add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher if new state not in tried_states: add new state to statelist If the pitcher isn't full: fill the pitcher --> new state if new state not in tried_states: add new state to statelist # We end up here if it is solved, but also if it is unsolvable # so we need to check which it is: if 4 in statelist[0]: Solved! else: Unsolvable :-( By remembering states we have tried, we not only terminate instead of looping forever, we search fewer options: Correct and Efficient!","title":"An edge case leads to a refinement"},{"location":"11.1_Pitcher_Problems/07_Refinement/#an-edge-case-leads-to-a-refinement","text":"This is the basic algorithm, but we have to watch out for edge cases. One important edge case is problems that don\u2019t have a solution, like the aforementioned problem of measuring one litre given a five-litre and a ten-litre pitcher. Consider the search tree that results: After three rounds of actions we have seen all the possible states. All the new states we generate are ones we have seen before, and we know they are not solutions, so the process will not terminate and we will have an infinite loop. The solution? Remember the states we have tried, and don\u2019t add tried states to statelist . If we do that then statelist will be emptied and that will terminate the program. goal = 4 statelist = [(0,0)] tried_states = [] while len(statelist) > 0 and 4 not in statelist[0]: # BUG! # BUG above: misses multi-pitcher solutions! state = statelist.pop(0) # remove first state from statelist add state to tried_states for every pitcher in state If the pitcher isn't empty: empty the pitcher --> new state if new state not in tried_states: add new state to statelist If the other pitcher isn't full: Pour from the pitcher into the other pitcher if new state not in tried_states: add new state to statelist If the pitcher isn't full: fill the pitcher --> new state if new state not in tried_states: add new state to statelist # We end up here if it is solved, but also if it is unsolvable # so we need to check which it is: if 4 in statelist[0]: Solved! else: Unsolvable :-( By remembering states we have tried, we not only terminate instead of looping forever, we search fewer options: Correct and Efficient!","title":"An edge case leads to a refinement"},{"location":"11.1_Pitcher_Problems/08_OOP/","text":"Towards Python: A little OOP Well that pseudocode expresses our algorithm, but it is one vague, buggy mess at the moment. How to move from there to a clear, correct Python program? Let\u2019s start with a bit of OOP, and look for the nouns and verbs we\u2019ve used in our pseudocode to identify the objects and methods we need to implement to let us express the algorithm. The only objects in sight are Pitcher s. What attributes do they have? A capacity and some contents . What methods do they have? fill and empty . Any other verbs we\u2019ve used? pour . That leads directly to this code: class Pitcher: def __init__(self, capacity, contents=0): self.capacity = capacity self.contents = contents def empty(self): self.contents = 0 def fill(self): self.contents = self.capacity def __str__(self): # debugging aid return '%d of %d' % (self.contents, self.capacity) def pour(src, destn): # How much can we pour into the destination pitcher? destn_space = destn.capacity - destn.contents # How much can we pour from the source pitcher? src_avail = src.contents # The amount we transfer is the least of those two amounts. transfer = min(destn_space, src_avail) #print 'Transferring', transfer, 'liters.' # Now we simulate pouring by adjusting the amounts in each pitcher. destn.contents += transfer src.contents -= transfer if __name__ == '__main__': print 'Create pitchers 7:5 and 3:3' a = Pitcher(7,5) b = Pitcher(3,3) print a print b print 'Try pouring into a full pitcher:' pour(a,b) print a print b print 'Try pouring from 3:3 into 7:5, should pour 2 litres:' pour(b,a) print a print b print 'Empty both pitchers:' a.empty() b.empty() print a print b Running it produces some encouraging output: >>> Create pitchers 7:5 and 3:3 5 of 7 3 of 3 Try pouring into a full pitcher: Transferring 0 litres. 5 of 7 3 of 3 Try pouring from 3:3 into 7:5, should pour 2 litres: Transferring 2 litres. 7 of 7 1 of 3 Empty both pitchers: 0 of 7 0 of 3 >>>","title":"Towards Python: A little OOP"},{"location":"11.1_Pitcher_Problems/08_OOP/#towards-python-a-little-oop","text":"Well that pseudocode expresses our algorithm, but it is one vague, buggy mess at the moment. How to move from there to a clear, correct Python program? Let\u2019s start with a bit of OOP, and look for the nouns and verbs we\u2019ve used in our pseudocode to identify the objects and methods we need to implement to let us express the algorithm. The only objects in sight are Pitcher s. What attributes do they have? A capacity and some contents . What methods do they have? fill and empty . Any other verbs we\u2019ve used? pour . That leads directly to this code: class Pitcher: def __init__(self, capacity, contents=0): self.capacity = capacity self.contents = contents def empty(self): self.contents = 0 def fill(self): self.contents = self.capacity def __str__(self): # debugging aid return '%d of %d' % (self.contents, self.capacity) def pour(src, destn): # How much can we pour into the destination pitcher? destn_space = destn.capacity - destn.contents # How much can we pour from the source pitcher? src_avail = src.contents # The amount we transfer is the least of those two amounts. transfer = min(destn_space, src_avail) #print 'Transferring', transfer, 'liters.' # Now we simulate pouring by adjusting the amounts in each pitcher. destn.contents += transfer src.contents -= transfer if __name__ == '__main__': print 'Create pitchers 7:5 and 3:3' a = Pitcher(7,5) b = Pitcher(3,3) print a print b print 'Try pouring into a full pitcher:' pour(a,b) print a print b print 'Try pouring from 3:3 into 7:5, should pour 2 litres:' pour(b,a) print a print b print 'Empty both pitchers:' a.empty() b.empty() print a print b Running it produces some encouraging output: >>> Create pitchers 7:5 and 3:3 5 of 7 3 of 3 Try pouring into a full pitcher: Transferring 0 litres. 5 of 7 3 of 3 Try pouring from 3:3 into 7:5, should pour 2 litres: Transferring 2 litres. 7 of 7 1 of 3 Empty both pitchers: 0 of 7 0 of 3 >>>","title":"Towards Python: A little OOP"},{"location":"11.1_Pitcher_Problems/09_Pseudocode_translation/","text":"Further towards Python: Pseudocode translation Now let\u2019s try expressing our pseudocode using the objects and methods we\u2019ve defined. Differences of this code from our pseudocode, and coding decisions, are numbered in the code and explained in the notes below it. def solve_it(pitchers, goal): '''Solve the problem of measuring goal litres of water using the pitchers in the list pitchers. ''' state_list = [pitchers] # Initialize the state list tried_states = [] # Initialize tried_states while True: # See note 1 # # Is it time to give up? # It is if there are no more states to try. if len(state_list) == 0: break # If not, get the next state to try. # Take it from the front of the list to do breadth-first traversal. state = state_list.pop(0) # Have we figured it out? # We have if this state is a solution. if is_goal(state, goal): # See note 2 # break # If we haven't, record that we are trying this state. tried_states.append(state) # See note 3 # # # Grow tree downward from this state by # trying every action for every pitcher in it. # # Emptying: for i in range(len(state)): # See note 4 # For every pitcher (by index). new_state = copy.deepcopy(state) # See note 4 # # Give new_state[i] a more meaningful name pitcher = new_state[i] if not pitcher.is_empty(): pitcher.empty() # If this isn't a state we've tried and it isn't already in # state_list: if new_state not in tried_states \\ and new_state not in state_list: # See notes 5 and 6 # state_list.append(new_state) # Filling: for i in range(len(state)): new_state = copy.deepcopy(state) pitcher = new_state[i] if not pitcher.is_full(): pitcher.fill() if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # Pouring: # Try pouring from every pitcher into every other pitcher # (so nested loops to try all combinations). for src in range(len(state)): # index of source pitcher for dest in range(len(state)): # index of destination pitcher if src == dest: # Don't try to pour into ourself! next # See note 6 # new_state = copy.deepcopy(state) # Assign more meaningful names: (source, destination) = (new_state[src], new_state[dest]) if not source.is_empty() and not destination.is_full(): pour(source, destination) if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # We end up here if it is solved, but also if it is unsolvable if is_goal(state, goal): print 'Figured it out!' else: print 'That\u2019s an impossible problem!' Notes: state_list = [pitchers] States aren\u2019t just lists of numbers now, they are lists of Pitchers . while True: I don\u2019t often use this construction (as you have probably noticed). I prefer to be explicit about the reasons a loop may end, or to at least use while not done and then assign to done inside the loop. In this case I opted for while True so you\u2019d have see it at least once, and because it let me reduce the number of indentation levels in the body of the loop substantially. The thing to remember when you see a while True is that it is telling you to look for the break statements in the loop body because that is how the loop will be exited. if is_goal(state, goal): In the pseudocode this test was just 4 not in statelist[0] , but state_list is no longer a list of integer values (see note 0) so we\u2019ll have to look inside Pitcher objects to perform the test, plus we know we\u2019re going to have to consider combinations of Pitchers down the road. That\u2019s too much to fit in a test condition, so I created a function is_goal . The details will be hidden in there. At the moment it looks like this, python def is_goal(state, goal): ''' Determines whether state meets goal. BUG: Misses multi-pitcher solutions! ''' # Check each pitcher to see if it contains goal litres of water. for pitcher in state: if pitcher.contents == goal: return True return False tried_states.append(state) This comes earlier than it did in the pseudocode, but we need to put the state into tried_states ASAP so that we won\u2019t add it more than once to state_list . for i in range(len(state)): This is the subtle one. Why not just say for pitcher in state ? It would be certainly be easier to read. The problem is that the empty , fill and pour operations are going to change (mutate) the Pitchers in state so they won\u2019t be the same for later operations as they are for earlier ones. Instead we have to make a copy of state for each operation and let that be changed into a modified state, which we may add to state_list for further investigation. And that means we have to loop through state by index rather than by direct object reference. Note that we use copy.deepcopy to make sure we get new member objects to mutate. Without deepcopy we would still mutate the states of the Pitchers in the original list. new_state not in tried_states This is the other subtle one! The in operator will loop through tried_states trying to see if new_state is in it or not. How will it tell? By comparing new_state to each item in tried_states . Now those items are lists, and Python knows how to compare two lists, it compares them itemwise, i.e. one pair of items at a time. But those items are Pitchers , and Python doesn\u2019t know how to compare Pitchers because they are one of our types not a built-in type so we have to help it out by providing an __eq__ method in class Pitcher : python def __eq__(self, other): if type(self) == type(other): return self.capacity == other.capacity \\ and self.contents == other.contents else: return False and new_state not in state_list A subtle bug I missed first time through (good thing I had tests!). It\u2019s not enough just to make sure new_state isn\u2019t in tried_states , we also have to check that it hasn\u2019t already been created and added to state_list by an earlier operation this time through the while loop so we add the test and new_state not in state_list . Here are two versions of a program incorporating solve_it . They differ only in the verbosity of the code and output. pitcher_new_1_verbose.py has more comments and prints out a play-by-play record of what operations are being performed. I think it will be very helpful to run it on the tests one at a time to see how the program operates. Stop here and run pitcher_new_1_verbose.py a few times. Make sure you can follow how it is finding the solution. On the other hand, it is verbose and once you understand it, you won\u2019t need all those comments, and the extra print statements obscure the logic of the code a bit, so there is also pitcher_new_1_succint.py (I know, the name\u2019s not succint, but the function is) which may make a better jumping off point for further development.","title":"Further towards Python: Pseudocode translation"},{"location":"11.1_Pitcher_Problems/09_Pseudocode_translation/#further-towards-python-pseudocode-translation","text":"Now let\u2019s try expressing our pseudocode using the objects and methods we\u2019ve defined. Differences of this code from our pseudocode, and coding decisions, are numbered in the code and explained in the notes below it. def solve_it(pitchers, goal): '''Solve the problem of measuring goal litres of water using the pitchers in the list pitchers. ''' state_list = [pitchers] # Initialize the state list tried_states = [] # Initialize tried_states while True: # See note 1 # # Is it time to give up? # It is if there are no more states to try. if len(state_list) == 0: break # If not, get the next state to try. # Take it from the front of the list to do breadth-first traversal. state = state_list.pop(0) # Have we figured it out? # We have if this state is a solution. if is_goal(state, goal): # See note 2 # break # If we haven't, record that we are trying this state. tried_states.append(state) # See note 3 # # # Grow tree downward from this state by # trying every action for every pitcher in it. # # Emptying: for i in range(len(state)): # See note 4 # For every pitcher (by index). new_state = copy.deepcopy(state) # See note 4 # # Give new_state[i] a more meaningful name pitcher = new_state[i] if not pitcher.is_empty(): pitcher.empty() # If this isn't a state we've tried and it isn't already in # state_list: if new_state not in tried_states \\ and new_state not in state_list: # See notes 5 and 6 # state_list.append(new_state) # Filling: for i in range(len(state)): new_state = copy.deepcopy(state) pitcher = new_state[i] if not pitcher.is_full(): pitcher.fill() if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # Pouring: # Try pouring from every pitcher into every other pitcher # (so nested loops to try all combinations). for src in range(len(state)): # index of source pitcher for dest in range(len(state)): # index of destination pitcher if src == dest: # Don't try to pour into ourself! next # See note 6 # new_state = copy.deepcopy(state) # Assign more meaningful names: (source, destination) = (new_state[src], new_state[dest]) if not source.is_empty() and not destination.is_full(): pour(source, destination) if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # We end up here if it is solved, but also if it is unsolvable if is_goal(state, goal): print 'Figured it out!' else: print 'That\u2019s an impossible problem!' Notes: state_list = [pitchers] States aren\u2019t just lists of numbers now, they are lists of Pitchers . while True: I don\u2019t often use this construction (as you have probably noticed). I prefer to be explicit about the reasons a loop may end, or to at least use while not done and then assign to done inside the loop. In this case I opted for while True so you\u2019d have see it at least once, and because it let me reduce the number of indentation levels in the body of the loop substantially. The thing to remember when you see a while True is that it is telling you to look for the break statements in the loop body because that is how the loop will be exited. if is_goal(state, goal): In the pseudocode this test was just 4 not in statelist[0] , but state_list is no longer a list of integer values (see note 0) so we\u2019ll have to look inside Pitcher objects to perform the test, plus we know we\u2019re going to have to consider combinations of Pitchers down the road. That\u2019s too much to fit in a test condition, so I created a function is_goal . The details will be hidden in there. At the moment it looks like this, python def is_goal(state, goal): ''' Determines whether state meets goal. BUG: Misses multi-pitcher solutions! ''' # Check each pitcher to see if it contains goal litres of water. for pitcher in state: if pitcher.contents == goal: return True return False tried_states.append(state) This comes earlier than it did in the pseudocode, but we need to put the state into tried_states ASAP so that we won\u2019t add it more than once to state_list . for i in range(len(state)): This is the subtle one. Why not just say for pitcher in state ? It would be certainly be easier to read. The problem is that the empty , fill and pour operations are going to change (mutate) the Pitchers in state so they won\u2019t be the same for later operations as they are for earlier ones. Instead we have to make a copy of state for each operation and let that be changed into a modified state, which we may add to state_list for further investigation. And that means we have to loop through state by index rather than by direct object reference. Note that we use copy.deepcopy to make sure we get new member objects to mutate. Without deepcopy we would still mutate the states of the Pitchers in the original list. new_state not in tried_states This is the other subtle one! The in operator will loop through tried_states trying to see if new_state is in it or not. How will it tell? By comparing new_state to each item in tried_states . Now those items are lists, and Python knows how to compare two lists, it compares them itemwise, i.e. one pair of items at a time. But those items are Pitchers , and Python doesn\u2019t know how to compare Pitchers because they are one of our types not a built-in type so we have to help it out by providing an __eq__ method in class Pitcher : python def __eq__(self, other): if type(self) == type(other): return self.capacity == other.capacity \\ and self.contents == other.contents else: return False and new_state not in state_list A subtle bug I missed first time through (good thing I had tests!). It\u2019s not enough just to make sure new_state isn\u2019t in tried_states , we also have to check that it hasn\u2019t already been created and added to state_list by an earlier operation this time through the while loop so we add the test and new_state not in state_list . Here are two versions of a program incorporating solve_it . They differ only in the verbosity of the code and output. pitcher_new_1_verbose.py has more comments and prints out a play-by-play record of what operations are being performed. I think it will be very helpful to run it on the tests one at a time to see how the program operates. Stop here and run pitcher_new_1_verbose.py a few times. Make sure you can follow how it is finding the solution. On the other hand, it is verbose and once you understand it, you won\u2019t need all those comments, and the extra print statements obscure the logic of the code a bit, so there is also pitcher_new_1_succint.py (I know, the name\u2019s not succint, but the function is) which may make a better jumping off point for further development.","title":"Further towards Python: Pseudocode translation"},{"location":"11.1_Pitcher_Problems/10_Debugging_is_goal/","text":"Debugging is_goal() Now there\u2019s one bug we\u2019re aware of in is_goal : it doesn\u2019t consider solutions involving more than one pitcher (there may also be other bugs of course!). For example given 3 and 7 litre pitchers and the goal of measuring 10 litres it won\u2019t notice that filling both pitchers meets this goal. It is easy to extend is_goal to handle exactly two pitchers, we just add another if : if len(state) == 2: # Check total contents of both pitchers against goal if state[0].contents + state[1].contents == goal: return True We could extend to include three pitchers by adding tests for each pair of pitchers and for all three pitchers: if len(state) == 3: # Check total contents of all pairs of pitchers against goal if state[0].contents + state[1].contents == goal or \\ state[0].contents + state[2].contents == goal or \\ state[1].contents + state[2].contents == goal: return True # Check total contents of all three pitchers against goal if state[0].contents + state[1].contents + state[2].contents = goal: return True But you should have good enough programming instincts by now that you have a sinking feeling that this is not a general approach and that things will get very unwieldy with more pitchers. What might a general approach be? Well we need some way of generating all possible subsets of the Pitchers in state . The key to doing that is to appreciate the 2-ness of the problem. What 2-ness? Well any given subset either does, or does not, include each Pitcher in state , i.e. there are 2 possibilities. Thus for three items there are 2 3 , or 8, possible subsets. Here are all possible subsets of the items [A, B, C] together with a binary list showing which elements of [A, B, C] are in the subset (using 1 for presence and 0 for absence) and then a binary number representation of the binary list, and finally the binary number\u2019s decimal equivalent. Subset Binary List Binary Number Decimal Number [] 0,0,0 000 0 [C] 0,0,1 001 1 [B] 0,1,0 010 2 [B,C] 0,1,1 011 3 [A] 1,0,0 100 4 [A,C] 1,0,1 101 5 [A,B] 1,1,0 110 6 [A,B,C] 1,1,1 111 7 Now let\u2019s read this from right to left, i.e. starting with the Decimal Number and working our way across. If you ask me for subset 3, I can give it to you by looking at the binary representation of 3, which is 011, which tells me that subset 3 should contain the elements B and C from the full set, because the bits in the B and C positions are 1s, but the bit for the A position is 0. In other words each of the bits acts as a switch telling us whether or not to include one specific set member. So given a subset number we can build the subset by looking at the binary representation of that number and adding the appropriate set members to the subset But how do we look at binary representations in Python? Using its bitwise operators. Wait, what? Bitwise operators?\u201d Yes indeedy. Python provides a full set of bitwise operators and operations . We only need one of them for this problem, bitwise and\u201d implemented by the operator & .","title":"Debugging is_goal()"},{"location":"11.1_Pitcher_Problems/10_Debugging_is_goal/#debugging-is_goal","text":"Now there\u2019s one bug we\u2019re aware of in is_goal : it doesn\u2019t consider solutions involving more than one pitcher (there may also be other bugs of course!). For example given 3 and 7 litre pitchers and the goal of measuring 10 litres it won\u2019t notice that filling both pitchers meets this goal. It is easy to extend is_goal to handle exactly two pitchers, we just add another if : if len(state) == 2: # Check total contents of both pitchers against goal if state[0].contents + state[1].contents == goal: return True We could extend to include three pitchers by adding tests for each pair of pitchers and for all three pitchers: if len(state) == 3: # Check total contents of all pairs of pitchers against goal if state[0].contents + state[1].contents == goal or \\ state[0].contents + state[2].contents == goal or \\ state[1].contents + state[2].contents == goal: return True # Check total contents of all three pitchers against goal if state[0].contents + state[1].contents + state[2].contents = goal: return True But you should have good enough programming instincts by now that you have a sinking feeling that this is not a general approach and that things will get very unwieldy with more pitchers. What might a general approach be? Well we need some way of generating all possible subsets of the Pitchers in state . The key to doing that is to appreciate the 2-ness of the problem. What 2-ness? Well any given subset either does, or does not, include each Pitcher in state , i.e. there are 2 possibilities. Thus for three items there are 2 3 , or 8, possible subsets. Here are all possible subsets of the items [A, B, C] together with a binary list showing which elements of [A, B, C] are in the subset (using 1 for presence and 0 for absence) and then a binary number representation of the binary list, and finally the binary number\u2019s decimal equivalent. Subset Binary List Binary Number Decimal Number [] 0,0,0 000 0 [C] 0,0,1 001 1 [B] 0,1,0 010 2 [B,C] 0,1,1 011 3 [A] 1,0,0 100 4 [A,C] 1,0,1 101 5 [A,B] 1,1,0 110 6 [A,B,C] 1,1,1 111 7 Now let\u2019s read this from right to left, i.e. starting with the Decimal Number and working our way across. If you ask me for subset 3, I can give it to you by looking at the binary representation of 3, which is 011, which tells me that subset 3 should contain the elements B and C from the full set, because the bits in the B and C positions are 1s, but the bit for the A position is 0. In other words each of the bits acts as a switch telling us whether or not to include one specific set member. So given a subset number we can build the subset by looking at the binary representation of that number and adding the appropriate set members to the subset But how do we look at binary representations in Python? Using its bitwise operators. Wait, what? Bitwise operators?\u201d Yes indeedy. Python provides a full set of bitwise operators and operations . We only need one of them for this problem, bitwise and\u201d implemented by the operator & .","title":"Debugging is_goal()"},{"location":"11.1_Pitcher_Problems/11_Bitwise_operations/","text":"Interlude: Bitwise operations (really just & ) Bitwise-and is like doing a logical and on two values bit by bit. When the bits in the two values are both 1 the result will be 1, and when they are not both 1 (i.e. they are 0,0 or 0,1 or 1,0) it will be 0. It makes sense if you think of 1 as True and 0 as False (which Python does!). Decimal Binary 6 110 3 011 6 & 3 = 2 010 We can verify that 6 & 3 is 2 using the Python shell: >>> 6 & 3 2 >>> So, bitwise-and tells us what bits are 1 in both values. How can we use this in our problem? Well we want to know which of the elements in the full set [A, B, C] to include in a subset, and the 1 bits in the binary representation of the subset number tell us which ones those are, and bitwise-and lets us read those bits. Here\u2019s how, fullset = ['A', 'B', 'C'] subset_num = 6 # i.e. 110 or the subset with B and C* subset = [] for i in range(len(fullset)): # i.e. i in [0, 1, 2] if subset_num & (2**i): # i.e. 6 & 2^0=1 then 6 & 2^1=2 and finally 6 & 2^2=4 subset.append(fullset[i]) print subset Output: >>> ['B', 'C'] >>> And here\u2019s how that works, showing the values each time through the loop: i subset_num 2**i subset_num & (2**i) fullset[i] 0 6 1 110 & 001 = 000 = 0 i.e. False - 1 6 2 110 & 010 = 010 = 2 i.e. True B 2 6 4 110 & 100 = 100 = 4 i.e. True C So & gives us a way of asking Is the bit corresponding to this element set (i.e. 1), or not (i.e. 0)?\u201d And then appending the element when it is set, since 0 is considered False, but all non-zero numbers are considered True. The careful reader will have noticed that I have pulled a fast one here. According to our original table the code sample above should return A and B instead of B and C. The reason we get B and C is that lists and binary numbers are read in opposite directions. Lists are read left to right, but numebrs are read right to left, that is the first item in a list is the leftmost one, but the first bit in a binary number is the rightmost one. This means they map onto each other like this: -------------------- | ------------- | | | ------ | | | | | | | | [ 'A', 'B', 'C' ] 1 1 0 And that\u2019s why 110 gives us B and C, not A and B. I didn\u2019t introduce this final complication earlier because it would have made the mapping from number to list harder to understand, but since we want to test all possible subsets this difference doesn\u2019t matter because we will loop through all of them.","title":"Interlude: Bitwise operations (really just &amp;)"},{"location":"11.1_Pitcher_Problems/11_Bitwise_operations/#interlude-bitwise-operations-really-just","text":"Bitwise-and is like doing a logical and on two values bit by bit. When the bits in the two values are both 1 the result will be 1, and when they are not both 1 (i.e. they are 0,0 or 0,1 or 1,0) it will be 0. It makes sense if you think of 1 as True and 0 as False (which Python does!). Decimal Binary 6 110 3 011 6 & 3 = 2 010 We can verify that 6 & 3 is 2 using the Python shell: >>> 6 & 3 2 >>> So, bitwise-and tells us what bits are 1 in both values. How can we use this in our problem? Well we want to know which of the elements in the full set [A, B, C] to include in a subset, and the 1 bits in the binary representation of the subset number tell us which ones those are, and bitwise-and lets us read those bits. Here\u2019s how, fullset = ['A', 'B', 'C'] subset_num = 6 # i.e. 110 or the subset with B and C* subset = [] for i in range(len(fullset)): # i.e. i in [0, 1, 2] if subset_num & (2**i): # i.e. 6 & 2^0=1 then 6 & 2^1=2 and finally 6 & 2^2=4 subset.append(fullset[i]) print subset Output: >>> ['B', 'C'] >>> And here\u2019s how that works, showing the values each time through the loop: i subset_num 2**i subset_num & (2**i) fullset[i] 0 6 1 110 & 001 = 000 = 0 i.e. False - 1 6 2 110 & 010 = 010 = 2 i.e. True B 2 6 4 110 & 100 = 100 = 4 i.e. True C So & gives us a way of asking Is the bit corresponding to this element set (i.e. 1), or not (i.e. 0)?\u201d And then appending the element when it is set, since 0 is considered False, but all non-zero numbers are considered True. The careful reader will have noticed that I have pulled a fast one here. According to our original table the code sample above should return A and B instead of B and C. The reason we get B and C is that lists and binary numbers are read in opposite directions. Lists are read left to right, but numebrs are read right to left, that is the first item in a list is the leftmost one, but the first bit in a binary number is the rightmost one. This means they map onto each other like this: -------------------- | ------------- | | | ------ | | | | | | | | [ 'A', 'B', 'C' ] 1 1 0 And that\u2019s why 110 gives us B and C, not A and B. I didn\u2019t introduce this final complication earlier because it would have made the mapping from number to list harder to understand, but since we want to test all possible subsets this difference doesn\u2019t matter because we will loop through all of them.","title":"Interlude: Bitwise operations (really just &amp;)"},{"location":"11.1_Pitcher_Problems/12_is_goal/","text":"Back to our program: is_goal() In case you have forgotten during the interlude: is_goal() is supposed to look at a state and determine if it meets a goal. It could do that by having the goal amount in one of the pitchers, or by having the contents of any group of pitchers in state add to the goal amount. That means we can see if the goal is met by looking at the total amount of water in each subset of the pitchers in state . Doing this will include individual pitcher solutions we were already testing for since single pitchers are just the subsets with exactly one element (i.e. 100, 010 and 001), but also include all combinations of multiple pitchers. def subset_x(lst, x): ''' return subset number x of the items in lst see the numbering in the earlier table to interpret x ''' subset = [] for i in range(len(lst)): # Check to see if bit corresponding to item i is set in x. if x & (2**i): subset.append(lst[i]) return subset def is_goal(state, goal): ''' Does any subset of pitchers in state contain the goal amount? ''' # Check each subset of state. There are 2**len(state) possible subsets. for subset_num in range(1, 2**len(state)): # Q: why start at 1? subset = subset_x(state, subset_num) total = 0 for pitcher in subset: total += pitcher.contents if total == goal: return True return False","title":"Back to our program: is_goal()"},{"location":"11.1_Pitcher_Problems/12_is_goal/#back-to-our-program-is_goal","text":"In case you have forgotten during the interlude: is_goal() is supposed to look at a state and determine if it meets a goal. It could do that by having the goal amount in one of the pitchers, or by having the contents of any group of pitchers in state add to the goal amount. That means we can see if the goal is met by looking at the total amount of water in each subset of the pitchers in state . Doing this will include individual pitcher solutions we were already testing for since single pitchers are just the subsets with exactly one element (i.e. 100, 010 and 001), but also include all combinations of multiple pitchers. def subset_x(lst, x): ''' return subset number x of the items in lst see the numbering in the earlier table to interpret x ''' subset = [] for i in range(len(lst)): # Check to see if bit corresponding to item i is set in x. if x & (2**i): subset.append(lst[i]) return subset def is_goal(state, goal): ''' Does any subset of pitchers in state contain the goal amount? ''' # Check each subset of state. There are 2**len(state) possible subsets. for subset_num in range(1, 2**len(state)): # Q: why start at 1? subset = subset_x(state, subset_num) total = 0 for pitcher in subset: total += pitcher.contents if total == goal: return True return False","title":"Back to our program: is_goal()"},{"location":"11.1_Pitcher_Problems/13_Final_program/","text":"Final program Putting all the pieces together we have pitcher_new_2_succint.py : # pitcher_new_2_succint.py import copy class Pitcher: def __init__(self, capacity, contents=0): self.capacity = capacity self.contents = contents def empty(self): self.contents = 0 def fill(self): self.contents = self.capacity def __str__(self): # debugging aid return '%d/%d' % (self.contents, self.capacity) def __eq__(self, other): if type(self) == type(other): return self.capacity == other.capacity \\ and self.contents == other.contents else: return False def is_full(self): # Convenience function to make code more readable. return self.capacity == self.contents def is_empty(self): # Convenience function to make code more readable. return self.contents == 0 def pour(src, destn): destn_space = destn.capacity - destn.contents src_avail = src.contents transfer = min(destn_space, src_avail) # print 'Transferring', transfer, 'liters.' destn.contents += transfer src.contents -= transfer def subset_x(lst, x): ''' return subset number x of the items in lst ''' subset = [] for i in range(len(lst)): # Check to see if bit corresponding to item i is set in x. if x & (2**i): subset.append(lst[i]) return subset def is_goal(state, goal): ''' Does any subset of pitchers in state contain the goal amount? ''' # Check each subset of state. There are 2**len(state) possible subsets. for subset_num in range(1, 2**len(state)): subset = subset_x(state, subset_num) total = 0 for pitcher in subset: total += pitcher.contents if total == goal: return True return False # A little debugging help: def show_state_list(sl): print '\\nstate_list:' for i in range(len(sl)): print i, ':', show_state(sl[i]) print print def show_state(s): for p in s: print p, def solve_it(pitchers, goal): '''Solve the problem of measuring goal litres of water using the pitchers in the list pitchers. ''' state_list = [pitchers] # See note 0 # Initialize the state list tried_states = [] # Initialize tried_states while True: # See note 1 # # Is it time to give up? # It is if there are no more states to try. if len(state_list) == 0: break # If not, get the next state to try. # Take it from the front of the list to do breadth-first traversal. state = state_list.pop(0) # Have we figured it out? # We have if this state is a solution. if is_goal(state, goal): # See note 2 # break # If we haven't, record that we are trying this state. tried_states.append(state) # See note 3 # # # Grow tree downward from this state by # trying every action for every pitcher in it. # # Emptying: for i in range(len(state)): # See note 4 # For every pitcher (by index). new_state = copy.deepcopy(state) # See note 4 # # Give new_state[i] a more meaningful name pitcher = new_state[i] if not pitcher.is_empty(): pitcher.empty() # If this isn't a state we've tried and it isn't already in # state_list: if new_state not in tried_states \\ and new_state not in state_list: # See notes 5 and 6 # state_list.append(new_state) # Filling: for i in range(len(state)): new_state = copy.deepcopy(state) pitcher = new_state[i] if not pitcher.is_full(): pitcher.fill() if new_state not in tried_states and new_state not in state_list: state_list.append(new_state) # Pouring: # Try pouring from every pitcher into every other pitcher # (so nested loops to try all combinations). for src in range(len(state)): # index of source pitcher for dest in range(len(state)): # index of destination pitcher if src == dest: # Don't try to pour into ourself! next # See note 6 # new_state = copy.deepcopy(state) # Assign more meaningful names: (source, destination) = (new_state[src], new_state[dest]) if not source.is_empty() and not destination.is_full(): pour(source, destination) if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # We end up here if it is solved, but also if it is unsolvable if is_goal(state, goal): print 'Figured it out!' else: print 'That\u2019s an impossible problem!' if __name__ == '__main__': # Test Pitcher class: print 'Create pitchers 7:5 and 3:3' a = Pitcher(7,5) b = Pitcher(3,3) print a print b print 'Try pouring into a full pitcher:' pour(a,b) print a print b print 'Try pouring from 3:3 into 7:5, should pour 2 litres:' pour(b,a) print a print b print 'Empty both pitchers:' a.empty() b.empty() print a print b print # Test Pitcher Problem solving function solve_it: print 'Starting problems...' # Test Problem 1: Measure 4 litres using 3 and 7 litre pitchers goal = 4 # Set the goal start = [Pitcher(3,0), Pitcher(7,0)] # Start with two empty pitchers solve_it(start, goal) # Test Problem 2: Measure 1 litre using 2, 5 and 10 litre pitchers goal = 1 start = [Pitcher(2,0), Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) # Test Problem 3: Measure 2 litres using 3 and 7 litre pitchers goal = 2 start = [Pitcher(3,0), Pitcher(7,0)] solve_it(start, goal) # Test Problem 4: Impossible problem # Measure 1 litres using 5 and 10 litre pitchers goal = 1 start = [Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) # Test Problem 5: Multi-pitcher solution # Measure 10 litres using 3 and 7 litre pitchers goal = 10 start = [Pitcher(3,0), Pitcher(7,0)] solve_it(start, goal) # Test Problem 6: Multi-pitcher solution # Measure 12 litres using 2, 5 and 10 litre pitchers goal = 12 start = [Pitcher(2,0), Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) print '...done.'","title":"Final program"},{"location":"11.1_Pitcher_Problems/13_Final_program/#final-program","text":"Putting all the pieces together we have pitcher_new_2_succint.py : # pitcher_new_2_succint.py import copy class Pitcher: def __init__(self, capacity, contents=0): self.capacity = capacity self.contents = contents def empty(self): self.contents = 0 def fill(self): self.contents = self.capacity def __str__(self): # debugging aid return '%d/%d' % (self.contents, self.capacity) def __eq__(self, other): if type(self) == type(other): return self.capacity == other.capacity \\ and self.contents == other.contents else: return False def is_full(self): # Convenience function to make code more readable. return self.capacity == self.contents def is_empty(self): # Convenience function to make code more readable. return self.contents == 0 def pour(src, destn): destn_space = destn.capacity - destn.contents src_avail = src.contents transfer = min(destn_space, src_avail) # print 'Transferring', transfer, 'liters.' destn.contents += transfer src.contents -= transfer def subset_x(lst, x): ''' return subset number x of the items in lst ''' subset = [] for i in range(len(lst)): # Check to see if bit corresponding to item i is set in x. if x & (2**i): subset.append(lst[i]) return subset def is_goal(state, goal): ''' Does any subset of pitchers in state contain the goal amount? ''' # Check each subset of state. There are 2**len(state) possible subsets. for subset_num in range(1, 2**len(state)): subset = subset_x(state, subset_num) total = 0 for pitcher in subset: total += pitcher.contents if total == goal: return True return False # A little debugging help: def show_state_list(sl): print '\\nstate_list:' for i in range(len(sl)): print i, ':', show_state(sl[i]) print print def show_state(s): for p in s: print p, def solve_it(pitchers, goal): '''Solve the problem of measuring goal litres of water using the pitchers in the list pitchers. ''' state_list = [pitchers] # See note 0 # Initialize the state list tried_states = [] # Initialize tried_states while True: # See note 1 # # Is it time to give up? # It is if there are no more states to try. if len(state_list) == 0: break # If not, get the next state to try. # Take it from the front of the list to do breadth-first traversal. state = state_list.pop(0) # Have we figured it out? # We have if this state is a solution. if is_goal(state, goal): # See note 2 # break # If we haven't, record that we are trying this state. tried_states.append(state) # See note 3 # # # Grow tree downward from this state by # trying every action for every pitcher in it. # # Emptying: for i in range(len(state)): # See note 4 # For every pitcher (by index). new_state = copy.deepcopy(state) # See note 4 # # Give new_state[i] a more meaningful name pitcher = new_state[i] if not pitcher.is_empty(): pitcher.empty() # If this isn't a state we've tried and it isn't already in # state_list: if new_state not in tried_states \\ and new_state not in state_list: # See notes 5 and 6 # state_list.append(new_state) # Filling: for i in range(len(state)): new_state = copy.deepcopy(state) pitcher = new_state[i] if not pitcher.is_full(): pitcher.fill() if new_state not in tried_states and new_state not in state_list: state_list.append(new_state) # Pouring: # Try pouring from every pitcher into every other pitcher # (so nested loops to try all combinations). for src in range(len(state)): # index of source pitcher for dest in range(len(state)): # index of destination pitcher if src == dest: # Don't try to pour into ourself! next # See note 6 # new_state = copy.deepcopy(state) # Assign more meaningful names: (source, destination) = (new_state[src], new_state[dest]) if not source.is_empty() and not destination.is_full(): pour(source, destination) if new_state not in tried_states \\ and new_state not in state_list: state_list.append(new_state) # We end up here if it is solved, but also if it is unsolvable if is_goal(state, goal): print 'Figured it out!' else: print 'That\u2019s an impossible problem!' if __name__ == '__main__': # Test Pitcher class: print 'Create pitchers 7:5 and 3:3' a = Pitcher(7,5) b = Pitcher(3,3) print a print b print 'Try pouring into a full pitcher:' pour(a,b) print a print b print 'Try pouring from 3:3 into 7:5, should pour 2 litres:' pour(b,a) print a print b print 'Empty both pitchers:' a.empty() b.empty() print a print b print # Test Pitcher Problem solving function solve_it: print 'Starting problems...' # Test Problem 1: Measure 4 litres using 3 and 7 litre pitchers goal = 4 # Set the goal start = [Pitcher(3,0), Pitcher(7,0)] # Start with two empty pitchers solve_it(start, goal) # Test Problem 2: Measure 1 litre using 2, 5 and 10 litre pitchers goal = 1 start = [Pitcher(2,0), Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) # Test Problem 3: Measure 2 litres using 3 and 7 litre pitchers goal = 2 start = [Pitcher(3,0), Pitcher(7,0)] solve_it(start, goal) # Test Problem 4: Impossible problem # Measure 1 litres using 5 and 10 litre pitchers goal = 1 start = [Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) # Test Problem 5: Multi-pitcher solution # Measure 10 litres using 3 and 7 litre pitchers goal = 10 start = [Pitcher(3,0), Pitcher(7,0)] solve_it(start, goal) # Test Problem 6: Multi-pitcher solution # Measure 12 litres using 2, 5 and 10 litre pitchers goal = 12 start = [Pitcher(2,0), Pitcher(5,0), Pitcher(10,0)] solve_it(start, goal) print '...done.'","title":"Final program"},{"location":"11.2_Reporting/00_index/","text":"Data Processing: Reporting A report generation problem","title":"Contents"},{"location":"11.2_Reporting/00_index/#data-processing-reporting","text":"A report generation problem","title":"Data Processing: Reporting"},{"location":"11.2_Reporting/01_The_Problem/","text":"A Report Generation Problem Vast amounts of data are stored in the world\u2019s computer systems. Making that data accessible is a first step to solving many problems we face, but humans are poor data processors. On the other hand we are excellent information processors. A first step in making data meaningful to people is to transform it into information. This begins with formatting it for viewing, and progresses through visualizations which let us see at a glance what the data is saying, to interactive simulations that let us ask what-if questions and play out scenarios. I apologize if I\u2019ve got you excited thinking about visualizations and simulation, because in this unit we\u2019re going to work on the more prosaic first step: Neatly tabulating and summarizing raw data. What we have is a file whose contents are formatted like this, Asia:Japan:120:144 North America:Mexico:78:762 Europe:England:56:94 Asia:USSR:275:8649 Europe:Germany:61:96 South America:Brasil:134:3286 North America:USA:237:3615 Asia:China:1032:3705 North America:Canada:25:3852 Europe:France:55:211 Asia:India:746:1267 but what we\u2019d like is a report that looks like this: CONTINENT COUNTRY POPULATION AREA POP. DEN. (,000,000s) (,000s MI^2) (POP./MI^2) Asia China 1032 3705 278.5 India 746 1267 588.8 Japan 120 144 833.3 USSR 275 8649 31.8 ---- ----- Total 2173 13765 Europe England 56 94 595.7 France 55 211 260.7 Germany 61 96 635.4 ---- ----- Total 172 401 North America Canada 25 3852 6.5 Mexico 78 762 102.4 USA 237 3615 65.6 ---- ----- Total 340 8229 South America Brasil 134 3286 40.8 ---- ----- Total 134 3286 You can see that it is much easier to scan the report and answer questions about the data than it is to scan the raw data file. The report has organized the data hierarchically from continent to country, and alphabetized the output by continent and country (helpful when looking for values in longer lists than we have here). In addition it has computed totals by continent, and population densities by country, and included those in the report enriching the raw data.","title":"A Report Generation Problem"},{"location":"11.2_Reporting/01_The_Problem/#a-report-generation-problem","text":"Vast amounts of data are stored in the world\u2019s computer systems. Making that data accessible is a first step to solving many problems we face, but humans are poor data processors. On the other hand we are excellent information processors. A first step in making data meaningful to people is to transform it into information. This begins with formatting it for viewing, and progresses through visualizations which let us see at a glance what the data is saying, to interactive simulations that let us ask what-if questions and play out scenarios. I apologize if I\u2019ve got you excited thinking about visualizations and simulation, because in this unit we\u2019re going to work on the more prosaic first step: Neatly tabulating and summarizing raw data. What we have is a file whose contents are formatted like this, Asia:Japan:120:144 North America:Mexico:78:762 Europe:England:56:94 Asia:USSR:275:8649 Europe:Germany:61:96 South America:Brasil:134:3286 North America:USA:237:3615 Asia:China:1032:3705 North America:Canada:25:3852 Europe:France:55:211 Asia:India:746:1267 but what we\u2019d like is a report that looks like this: CONTINENT COUNTRY POPULATION AREA POP. DEN. (,000,000s) (,000s MI^2) (POP./MI^2) Asia China 1032 3705 278.5 India 746 1267 588.8 Japan 120 144 833.3 USSR 275 8649 31.8 ---- ----- Total 2173 13765 Europe England 56 94 595.7 France 55 211 260.7 Germany 61 96 635.4 ---- ----- Total 172 401 North America Canada 25 3852 6.5 Mexico 78 762 102.4 USA 237 3615 65.6 ---- ----- Total 340 8229 South America Brasil 134 3286 40.8 ---- ----- Total 134 3286 You can see that it is much easier to scan the report and answer questions about the data than it is to scan the raw data file. The report has organized the data hierarchically from continent to country, and alphabetized the output by continent and country (helpful when looking for values in longer lists than we have here). In addition it has computed totals by continent, and population densities by country, and included those in the report enriching the raw data.","title":"A Report Generation Problem"},{"location":"12.1_IP_2/00_index/","text":"Image Enhancement Lab Introduction Dynamic Range Noise Filtering Sharpening","title":"Contents"},{"location":"12.1_IP_2/00_index/#image-enhancement-lab","text":"Introduction Dynamic Range Noise Filtering Sharpening","title":"Image Enhancement Lab"},{"location":"12.1_IP_2/01_Introduction/","text":"Introduction This week we\u2019ll take another dip into image processing by considering three specific operations for enhancing images: adjusting dynamic range, filtering out noise, and sharpening edges. Lab vs Lecture The following pages won\u2019t show you how to do the operations, but they will tell you what to do, so they are more like lab instructions than lectures. Following those instructions makes up the first half of the assignment!","title":"Introduction"},{"location":"12.1_IP_2/01_Introduction/#introduction","text":"This week we\u2019ll take another dip into image processing by considering three specific operations for enhancing images: adjusting dynamic range, filtering out noise, and sharpening edges.","title":"Introduction"},{"location":"12.1_IP_2/01_Introduction/#lab-vs-lecture","text":"The following pages won\u2019t show you how to do the operations, but they will tell you what to do, so they are more like lab instructions than lectures. Following those instructions makes up the first half of the assignment!","title":"Lab vs Lecture"},{"location":"12.1_IP_2/02_Dynamic_range/","text":"Dynamic Range Often we receive pictures that are dark\u201d because they were underexposed, or washed out\u201d because they were overexposed, and sometimes we create them as a result of our processing. For example: One way to enhance images like these is to increase their dynamic range. An image\u2019s dynamic range is the range of pixel values it uses. Greyscale PIL images assign each pixel a value from 0 to 255 (inclusive). The problem with the images above is that they don\u2019t take full advantage of this range. The penguin image has an upper limit far less than 255, and the moon image doesn\u2019t have any true blacks because its pixel values don\u2019t go as low as 0. The mathematical problem of dynamic range is to take an image with pixel values in the range [ a , b ] and reassign them so they use the range [0,255]. We can do that by subtracting a from each pixel value to shift the range of pixel values so it starts at 0, and then multiplying each shifted pixel value by the ratio of the maximum shifted pixel value in the image to 255. This will make the new maximum pixel value in the image be 255 (while leaving the 0 values at 0 because that\u2019s how multiplication works). What could go wrong ? Do it by hand first: Before coding it check your formula on an example. Imagine you have an image with pixel values in the range [50,100]. Your formula should turn 50 into 0 and 100 into 255. Check that it does. Watch out for integer arithmetic! Remember that integer division truncates so you might need to a) change what seems like the natural\u201d order of operations to let your numerators grow before dividing them by potentially large denominators, or alternatively b) use floating point values for some parts of calculations. For example if we get 12 out of 15 on a test and calculate our percentage grade using the obvious\u201d formula 12/15 * 100 with integer arithmetic we will get 0, because 12/15 is 0 and 0 times 100 is still 0. Instead we need either to rearrange this expression as 12 * 100 /15 to get 80 (since 12*100 = 1200 and 1200/15 = 80), or use floating point values, 12.0/15 * 100, to get 80.0 which we can then convert to 80 if we need an integer result.","title":"Dynamic Range"},{"location":"12.1_IP_2/02_Dynamic_range/#dynamic-range","text":"Often we receive pictures that are dark\u201d because they were underexposed, or washed out\u201d because they were overexposed, and sometimes we create them as a result of our processing. For example: One way to enhance images like these is to increase their dynamic range. An image\u2019s dynamic range is the range of pixel values it uses. Greyscale PIL images assign each pixel a value from 0 to 255 (inclusive). The problem with the images above is that they don\u2019t take full advantage of this range. The penguin image has an upper limit far less than 255, and the moon image doesn\u2019t have any true blacks because its pixel values don\u2019t go as low as 0. The mathematical problem of dynamic range is to take an image with pixel values in the range [ a , b ] and reassign them so they use the range [0,255]. We can do that by subtracting a from each pixel value to shift the range of pixel values so it starts at 0, and then multiplying each shifted pixel value by the ratio of the maximum shifted pixel value in the image to 255. This will make the new maximum pixel value in the image be 255 (while leaving the 0 values at 0 because that\u2019s how multiplication works). What could go wrong ? Do it by hand first: Before coding it check your formula on an example. Imagine you have an image with pixel values in the range [50,100]. Your formula should turn 50 into 0 and 100 into 255. Check that it does. Watch out for integer arithmetic! Remember that integer division truncates so you might need to a) change what seems like the natural\u201d order of operations to let your numerators grow before dividing them by potentially large denominators, or alternatively b) use floating point values for some parts of calculations. For example if we get 12 out of 15 on a test and calculate our percentage grade using the obvious\u201d formula 12/15 * 100 with integer arithmetic we will get 0, because 12/15 is 0 and 0 times 100 is still 0. Instead we need either to rearrange this expression as 12 * 100 /15 to get 80 (since 12*100 = 1200 and 1200/15 = 80), or use floating point values, 12.0/15 * 100, to get 80.0 which we can then convert to 80 if we need an integer result.","title":"Dynamic Range"},{"location":"12.1_IP_2/03_Noise_filtering/","text":"Noise Filtering Real world measurements always contain noise or errors. These errors are random perturbations of the true signal that occur in the measuring process. Systematic errors can be modelled and that model used to remove them exactly to recover the original measurement or true signal. For example if you are using a metre stick to measure things and you know that a 5 cm piece has been cut off the low end you can adjust your measurements by adding 5 cm to them, and thus get an accurate measurement. With random errors on the other hand we either don\u2019t know why or how they occurred, or we can\u2019t model the process we suspect produced them, so we can\u2019t remove them precisely. For example aerial photographs that are attempting to capture a picture of the land surface below are affected by the fact that the atmosphere between the camera and ground is neither transparent nor homogenous. Since we can\u2019t remove random error precisely we instead try to reduce its effect. In image processing this means we want to reduce its visual impact on the image. One common type of noise in some image acquisition systems is salt and pepper or data drop-out noise. This kind of noise can be caused by errors in data transmission. The result is corrupted pixels that are either set to the maximum value or the minimum value in the image, i.e. in PIL terms to 0 or to 255. The result is to create black and white pixels in the image so it looks like it has had some salt and pepper sprinkled on it. Here\u2019s an image with 5% and 25% levels of salt and pepper noise: Median filtering is an effective technique to reduce the visual impact of salt and pepper noise. It replaces the value of each pixel by the median value of the pixels in its local neighbourhood. This is effective because the salt and pepper pixels are unlikely to be the median value in the neighbourhood and so are generally replaced. The removal isn\u2019t perfect because the values we replace the noise pixels with probably aren\u2019t exactly what the true value is (the median is just a reasonable estimate for the likely value), and other, non-noise, pixels will also be affected and replaced. It would be nice to be have an idea of how effective our filtering is. One measure we can use is the root mean square error between the noisy image and the true\u201d image. Of course in applications we don\u2019t have a true image, just a noisy one, but we can estimate the performance of the filter on actual images, by creating our own noisy ones, and seeing how the filter performs on them.","title":"Noise Filtering"},{"location":"12.1_IP_2/03_Noise_filtering/#noise-filtering","text":"Real world measurements always contain noise or errors. These errors are random perturbations of the true signal that occur in the measuring process. Systematic errors can be modelled and that model used to remove them exactly to recover the original measurement or true signal. For example if you are using a metre stick to measure things and you know that a 5 cm piece has been cut off the low end you can adjust your measurements by adding 5 cm to them, and thus get an accurate measurement. With random errors on the other hand we either don\u2019t know why or how they occurred, or we can\u2019t model the process we suspect produced them, so we can\u2019t remove them precisely. For example aerial photographs that are attempting to capture a picture of the land surface below are affected by the fact that the atmosphere between the camera and ground is neither transparent nor homogenous. Since we can\u2019t remove random error precisely we instead try to reduce its effect. In image processing this means we want to reduce its visual impact on the image. One common type of noise in some image acquisition systems is salt and pepper or data drop-out noise. This kind of noise can be caused by errors in data transmission. The result is corrupted pixels that are either set to the maximum value or the minimum value in the image, i.e. in PIL terms to 0 or to 255. The result is to create black and white pixels in the image so it looks like it has had some salt and pepper sprinkled on it. Here\u2019s an image with 5% and 25% levels of salt and pepper noise: Median filtering is an effective technique to reduce the visual impact of salt and pepper noise. It replaces the value of each pixel by the median value of the pixels in its local neighbourhood. This is effective because the salt and pepper pixels are unlikely to be the median value in the neighbourhood and so are generally replaced. The removal isn\u2019t perfect because the values we replace the noise pixels with probably aren\u2019t exactly what the true value is (the median is just a reasonable estimate for the likely value), and other, non-noise, pixels will also be affected and replaced. It would be nice to be have an idea of how effective our filtering is. One measure we can use is the root mean square error between the noisy image and the true\u201d image. Of course in applications we don\u2019t have a true image, just a noisy one, but we can estimate the performance of the filter on actual images, by creating our own noisy ones, and seeing how the filter performs on them.","title":"Noise Filtering"},{"location":"12.1_IP_2/04_Sharpening/","text":"Sharpening Well so far we\u2019ve looked at enhancing images suffering from exposure problems and random noise. Another common source of image degradation are lens\u201d issues resulting in poor focus and soft or blurred images. Lens\u201d is quoted because focus-like issues arise even in image capture techniques that do not rely on an optical lens. One of the least desirable effects of capturing an image with an imperfectly focussed lens is that the edges in the image are blurred. We can use an edge filter to enhance the edges in the image. For example on the left below (or above if your window is narrow) is an original image and on the right (or below) is the sharpened version. If you examine the images closely you should be able to see that the edges in the second image are sharper and the contrast higher. Here\u2019s how to achieve this. First apply a Laplacian filter to the image. The edge filter we used last time around is the Prewitt operator. It\u2019s a first order operator, also called a gradient filter, that is a discrete approximation to a first derivative ( discrete as opposed to continuous since our pixel values make up a discrete rather than continuous function). The Laplacian operator is a second order filter that approximates the second derivative. Any image feature with high curvature, i.e. a sudden change in intensity, will be enhanced by a Laplacian filter so it is a good candidate to restore fine detail that may have been lost due to imperfect focus. The mask for the Laplacian filter is, -1 -1 -1 -1 8 -1 -1 -1 -1 </table Applying it to the original image produces this image which captures both the fine detail and the strong edges from the original image. ( What could go wrong ? The mask can produce negative values. What will PIL do with these when you save them into the image object?) Next we want to add the features we\u2019ve extracted back into the original image. To do that we need to scale the filtered data back into the same [0, 255] range as the original image. The scaled Laplacian image looks like this: ( What could go wrong ? Watch out for integer arithmetic!) Finally we\u2019re ready to add the filter output back into the original image. After adding it and adjusting the dynamic range you should get this: ( What could go wrong ? When you add the two images you may get values larger than 255, what will PIL do when you save those into the image? Don\u2019t overlook the phrase and adjusting the dynamic range \u201d above.) If we look hard we can see that finer detail is more visible in this image, but the image as a whole appears lighter than the original. This isn\u2019t because it doesn\u2019t use the full of pixel values. Check the image and you will see that its values range from 0 to 255. The problem is a little more subtle: the distribution of the pixel values is not the same as it was in the original image. Perhaps something like this: We can correct for that by equalizing the distribution of pixel values in this image to the distribution of pixel values in the original. (A function to do the histogram equalization is provided below.) Doing that gets us this image: def equalize(input_image, model_image): ''' Returns eq_image a version of input_image whose pixel values have been equalized so its histogram will match model_image's histogram. Leaves input_image and model_image unchanged. See http://en.wikipedia.org/wiki/Histogram_matching and http://en.wikipedia.org/wiki/Histogram_equalization for background. Outline: 1. Build histograms of the grey level values in each image. 2. Build cumulative distributions (CDFs) of the grey level values in each image from the histograms. 3. Use the CDFs to build a pixel value lookup table (LUT). 4. Loop through the input image and use the LUT to assign new equalized pixel values. ''' # 1. Get the grey level histograms for each image. input_histogram = input_image.histogram() model_histogram = model_image.histogram() # print input_histogram, 'n', model_histogram # DEBUG # Minimal error checking to avoid annoying failures. if len(input_histogram) != len(model_histogram): print 'Error: Histograms do not have same length!' return if len(input_histogram) != 256 or len(model_histogram) != 256: print 'Error: Histograms do not use full 0-255 range of values!' return # 2. Build the Cumulative Distribution Functions (cdf's) for each image # TODO: s/b a separate function. input_cdf = input_histogram[:] for i in range(1, len(input_cdf)): input_cdf[i] = input_cdf[i] + input_cdf[i-1] model_cdf = model_histogram[:] for i in range(1, len(model_cdf)): model_cdf[i] = model_cdf[i] + model_cdf[i-1] # print input_cdf, '\\n', model_cdf # DEBUG # 3. Build a lookup table (lut) that will let us look up a pixel value in # input_image to see what it should become in the equalized image. lut = 256*[0] # The rule is to assign each lut entry the index (grey level) of # the first entry in model_cdf that is greater than or equal to # input_cdf's entry. grey_level = 0 for input_cdf_index in range(len(input_histogram)): while model_cdf[grey_level] < input_cdf[input_cdf_index]: grey_level += 1 lut[input_cdf_index] = grey_level # print lut # DEBUG # 4. Create the equalized image, eq_image, by looping through input_image # using the lut to assign pixel values for eq_image. eq_image = Image.new(\"L\", input_image.size) eq_pix = eq_image.load() input_pix = input_image.load() for x in range(im.size[0]): for y in range(im.size[1]): eq_pix[x,y] = lut[input_pix[x,y]] return eq_image (Don't worry about the TODO in there, it's for me not you.)","title":"Sharpening"},{"location":"12.1_IP_2/04_Sharpening/#sharpening","text":"Well so far we\u2019ve looked at enhancing images suffering from exposure problems and random noise. Another common source of image degradation are lens\u201d issues resulting in poor focus and soft or blurred images. Lens\u201d is quoted because focus-like issues arise even in image capture techniques that do not rely on an optical lens. One of the least desirable effects of capturing an image with an imperfectly focussed lens is that the edges in the image are blurred. We can use an edge filter to enhance the edges in the image. For example on the left below (or above if your window is narrow) is an original image and on the right (or below) is the sharpened version. If you examine the images closely you should be able to see that the edges in the second image are sharper and the contrast higher. Here\u2019s how to achieve this. First apply a Laplacian filter to the image. The edge filter we used last time around is the Prewitt operator. It\u2019s a first order operator, also called a gradient filter, that is a discrete approximation to a first derivative ( discrete as opposed to continuous since our pixel values make up a discrete rather than continuous function). The Laplacian operator is a second order filter that approximates the second derivative. Any image feature with high curvature, i.e. a sudden change in intensity, will be enhanced by a Laplacian filter so it is a good candidate to restore fine detail that may have been lost due to imperfect focus. The mask for the Laplacian filter is, -1 -1 -1 -1 8 -1 -1 -1 -1 </table Applying it to the original image produces this image which captures both the fine detail and the strong edges from the original image. ( What could go wrong ? The mask can produce negative values. What will PIL do with these when you save them into the image object?) Next we want to add the features we\u2019ve extracted back into the original image. To do that we need to scale the filtered data back into the same [0, 255] range as the original image. The scaled Laplacian image looks like this: ( What could go wrong ? Watch out for integer arithmetic!) Finally we\u2019re ready to add the filter output back into the original image. After adding it and adjusting the dynamic range you should get this: ( What could go wrong ? When you add the two images you may get values larger than 255, what will PIL do when you save those into the image? Don\u2019t overlook the phrase and adjusting the dynamic range \u201d above.) If we look hard we can see that finer detail is more visible in this image, but the image as a whole appears lighter than the original. This isn\u2019t because it doesn\u2019t use the full of pixel values. Check the image and you will see that its values range from 0 to 255. The problem is a little more subtle: the distribution of the pixel values is not the same as it was in the original image. Perhaps something like this: We can correct for that by equalizing the distribution of pixel values in this image to the distribution of pixel values in the original. (A function to do the histogram equalization is provided below.) Doing that gets us this image: def equalize(input_image, model_image): ''' Returns eq_image a version of input_image whose pixel values have been equalized so its histogram will match model_image's histogram. Leaves input_image and model_image unchanged. See http://en.wikipedia.org/wiki/Histogram_matching and http://en.wikipedia.org/wiki/Histogram_equalization for background. Outline: 1. Build histograms of the grey level values in each image. 2. Build cumulative distributions (CDFs) of the grey level values in each image from the histograms. 3. Use the CDFs to build a pixel value lookup table (LUT). 4. Loop through the input image and use the LUT to assign new equalized pixel values. ''' # 1. Get the grey level histograms for each image. input_histogram = input_image.histogram() model_histogram = model_image.histogram() # print input_histogram, 'n', model_histogram # DEBUG # Minimal error checking to avoid annoying failures. if len(input_histogram) != len(model_histogram): print 'Error: Histograms do not have same length!' return if len(input_histogram) != 256 or len(model_histogram) != 256: print 'Error: Histograms do not use full 0-255 range of values!' return # 2. Build the Cumulative Distribution Functions (cdf's) for each image # TODO: s/b a separate function. input_cdf = input_histogram[:] for i in range(1, len(input_cdf)): input_cdf[i] = input_cdf[i] + input_cdf[i-1] model_cdf = model_histogram[:] for i in range(1, len(model_cdf)): model_cdf[i] = model_cdf[i] + model_cdf[i-1] # print input_cdf, '\\n', model_cdf # DEBUG # 3. Build a lookup table (lut) that will let us look up a pixel value in # input_image to see what it should become in the equalized image. lut = 256*[0] # The rule is to assign each lut entry the index (grey level) of # the first entry in model_cdf that is greater than or equal to # input_cdf's entry. grey_level = 0 for input_cdf_index in range(len(input_histogram)): while model_cdf[grey_level] < input_cdf[input_cdf_index]: grey_level += 1 lut[input_cdf_index] = grey_level # print lut # DEBUG # 4. Create the equalized image, eq_image, by looping through input_image # using the lut to assign pixel values for eq_image. eq_image = Image.new(\"L\", input_image.size) eq_pix = eq_image.load() input_pix = input_image.load() for x in range(im.size[0]): for y in range(im.size[1]): eq_pix[x,y] = lut[input_pix[x,y]] return eq_image (Don't worry about the TODO in there, it's for me not you.)","title":"Sharpening"},{"location":"12.2_YG_Emails/00_index/","text":"DP: Names and Addresses Algorithms and Heuristics Introduction The Goal Complications Support file: activedirectory.txt Support file: peoplesoft.txt","title":"Contents"},{"location":"12.2_YG_Emails/00_index/#dp-names-and-addresses","text":"Algorithms and Heuristics Introduction The Goal Complications Support file: activedirectory.txt Support file: peoplesoft.txt","title":"DP: Names and Addresses"},{"location":"12.2_YG_Emails/01_Algorithms_and_heuristics/","text":"Algorithms and Heuristics This course and its predecessor CPSC 128 have focussed exclusively on solving problems using algorithms. An algorithm is a mechanical procedure that is guaranteed to find the correct solution in a finite amount of time. The word mechanical indicates that it doesn\u2019t rely on magic, or luck, or involve human judgment or intuition; correct means that it always works; and finite that we won\u2019t have to wait forever to get that answer. Those are all desirable properties of a solution methodology, but sometimes they may be overriden by other considerations. For example we may need a solution now (after all finite just guarantees us that an algorithm won\u2019t take forever, but it could take years, or for that matter millenia, and still qualify as an algorithm), and be willing to accept an inexact one as long as it is close to the correct one. It might also be that no perfect solution is even possible, i.e. that the solution is not computable, for example because there is insufficient information. In these cases we may turn to heuristics instead of algorithms. Heuristics are solution techniques that give us reasonable answers quickly. A well-known investing heuristic is that you can find the number of years it will take an investment to double in value by dividing the interest rate into 72. For example money invested at 6% will double in (approximately) 72/6=12 years. (This is an example of an approximation heuristic.) Email virus scanners use heuristics to flag spam by relying on the presence of certain words to classify messages. The presence of the word viagra\u201d does not guarantee that the message is spam, but unless you are a medical researcher it is likely. (This is an example where no perfect mechanical solution is possible.) This week\u2019s problem will give you the chance to come up with some heuristics to help with an intractable problem.","title":"Algorithms and Heuristics"},{"location":"12.2_YG_Emails/01_Algorithms_and_heuristics/#algorithms-and-heuristics","text":"This course and its predecessor CPSC 128 have focussed exclusively on solving problems using algorithms. An algorithm is a mechanical procedure that is guaranteed to find the correct solution in a finite amount of time. The word mechanical indicates that it doesn\u2019t rely on magic, or luck, or involve human judgment or intuition; correct means that it always works; and finite that we won\u2019t have to wait forever to get that answer. Those are all desirable properties of a solution methodology, but sometimes they may be overriden by other considerations. For example we may need a solution now (after all finite just guarantees us that an algorithm won\u2019t take forever, but it could take years, or for that matter millenia, and still qualify as an algorithm), and be willing to accept an inexact one as long as it is close to the correct one. It might also be that no perfect solution is even possible, i.e. that the solution is not computable, for example because there is insufficient information. In these cases we may turn to heuristics instead of algorithms. Heuristics are solution techniques that give us reasonable answers quickly. A well-known investing heuristic is that you can find the number of years it will take an investment to double in value by dividing the interest rate into 72. For example money invested at 6% will double in (approximately) 72/6=12 years. (This is an example of an approximation heuristic.) Email virus scanners use heuristics to flag spam by relying on the presence of certain words to classify messages. The presence of the word viagra\u201d does not guarantee that the message is spam, but unless you are a medical researcher it is likely. (This is an example where no perfect mechanical solution is possible.) This week\u2019s problem will give you the chance to come up with some heuristics to help with an intractable problem.","title":"Algorithms and Heuristics"},{"location":"12.2_YG_Emails/02_YG_Introduction/","text":"Introduction: We just want a list of their email addresses\u201d This problem is inspired by an actual situation at the Yukon Government: They wanted to send an email to every employee, and that wasn\u2019t as easy as you migh expect. The problem is that they can\u2019t easily generate a list of all their employees with their email addresses (or at least they couldn\u2019t a couple of years ago). The problem is that the employee name and id number is kept in one database system (PeopleSoft), while their email addresses and network logins are maintained in another (an Active Directory repository). Having two database systems is not necessarily a problem, but in this case it is because the two databases do not have a shared field. This makes it difficult to combine them and generate a list of employee names and email addresses. (In relational database terms we would like to do a join on the two tables, but can\u2019t because they do not have a shared field, specifically one that is a primary key field in one table and a foreign key field in the other. There\u2019s your jargon for the day.) We can extract records like this from PeopleSoft, ID Name 0047281 Tim Topper ... ... and ones like this from Active Directory, YNET Login EMail ttopper tim.topper@gov.yk.ca ... ... but we want to generate ones like this that combine a field from each table. Name email Tim Topper tim.topper@gov.yk.ca ... ... Do you see a pattern? Doesn\u2019t it make you want to automate the solution to this problem?","title":"Introduction: We just want a list of their email addresses\u201d"},{"location":"12.2_YG_Emails/02_YG_Introduction/#introduction-we-just-want-a-list-of-their-email-addresses","text":"This problem is inspired by an actual situation at the Yukon Government: They wanted to send an email to every employee, and that wasn\u2019t as easy as you migh expect. The problem is that they can\u2019t easily generate a list of all their employees with their email addresses (or at least they couldn\u2019t a couple of years ago). The problem is that the employee name and id number is kept in one database system (PeopleSoft), while their email addresses and network logins are maintained in another (an Active Directory repository). Having two database systems is not necessarily a problem, but in this case it is because the two databases do not have a shared field. This makes it difficult to combine them and generate a list of employee names and email addresses. (In relational database terms we would like to do a join on the two tables, but can\u2019t because they do not have a shared field, specifically one that is a primary key field in one table and a foreign key field in the other. There\u2019s your jargon for the day.) We can extract records like this from PeopleSoft, ID Name 0047281 Tim Topper ... ... and ones like this from Active Directory, YNET Login EMail ttopper tim.topper@gov.yk.ca ... ... but we want to generate ones like this that combine a field from each table. Name email Tim Topper tim.topper@gov.yk.ca ... ... Do you see a pattern? Doesn\u2019t it make you want to automate the solution to this problem?","title":"Introduction: We just want a list of their email addresses\u201d"},{"location":"12.2_YG_Emails/03_YG_Goal/","text":"Your Goal Your job is to write a Python program that will take two text files (e.g. peoplesoft.txt and activedirectory.txt ) containing data exported from each system and attempt to resolve the entries in them. You should output a list of matches sorted in descending order by match quality, where the possible quality values should include likely match\u201d, possible match\u201d, and unmatched\u201d, Name Email Match quality Tim Topper tim.topper@gov.yk.ca Likely Match Michael Smith michael.smith@gov.yk.ca Likely Match Robert Timms bob.timms@gov.yk.ca Possible Match Michael Smith mike.smith@gov.yk.ca Possible Match Marlene Trent Unmatched helpdesk@gov.yk.ca Unmatched Due to the complications we cannot automate the entire process, but with around 5,000 employees if our program can match 80% of them with confidence we have saved someone a lot of manual work.","title":"Your Goal"},{"location":"12.2_YG_Emails/03_YG_Goal/#your-goal","text":"Your job is to write a Python program that will take two text files (e.g. peoplesoft.txt and activedirectory.txt ) containing data exported from each system and attempt to resolve the entries in them. You should output a list of matches sorted in descending order by match quality, where the possible quality values should include likely match\u201d, possible match\u201d, and unmatched\u201d, Name Email Match quality Tim Topper tim.topper@gov.yk.ca Likely Match Michael Smith michael.smith@gov.yk.ca Likely Match Robert Timms bob.timms@gov.yk.ca Possible Match Michael Smith mike.smith@gov.yk.ca Possible Match Marlene Trent Unmatched helpdesk@gov.yk.ca Unmatched Due to the complications we cannot automate the entire process, but with around 5,000 employees if our program can match 80% of them with confidence we have saved someone a lot of manual work.","title":"Your Goal"},{"location":"12.2_YG_Emails/04_YG_Complications/","text":"Complications The records for Tim Topper may be manageable, but looking through the tables reveals other cases that are more difficult. Familiar name != Formal name Robert Timms has login btimms and email address bob.timms@gov.yk.ca but unless we knew that Roberts sometimes go by the name Bob (or Bobby) this would be difficult to predict. Familiar name similar to Formal name Richard Johnson has login rjohnson (which we would predict) but email address rick.johnson@gov.yk.ca because he told the departmental network admin who created the email address that his name was Rick Johnson. Now in fairness that\u2019s what everyone calls him, and so to keep his email address guessable by people wanting to contact him it should be rick.johnson@gov.yk.ca. The real problem here is having two disconnected databases. Names not unique And then there are the Michael Smiths. The first one hired has login msmith and email address Michael.Smith as we would predict. The second one has login masmith (Since he is Michael Andrew Smith) and email address Mike.Smith@gov.yk.ca since he goes by Mike rather than Michael. What\u2019s a busy network admin to do when the first login and email address they enter is already taken? Not all employees have email addresses Marlene Trent doesn\u2019t have a login or an email address. Some email addresses don\u2019t belong to employees mail1@gov.yk.ca and helpdesk@gov.yk.ca don\u2019t have names or employee ids associated with them.","title":"Complications"},{"location":"12.2_YG_Emails/04_YG_Complications/#complications","text":"The records for Tim Topper may be manageable, but looking through the tables reveals other cases that are more difficult.","title":"Complications"},{"location":"12.2_YG_Emails/04_YG_Complications/#familiar-name-formal-name","text":"Robert Timms has login btimms and email address bob.timms@gov.yk.ca but unless we knew that Roberts sometimes go by the name Bob (or Bobby) this would be difficult to predict.","title":"Familiar name != Formal name"},{"location":"12.2_YG_Emails/04_YG_Complications/#familiar-name-similar-to-formal-name","text":"Richard Johnson has login rjohnson (which we would predict) but email address rick.johnson@gov.yk.ca because he told the departmental network admin who created the email address that his name was Rick Johnson. Now in fairness that\u2019s what everyone calls him, and so to keep his email address guessable by people wanting to contact him it should be rick.johnson@gov.yk.ca. The real problem here is having two disconnected databases.","title":"Familiar name similar to Formal name"},{"location":"12.2_YG_Emails/04_YG_Complications/#names-not-unique","text":"And then there are the Michael Smiths. The first one hired has login msmith and email address Michael.Smith as we would predict. The second one has login masmith (Since he is Michael Andrew Smith) and email address Mike.Smith@gov.yk.ca since he goes by Mike rather than Michael. What\u2019s a busy network admin to do when the first login and email address they enter is already taken?","title":"Names not unique"},{"location":"12.2_YG_Emails/04_YG_Complications/#not-all-employees-have-email-addresses","text":"Marlene Trent doesn\u2019t have a login or an email address.","title":"Not all employees have email addresses"},{"location":"12.2_YG_Emails/04_YG_Complications/#some-email-addresses-dont-belong-to-employees","text":"mail1@gov.yk.ca and helpdesk@gov.yk.ca don\u2019t have names or employee ids associated with them.","title":"Some email addresses don\u2019t belong to employees"},{"location":"13.1_Exam_Preparation/00_index/","text":"Exam Preparation Examinable topics Exam Study Guide Redacted final exam + Q&A","title":"Contents"},{"location":"13.1_Exam_Preparation/00_index/#exam-preparation","text":"Examinable topics Exam Study Guide Redacted final exam + Q&A","title":"Exam Preparation"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/","text":"Examinable Topics I\u2019ll leave this here because it serves as a useful list of topics, but focus your studying on the Exam Study Guide . Items that are crossed out were covered in the course, but will not be examined. Algorithmics: How? When? Searching : exhaustive, linear, binary (with and without recursion), interpolation. Be able to write the first three. Know the performance of all. Sorting : straight insertion, selection and exchange (bubble); Shell sort, quicksort (with and without recursion), heapsort. Be able to write the first three, read and modify the second three. Know the performance of all six. Recursion . Be able to step through, and convert to and from recursive solutions. Median . Remember and be able to adapt the two approaches. ~~Indexing~~ ~~. Persistent indexes~~. Breadth-first tree search , e.g. pitcher problem. Remember the approach. Binary trick to get all subsets. Be able to discuss, read and modify (but not write from scratch). Data structures Processing arrays , e.g. Game of life, Mazes. Complex representations : e.g. maze with shared walls. Binary trees in a list, e.g. heap; ischild(), parent(), ancestor(). Design patterns, tools, and issues ~~Persistence~~ ~~: designing text file formats (see CGoL alternatives: screenshot, list of live ones). Binary file formats, e.g. bitmap for CGoL, pickling and shelves. Analyzing space requirements of file formats, e.g. as we did for the text formats in CGoL.~~ Theoretical algorithm analysis . Big O notation. Be able to do the assignment problems. ~~Empirical algorithm analysis~~ ~~: Plot your timing data vs the hypothesized order, a straight line means your hypothesis is correct.~~ ~~Event driven programming~~ ~~, e.g. our text and visual controllers for the object server~~. T~~ext controllers vs visual (for us, HTML) controllers~~. Object serialization . (Just know what the term means). ~~ TDD : Test driven development.~~ MVC : Model-view-controller. Know the diagram. CRUDS : Create-retrieve-update-delete-search. Approach: Design from the desired interface to the code . OO modelling , e.g. as we did for pitchers. Testing for correctness (unit testing). Performance testing. Testing frameworks. UIDs : Hashing (SHA, md5, Python\u2019s hash()) Efficiency strategies : Avoid unnecessary work; Remember previously computed values (cache). ~~Symbolic debuggers .~~ ~~ UML. You should remember what we saw in CPSC 128.~~ Major problem domains that might be referred to CGoL: Conway\u2019s game of life Bitmapped graphics, e.g. bouncing ball. Mazes Text files Object server (originally quote server) ~~CGI programming. HTML forms for input. Parsing the query~~. String processing, e.g. early anagram-like problem using people\u2019s names. ~~Pitcher problems~~ Language specific issues the subtleties of reference semantics; copy.deepcopy() list comprehensions list splitting and slicing, e.g. as done in median-by-partition. hash() pickling and shelves (which update on assignment not mutation). try...except...","title":"Examinable Topics"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#examinable-topics","text":"I\u2019ll leave this here because it serves as a useful list of topics, but focus your studying on the Exam Study Guide . Items that are crossed out were covered in the course, but will not be examined.","title":"Examinable Topics"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#algorithmics-how-when","text":"Searching : exhaustive, linear, binary (with and without recursion), interpolation. Be able to write the first three. Know the performance of all. Sorting : straight insertion, selection and exchange (bubble); Shell sort, quicksort (with and without recursion), heapsort. Be able to write the first three, read and modify the second three. Know the performance of all six. Recursion . Be able to step through, and convert to and from recursive solutions. Median . Remember and be able to adapt the two approaches. ~~Indexing~~ ~~. Persistent indexes~~. Breadth-first tree search , e.g. pitcher problem. Remember the approach. Binary trick to get all subsets. Be able to discuss, read and modify (but not write from scratch).","title":"Algorithmics: How? When?"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#data-structures","text":"Processing arrays , e.g. Game of life, Mazes. Complex representations : e.g. maze with shared walls. Binary trees in a list, e.g. heap; ischild(), parent(), ancestor().","title":"Data structures"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#design-patterns-tools-and-issues","text":"~~Persistence~~ ~~: designing text file formats (see CGoL alternatives: screenshot, list of live ones). Binary file formats, e.g. bitmap for CGoL, pickling and shelves. Analyzing space requirements of file formats, e.g. as we did for the text formats in CGoL.~~ Theoretical algorithm analysis . Big O notation. Be able to do the assignment problems. ~~Empirical algorithm analysis~~ ~~: Plot your timing data vs the hypothesized order, a straight line means your hypothesis is correct.~~ ~~Event driven programming~~ ~~, e.g. our text and visual controllers for the object server~~. T~~ext controllers vs visual (for us, HTML) controllers~~. Object serialization . (Just know what the term means). ~~ TDD : Test driven development.~~ MVC : Model-view-controller. Know the diagram. CRUDS : Create-retrieve-update-delete-search. Approach: Design from the desired interface to the code . OO modelling , e.g. as we did for pitchers. Testing for correctness (unit testing). Performance testing. Testing frameworks. UIDs : Hashing (SHA, md5, Python\u2019s hash()) Efficiency strategies : Avoid unnecessary work; Remember previously computed values (cache). ~~Symbolic debuggers .~~ ~~ UML. You should remember what we saw in CPSC 128.~~","title":"Design patterns, tools, and issues"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#major-problem-domains-that-might-be-referred-to","text":"CGoL: Conway\u2019s game of life Bitmapped graphics, e.g. bouncing ball. Mazes Text files Object server (originally quote server) ~~CGI programming. HTML forms for input. Parsing the query~~. String processing, e.g. early anagram-like problem using people\u2019s names. ~~Pitcher problems~~","title":"Major problem domains that might be referred to"},{"location":"13.1_Exam_Preparation/01_Examinable_topics/#language-specific-issues","text":"the subtleties of reference semantics; copy.deepcopy() list comprehensions list splitting and slicing, e.g. as done in median-by-partition. hash() pickling and shelves (which update on assignment not mutation). try...except...","title":"Language specific issues"},{"location":"13.1_Exam_Preparation/02_Exam_study_guide/","text":"Exam Study Guide Just what you were sent by email, but saved here for posterity. Some things that WON'T be on the exam: * No new long code chunks to read and understand. Reading code is a slow process, and difficult to do quickly. * No new problem domains to wrap your head around. * No class inheritance though small, simple classes may appear. The exam is NOT comprehensive, i.e. it does not test everything we covered this semester. Your ability to do most things has already been assessed through the assignments. Look closely at the descriptions of the problems so you will know what to study and prepare for. The exam is out of 180 marks, and you have 180 minutes to write it, so the value of a question gives you a rough idea of how long you should spend on it. The exam has 8 problems: Problem 1 (30 marks) Three parts that each begin: \"What output does the following code fragment produce?\" (Hint: Watch out for references.) Problem 2 (10 marks) Four parts: \"Which of the six main sorting methods we studied (straight insertion, straight selection, straight exchange/bubble, Shell sort, quicksort and heapsort) would you implement for each of the following applications? Briefly explain why in each case.\" Problem 3 (10 marks) Two parts each with the form: \"What does the acronym _____ stand for? What is the rationale for this _______?\" Problem 4 (15 marks) Four parts each with the form: An O(_) algorithm takes ____ to process a _____. How long will it take to process a ____? (Hint: Just like a2p2 and a3p1) Problem 5 (25 marks) Write two functions to work with binary trees stored in lists. (Hint: Functions similar to those in a7p3). Problem 6 (30 marks) Design a data representation: \"Conduct an OO analysis of this ____, i.e. identify the type(s) of object(s) it contains, and the attributes of each type. Write the class statements and __init__ methods for the object type(s) you have identified.\" (Hint: Know our design of the maze representation). Problem 7 (30 marks) Implement an algorithm drawing on sorting techniques. (Hint: Know your sorts and the techniques they used for implementation) Problem 8 (30 marks) Involves writing a function to work with graphs like this, represented like this: g = { 'A': ['B', 'C'], 'B': ['D', 'C'], 'C': ['E'], 'D': ['C', 'E'], 'E': [] } (Hint: Know the pitcher problem solving algorithm.)","title":"Exam Study Guide"},{"location":"13.1_Exam_Preparation/02_Exam_study_guide/#exam-study-guide","text":"Just what you were sent by email, but saved here for posterity. Some things that WON'T be on the exam: * No new long code chunks to read and understand. Reading code is a slow process, and difficult to do quickly. * No new problem domains to wrap your head around. * No class inheritance though small, simple classes may appear. The exam is NOT comprehensive, i.e. it does not test everything we covered this semester. Your ability to do most things has already been assessed through the assignments. Look closely at the descriptions of the problems so you will know what to study and prepare for. The exam is out of 180 marks, and you have 180 minutes to write it, so the value of a question gives you a rough idea of how long you should spend on it. The exam has 8 problems: Problem 1 (30 marks) Three parts that each begin: \"What output does the following code fragment produce?\" (Hint: Watch out for references.) Problem 2 (10 marks) Four parts: \"Which of the six main sorting methods we studied (straight insertion, straight selection, straight exchange/bubble, Shell sort, quicksort and heapsort) would you implement for each of the following applications? Briefly explain why in each case.\" Problem 3 (10 marks) Two parts each with the form: \"What does the acronym _____ stand for? What is the rationale for this _______?\" Problem 4 (15 marks) Four parts each with the form: An O(_) algorithm takes ____ to process a _____. How long will it take to process a ____? (Hint: Just like a2p2 and a3p1) Problem 5 (25 marks) Write two functions to work with binary trees stored in lists. (Hint: Functions similar to those in a7p3). Problem 6 (30 marks) Design a data representation: \"Conduct an OO analysis of this ____, i.e. identify the type(s) of object(s) it contains, and the attributes of each type. Write the class statements and __init__ methods for the object type(s) you have identified.\" (Hint: Know our design of the maze representation). Problem 7 (30 marks) Implement an algorithm drawing on sorting techniques. (Hint: Know your sorts and the techniques they used for implementation) Problem 8 (30 marks) Involves writing a function to work with graphs like this, represented like this: g = { 'A': ['B', 'C'], 'B': ['D', 'C'], 'C': ['E'], 'D': ['C', 'E'], 'E': [] } (Hint: Know the pitcher problem solving algorithm.)","title":"Exam Study Guide"},{"location":"13.1_Exam_Preparation/03_Redacted_final_exam/","text":"Redacted Final Exam (aka As much as I can tell you about without actually showing it all to you\u201d) Tara: Hello Tim Topper: Hi Tara. Don't have my headset on yet. Just need to upload some images. Tara: ok Tim Topper: Aah! The system doesn't see my headset. Here look at this while I fiddle. Tara: where would we get python in a nutshell? Tim Topper: It's available as a printed book and an ebook from O'Reilly publishing. Tim Topper: It's an excellent compact reference to the language. Reference means it doesn't explain much. Tara: that is for part 2 only? Tim Topper: Just shows you the details, e.g. if you want to see a list of string methods. Tim Topper: Oh, I see why you are asking. Sorry that is an old instruction, from a term where it was a required text. Tim Topper: I'll remove that... Tim Topper: I'm going to try one more thing to get sound going. Be right back. (I hope). [...15 minutes later...] Tim Topper: There will be no audio today. Tim Topper: Dialogs that begin ''The filesystem is dirty'' do not lead to anything good. Tara: This adobe software is something eh Tim Topper: The crazy thing is that it works for weeks, then...bam. Tim Topper: Are you bored of looking at the instructions? :-) Any questions? Chris Lane: looks all good Tara: Is there any material we can consult during the test then? Tim Topper: No. You can try things out in IDLE, but there shouldn't be anything you would want to look up. Tara: ok Tim Topper: I've got some redacted screen shots of my workign copy of the exam. Tim Topper: It's not finalized yet, but I thought we would go through them to give you an idea of what to expect. Tim Topper: The first three questiosn will be the classic ''what output does this produce'' to make sure you can step through code. Tim Topper: 3 x 10 marks each means they should take you around 30 minutes. Tim Topper: As you can see the bottom one may involve something graphical. Tara: ok Tim Topper: Next up some short answer questions. Tim Topper: One about the sorting methods (to make sure you wouldn't use a bubble sort on a list with a million random elements!). Tim Topper: One on search. Tim Topper: One to check on some of the jargon we encountered, e.g. CRUD. Tim Topper: One on algorithmic complexity, just like the assignment problems. Tim Topper: Around 40 marks and thus 40 minutes. Tim Topper: Quetions about those types? Tara: yes Tara: how do we know which sort to use? Why would we use the 'slower' methods again? Tim Topper: You might use a slower method if the list was very short. Woudl you really invest the time to gte a quicksort going Tim Topper: to sort lists of 5 elements? Tim Topper: If you knew a list was mostly sorted already you might use an insertion sort. Tim Topper: If you only had to sort the first 1/4 of a list you might not be able to use some fo the fast sorts. Tim Topper: Remember that even the fast sorts can have worst cases that are pretty bad, so you have to watch out for situations that could give rise to that worst case. Tara: I am also not clear on how to figure out the O(...) for code, like what each sort method is considered to be On^2 or Log n? Tim Topper: You might want to break out the popcorn and rewatch sorting out sorting! Tim Topper: The short version is: for random lists the three slow ones are all O(n^2) and the three fast ones are all O(n log n) Tim Topper: That's n times log n, not just log n. Tara: right Tim Topper: Binary search was O(log n). Linear search is O(n). Tim Topper: (Bogosort was O(n!)) Tim Topper: Does that help? Tara: yes, thanks Tim Topper: Don't overlook the preliminary clause ''for random data''. Tim Topper: For sorted data, and reversed data the results can be different as you hopefully found on an assignment. Tim Topper: Other questions on these? Tara: my data was too all over the place for me to really put it together Tim Topper: Aha! Your past comes back to haunt you. Tim Topper: Let's see... Tim Topper: You should have noticed that selection sort is very stable. Because it always does all the comparisons and Tim Topper: then one swap it doesn't speed up much if the list is already sorted or slow down much if it is in reverse order. Tim Topper: Insertion sort is really fast if the list is in order becasue it discovers that everything is in place and doesn't actually have to do any insertions. Tim Topper: By contrast a reversed list is its worst case. Tim Topper: Bubble/Shaker sort share that quality of insertion sort. Tara: right, it has to change everything Tim Topper: That's right. Tim Topper: Quicksort's worst case depends on the way the pivot is chosen, but it's worst case is O(n^2) Tara: sorry for 6 b, how do we calc how much bigger the image is, is it 3x as big ? Tim Topper: If you choose the first element to be the pivot as we did then either an in order or reversed list produces the worst case, and may even exhaust the recursion stack and lead to a crash. Tara: seen that happen Tim Topper: Good question. Images are tricky because they are rectangular (or in this case square). Tim Topper: That means this one is 3 times as wide AND 3x as high so it's area is 3x3=9 times as large. Tim Topper: Subtle eh? Tim Topper: Other Qs? Tara: I was thinking either 3 or 9. Not from me Tim Topper: 9 it is. Tim Topper: The next questions will be some short code bits. Tara: will you be posting the images and chat session? or did you plan to record this session? Tim Topper: I will post the transcript and the images to D2L. Tara: thanks Tara: 7 looks like the ancestor/child problem Tim Topper: That will be easier to scan than a recording would be. (With audio I would have recorded). Tim Topper: One will get you to do something with binary trees stored in lists -- just like the ancestor-child problem, though not that exact problem. Tim Topper: The other question will get you to specify some tests AND write some code to implement them. Tim Topper: So you have to think of what would make godo test data and then write the code to apply the tests. Tara: so this someone is us? Tim Topper: The weight of the individual questions may change a bit, but together they should add to around 30. Tim Topper: No you won't have to write the function, but you won't get to see it either. Tara: ok Tim Topper: Imagine someone has told you they have written a sort function. That's all you know, but your job is to think how to test it. Tara: will we know attributes? or just guess Tara: or doesn't matter? Tim Topper: You will see a sample call to the function, e.g. sort(lst), or max(a,b) Tara: ah ok Tim Topper: Does that make sense? I am not trying to be mysterious. Tara: yes makes sense Tim Topper: Onward? Chris Lane: k Tara: ok Tim Topper: The last three problems will be substantial coding problems at around 30 mins each. Tim Topper: One will focus on class/representation issues. Tim Topper: One on coding methods we encountered in sorting or searching. Tim Topper: And the last one on general algorithm development. Tim Topper: Qs? Tara: will we be writing all the code for each? Tim Topper: Probably. Tim Topper: The last two will probably be short, but as you know short code can be tricky. Tim Topper: On the other hand I amot expecting working programs for each solution. Tara: 11 is that code or pseudocode you are looking for? Tim Topper: It's the algorithm that is most improtant. Tim Topper: I would defintiely start with and submit pseudocode. Tim Topper: Feel free to leave pseudocode in your file, or to print out multiple versions as it evolves. Tara: Is there something in class we have done that we could compare, with q9 Tim Topper: Yes Tara: It seems quite different from the wumpus and other classes we've worked with, I am not connecting how to build an excel type output Tim Topper: Don't worry about displaying it. Just think about representing it internally. Tim Topper: Internally it's not much different than a tic tac toe board. Tim Topper: Or a maze with walls... Tara: like is_filled, has_border Tim Topper: Exactly. Tara: ok Tara: are there more questions on the test? Tim Topper: That's it. Tim Topper: One thing that isn't apparent in this redacted version is that I am hoping to test recursion too. Tim Topper: i.e. your ability to write small recurve functions. Tim Topper: s/b recursive not ''recurve'' Tara: small ones are not so bad :) Tim Topper: Don't worry, nothing large and recursive. Tara: nothing with html or cgi? Tara: pygame? Tim Topper: In fact recursive solutions even to large problems tend to be small pieces of code. Tim Topper: No pygame. Unless there is a short answer question about main event loops or something. Tim Topper: There's no way to ensure pygame would be on the machines you might have access to... Tim Topper: ... and I don't expect you to have memorized any of it. Tara: ok, yes it won't install at work, nor on my vista laptop Tim Topper: Similarly for CGI and HTTP servers. Tim Topper: Good thing to ask about though. Any other content you're wonderingbout? Tara: not anything I can think of right now Tim Topper: (Sorry to hear about pygame on Vista. It works for on Windows 7 and XP so I just assumed...) Tim Topper: Anything else helpful I can tell you about the exam? Tara: I think you already told us how long? Tara: Was the first page all of part 1? Tim Topper: 3 hours. 180 marks. So 1 mark per minute for planning. Tim Topper: Just that one page. Hand it to your invigilator and you can use the computer for all of part 2. Tara: ok Tim Topper: Any other questions? About the exam or anything else? Tara: not right now Tim Topper: Feel free to contact me if any occur to you later. Tim Topper: I'll be hearing who your invigilators are sometime soon? Tara: I sent an email to Penny to ask her and cc'd you, but she hasn't got back to me yet Tim Topper: Me neither. Are you sure she isn't on leave? Tara: I should call the library to confirm Tara: I know there is another invigilator, she is new here at NWCC on-call Tim Topper: OK Let me know when you have one lined up. Tara: will do Tim Topper: That's all I had planned for today. Minus the audio problems! Tim Topper: Maybe my computer has finished its disk check (I moved into one of our labs). Tara: do you have backups? Tim Topper: Of all my data absolutely. No image of the installed software though, so that could be time consuming IF I have to reinstall. Tim Topper: I'll let you know how it turns out. Tim Topper: Study hard _all_weekend_long_! Tara: I think I am done a11, my only question non-essential was if we could use local pictures for the 'hockey player' Tim Topper: And feel free to submit more or updated assignments... Tim Topper: You could if you used an upload field in your form, but then you'd need to save them on your ''server'' too. Tim Topper: As you can see in the hockey player class, I instead just linked to images already available online. Tara: oh should we know doctest for the exam? Tara: right, that seemed to be the only way that worked Tim Topper: Re doctest. It's not something I'm setting out to test, but I'd hope you could read one. Tim Topper: I'm more interesting in you writing a small custom testing routine for correctness and/or speed. Tara: ok Tim Topper: Likewise I'm not setting out to test UML, but I wouldn't feel bad about providing a UML diagram as part of a problem description. Tim Topper: More good questions Tara! Tim Topper: Anything else? Tara: not from me Chris Lane: all good here Tim Topper: Well then, best of luck to you both on the exam, and wherever you head next. Tara: Will a 2nd year programming course be offered? and will you be teaching it? Tim Topper: Unfortunately there aren't any plans to offer further programming courses as part of the NCIT program. Tim Topper: You'll have to look to a specific College or University for more. Tara: ok, thanks, bye for now Tim Topper: Your welcome. Bye. Tim Topper: Bye Chris. Chris Lane: c ya","title":"Redacted Final Exam"},{"location":"13.1_Exam_Preparation/03_Redacted_final_exam/#redacted-final-exam","text":"(aka As much as I can tell you about without actually showing it all to you\u201d) Tara: Hello Tim Topper: Hi Tara. Don't have my headset on yet. Just need to upload some images. Tara: ok Tim Topper: Aah! The system doesn't see my headset. Here look at this while I fiddle. Tara: where would we get python in a nutshell? Tim Topper: It's available as a printed book and an ebook from O'Reilly publishing. Tim Topper: It's an excellent compact reference to the language. Reference means it doesn't explain much. Tara: that is for part 2 only? Tim Topper: Just shows you the details, e.g. if you want to see a list of string methods. Tim Topper: Oh, I see why you are asking. Sorry that is an old instruction, from a term where it was a required text. Tim Topper: I'll remove that... Tim Topper: I'm going to try one more thing to get sound going. Be right back. (I hope). [...15 minutes later...] Tim Topper: There will be no audio today. Tim Topper: Dialogs that begin ''The filesystem is dirty'' do not lead to anything good. Tara: This adobe software is something eh Tim Topper: The crazy thing is that it works for weeks, then...bam. Tim Topper: Are you bored of looking at the instructions? :-) Any questions? Chris Lane: looks all good Tara: Is there any material we can consult during the test then? Tim Topper: No. You can try things out in IDLE, but there shouldn't be anything you would want to look up. Tara: ok Tim Topper: I've got some redacted screen shots of my workign copy of the exam. Tim Topper: It's not finalized yet, but I thought we would go through them to give you an idea of what to expect. Tim Topper: The first three questiosn will be the classic ''what output does this produce'' to make sure you can step through code. Tim Topper: 3 x 10 marks each means they should take you around 30 minutes. Tim Topper: As you can see the bottom one may involve something graphical. Tara: ok Tim Topper: Next up some short answer questions. Tim Topper: One about the sorting methods (to make sure you wouldn't use a bubble sort on a list with a million random elements!). Tim Topper: One on search. Tim Topper: One to check on some of the jargon we encountered, e.g. CRUD. Tim Topper: One on algorithmic complexity, just like the assignment problems. Tim Topper: Around 40 marks and thus 40 minutes. Tim Topper: Quetions about those types? Tara: yes Tara: how do we know which sort to use? Why would we use the 'slower' methods again? Tim Topper: You might use a slower method if the list was very short. Woudl you really invest the time to gte a quicksort going Tim Topper: to sort lists of 5 elements? Tim Topper: If you knew a list was mostly sorted already you might use an insertion sort. Tim Topper: If you only had to sort the first 1/4 of a list you might not be able to use some fo the fast sorts. Tim Topper: Remember that even the fast sorts can have worst cases that are pretty bad, so you have to watch out for situations that could give rise to that worst case. Tara: I am also not clear on how to figure out the O(...) for code, like what each sort method is considered to be On^2 or Log n? Tim Topper: You might want to break out the popcorn and rewatch sorting out sorting! Tim Topper: The short version is: for random lists the three slow ones are all O(n^2) and the three fast ones are all O(n log n) Tim Topper: That's n times log n, not just log n. Tara: right Tim Topper: Binary search was O(log n). Linear search is O(n). Tim Topper: (Bogosort was O(n!)) Tim Topper: Does that help? Tara: yes, thanks Tim Topper: Don't overlook the preliminary clause ''for random data''. Tim Topper: For sorted data, and reversed data the results can be different as you hopefully found on an assignment. Tim Topper: Other questions on these? Tara: my data was too all over the place for me to really put it together Tim Topper: Aha! Your past comes back to haunt you. Tim Topper: Let's see... Tim Topper: You should have noticed that selection sort is very stable. Because it always does all the comparisons and Tim Topper: then one swap it doesn't speed up much if the list is already sorted or slow down much if it is in reverse order. Tim Topper: Insertion sort is really fast if the list is in order becasue it discovers that everything is in place and doesn't actually have to do any insertions. Tim Topper: By contrast a reversed list is its worst case. Tim Topper: Bubble/Shaker sort share that quality of insertion sort. Tara: right, it has to change everything Tim Topper: That's right. Tim Topper: Quicksort's worst case depends on the way the pivot is chosen, but it's worst case is O(n^2) Tara: sorry for 6 b, how do we calc how much bigger the image is, is it 3x as big ? Tim Topper: If you choose the first element to be the pivot as we did then either an in order or reversed list produces the worst case, and may even exhaust the recursion stack and lead to a crash. Tara: seen that happen Tim Topper: Good question. Images are tricky because they are rectangular (or in this case square). Tim Topper: That means this one is 3 times as wide AND 3x as high so it's area is 3x3=9 times as large. Tim Topper: Subtle eh? Tim Topper: Other Qs? Tara: I was thinking either 3 or 9. Not from me Tim Topper: 9 it is. Tim Topper: The next questions will be some short code bits. Tara: will you be posting the images and chat session? or did you plan to record this session? Tim Topper: I will post the transcript and the images to D2L. Tara: thanks Tara: 7 looks like the ancestor/child problem Tim Topper: That will be easier to scan than a recording would be. (With audio I would have recorded). Tim Topper: One will get you to do something with binary trees stored in lists -- just like the ancestor-child problem, though not that exact problem. Tim Topper: The other question will get you to specify some tests AND write some code to implement them. Tim Topper: So you have to think of what would make godo test data and then write the code to apply the tests. Tara: so this someone is us? Tim Topper: The weight of the individual questions may change a bit, but together they should add to around 30. Tim Topper: No you won't have to write the function, but you won't get to see it either. Tara: ok Tim Topper: Imagine someone has told you they have written a sort function. That's all you know, but your job is to think how to test it. Tara: will we know attributes? or just guess Tara: or doesn't matter? Tim Topper: You will see a sample call to the function, e.g. sort(lst), or max(a,b) Tara: ah ok Tim Topper: Does that make sense? I am not trying to be mysterious. Tara: yes makes sense Tim Topper: Onward? Chris Lane: k Tara: ok Tim Topper: The last three problems will be substantial coding problems at around 30 mins each. Tim Topper: One will focus on class/representation issues. Tim Topper: One on coding methods we encountered in sorting or searching. Tim Topper: And the last one on general algorithm development. Tim Topper: Qs? Tara: will we be writing all the code for each? Tim Topper: Probably. Tim Topper: The last two will probably be short, but as you know short code can be tricky. Tim Topper: On the other hand I amot expecting working programs for each solution. Tara: 11 is that code or pseudocode you are looking for? Tim Topper: It's the algorithm that is most improtant. Tim Topper: I would defintiely start with and submit pseudocode. Tim Topper: Feel free to leave pseudocode in your file, or to print out multiple versions as it evolves. Tara: Is there something in class we have done that we could compare, with q9 Tim Topper: Yes Tara: It seems quite different from the wumpus and other classes we've worked with, I am not connecting how to build an excel type output Tim Topper: Don't worry about displaying it. Just think about representing it internally. Tim Topper: Internally it's not much different than a tic tac toe board. Tim Topper: Or a maze with walls... Tara: like is_filled, has_border Tim Topper: Exactly. Tara: ok Tara: are there more questions on the test? Tim Topper: That's it. Tim Topper: One thing that isn't apparent in this redacted version is that I am hoping to test recursion too. Tim Topper: i.e. your ability to write small recurve functions. Tim Topper: s/b recursive not ''recurve'' Tara: small ones are not so bad :) Tim Topper: Don't worry, nothing large and recursive. Tara: nothing with html or cgi? Tara: pygame? Tim Topper: In fact recursive solutions even to large problems tend to be small pieces of code. Tim Topper: No pygame. Unless there is a short answer question about main event loops or something. Tim Topper: There's no way to ensure pygame would be on the machines you might have access to... Tim Topper: ... and I don't expect you to have memorized any of it. Tara: ok, yes it won't install at work, nor on my vista laptop Tim Topper: Similarly for CGI and HTTP servers. Tim Topper: Good thing to ask about though. Any other content you're wonderingbout? Tara: not anything I can think of right now Tim Topper: (Sorry to hear about pygame on Vista. It works for on Windows 7 and XP so I just assumed...) Tim Topper: Anything else helpful I can tell you about the exam? Tara: I think you already told us how long? Tara: Was the first page all of part 1? Tim Topper: 3 hours. 180 marks. So 1 mark per minute for planning. Tim Topper: Just that one page. Hand it to your invigilator and you can use the computer for all of part 2. Tara: ok Tim Topper: Any other questions? About the exam or anything else? Tara: not right now Tim Topper: Feel free to contact me if any occur to you later. Tim Topper: I'll be hearing who your invigilators are sometime soon? Tara: I sent an email to Penny to ask her and cc'd you, but she hasn't got back to me yet Tim Topper: Me neither. Are you sure she isn't on leave? Tara: I should call the library to confirm Tara: I know there is another invigilator, she is new here at NWCC on-call Tim Topper: OK Let me know when you have one lined up. Tara: will do Tim Topper: That's all I had planned for today. Minus the audio problems! Tim Topper: Maybe my computer has finished its disk check (I moved into one of our labs). Tara: do you have backups? Tim Topper: Of all my data absolutely. No image of the installed software though, so that could be time consuming IF I have to reinstall. Tim Topper: I'll let you know how it turns out. Tim Topper: Study hard _all_weekend_long_! Tara: I think I am done a11, my only question non-essential was if we could use local pictures for the 'hockey player' Tim Topper: And feel free to submit more or updated assignments... Tim Topper: You could if you used an upload field in your form, but then you'd need to save them on your ''server'' too. Tim Topper: As you can see in the hockey player class, I instead just linked to images already available online. Tara: oh should we know doctest for the exam? Tara: right, that seemed to be the only way that worked Tim Topper: Re doctest. It's not something I'm setting out to test, but I'd hope you could read one. Tim Topper: I'm more interesting in you writing a small custom testing routine for correctness and/or speed. Tara: ok Tim Topper: Likewise I'm not setting out to test UML, but I wouldn't feel bad about providing a UML diagram as part of a problem description. Tim Topper: More good questions Tara! Tim Topper: Anything else? Tara: not from me Chris Lane: all good here Tim Topper: Well then, best of luck to you both on the exam, and wherever you head next. Tara: Will a 2nd year programming course be offered? and will you be teaching it? Tim Topper: Unfortunately there aren't any plans to offer further programming courses as part of the NCIT program. Tim Topper: You'll have to look to a specific College or University for more. Tara: ok, thanks, bye for now Tim Topper: Your welcome. Bye. Tim Topper: Bye Chris. Chris Lane: c ya","title":"Redacted Final Exam"},{"location":"Assignments/Assignment_01/","text":"Assignment 1 Problems Game of Life Complete the Game of Life program begun in the screencasts and make the following improvements: Allow the user to choose between the current random display or starting with a predefined shape. You should include at least the following shapes for the user to choose between: Block, Blinker, Beacon, Glider, and Acorn. (This feature is mostly to simplify debugging.) Try to express the aging logic more compactly than the current cascade of if-elif-elif-elif-else. Implement a toroidal universe where the top boundary of the universe is attached to the bottom boundary and the left boundary is attached to the right boundary. Hint: You may recall that because of the way it deals with negative indices Python is making half of each of these connections already, e.g. it has connected the top edge to the bottom edge (but not the bottom to the top) and the left to the right (but not vice versa). In the current implementation we have to create a new next universe (next_u) every generation. This must take some time. Try to have your code reuse the existing u and next_u objects instead of creating new ones. Establish a Baseline One of the key themes of this course is algorithm refinement and this is one of the algorithms we will be revisiting and refining. Let's establish a baseline against which we can compare our refinements. Submit a second version of your program that is instrumented to record and display the time it takes your program to, Initialize the universe. Display the universe Age the universe Run, i.e. the total run time (this should be approximately the sum of the first three values). As well as your program submit a sample output run for the first 50 generations of the Acorn starting configuration using a 25x80 universe. This will let us compare implementations and our computers \u2014 which is always fun. You may want to refresh your memory about timing by consulting Timing Programs from CPSC 128. Logistics Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a1p1bob.py .","title":1},{"location":"Assignments/Assignment_01/#assignment-1","text":"","title":"Assignment 1"},{"location":"Assignments/Assignment_01/#problems","text":"","title":"Problems"},{"location":"Assignments/Assignment_01/#game-of-life","text":"Complete the Game of Life program begun in the screencasts and make the following improvements: Allow the user to choose between the current random display or starting with a predefined shape. You should include at least the following shapes for the user to choose between: Block, Blinker, Beacon, Glider, and Acorn. (This feature is mostly to simplify debugging.) Try to express the aging logic more compactly than the current cascade of if-elif-elif-elif-else. Implement a toroidal universe where the top boundary of the universe is attached to the bottom boundary and the left boundary is attached to the right boundary. Hint: You may recall that because of the way it deals with negative indices Python is making half of each of these connections already, e.g. it has connected the top edge to the bottom edge (but not the bottom to the top) and the left to the right (but not vice versa). In the current implementation we have to create a new next universe (next_u) every generation. This must take some time. Try to have your code reuse the existing u and next_u objects instead of creating new ones.","title":"Game of Life"},{"location":"Assignments/Assignment_01/#establish-a-baseline","text":"One of the key themes of this course is algorithm refinement and this is one of the algorithms we will be revisiting and refining. Let's establish a baseline against which we can compare our refinements. Submit a second version of your program that is instrumented to record and display the time it takes your program to, Initialize the universe. Display the universe Age the universe Run, i.e. the total run time (this should be approximately the sum of the first three values). As well as your program submit a sample output run for the first 50 generations of the Acorn starting configuration using a 25x80 universe. This will let us compare implementations and our computers \u2014 which is always fun. You may want to refresh your memory about timing by consulting Timing Programs from CPSC 128.","title":"Establish a Baseline"},{"location":"Assignments/Assignment_01/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a1p1bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_02/","text":"Assignment 2 Problems Complete the search code begun in the lecture. Specifically: a. Fix the errors in the binary search function. b. Create a binary search_i function. c. Create an interpolativae search function. d. Create an interpolativae search_i function. Ensure all the functions work correctly. (Hint: Don't forget to ensure that they work on very short lists.) A \"pencil and paper\"* exercise on algorithmic complexity. Submit your answers to the following in a text file. a. An O(n) algorithm takes 13ms (milliseconds) to process an array of 300 elements. How long will it take to process an array with 900 elements? b. An O(n3) algorithm takes 5 seconds to process a file with 3,000 entries. How long will it take it to process a file with 8,000 entries? c. An O(log n) algorithm takes 1 second to process a list of 1,000 elements. How long will it take to process a list with 4,000,000 elements? d. An O(n2) algorithm takes 2 minutes to process a 100x100 pixel image. How long will it take to process a 600x600 pixel image? e. An O(2n) algorithm takes 4\u03bcs (microseconds) to process a list with 100 elements. How long will it take to process a list with 12,000 elements? \"Pencil and paper\" does not mean that it has to be done with pencil and paper, it just points out that it can be and doesn't require a program as an answer. The Python shell might provide a convenient way of doing the calculations and you could submit the Python expressions that calculate the answers, e.g. an answer for a2p2e might be print((2 12000//2 100)*4, 'microseconds') Write a pygame program that produces the output below: Tip 1: The program that produced this built upward from the lines: u_rows = 25 u_cols = 40 (In a few weeks we'll use this to display our life universes instead of text output to the shell window.) Tip 2: The 100 cells are placed randomly so you don't have to recreate this exact image. Tip 3: The 16x16 cell image is Blue cell.. Right-click on the image below and do a save-as to get it. Tip 4: screen.blit() is your friend for pasting images onto the screen. Logistics Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a2p1bob.py .","title":2},{"location":"Assignments/Assignment_02/#assignment-2","text":"","title":"Assignment 2"},{"location":"Assignments/Assignment_02/#problems","text":"","title":"Problems"},{"location":"Assignments/Assignment_02/#complete-the-search-code-begun-in-the-lecture","text":"Specifically: a. Fix the errors in the binary search function. b. Create a binary search_i function. c. Create an interpolativae search function. d. Create an interpolativae search_i function. Ensure all the functions work correctly. (Hint: Don't forget to ensure that they work on very short lists.)","title":"Complete the search code begun in the lecture."},{"location":"Assignments/Assignment_02/#a-pencil-and-paper-exercise-on-algorithmic-complexity","text":"Submit your answers to the following in a text file. a. An O(n) algorithm takes 13ms (milliseconds) to process an array of 300 elements. How long will it take to process an array with 900 elements? b. An O(n3) algorithm takes 5 seconds to process a file with 3,000 entries. How long will it take it to process a file with 8,000 entries? c. An O(log n) algorithm takes 1 second to process a list of 1,000 elements. How long will it take to process a list with 4,000,000 elements? d. An O(n2) algorithm takes 2 minutes to process a 100x100 pixel image. How long will it take to process a 600x600 pixel image? e. An O(2n) algorithm takes 4\u03bcs (microseconds) to process a list with 100 elements. How long will it take to process a list with 12,000 elements? \"Pencil and paper\" does not mean that it has to be done with pencil and paper, it just points out that it can be and doesn't require a program as an answer. The Python shell might provide a convenient way of doing the calculations and you could submit the Python expressions that calculate the answers, e.g. an answer for a2p2e might be print((2 12000//2 100)*4, 'microseconds')","title":"A \"pencil and paper\"* exercise on algorithmic complexity."},{"location":"Assignments/Assignment_02/#write-a-pygame-program-that-produces-the-output-below","text":"Tip 1: The program that produced this built upward from the lines: u_rows = 25 u_cols = 40 (In a few weeks we'll use this to display our life universes instead of text output to the shell window.) Tip 2: The 100 cells are placed randomly so you don't have to recreate this exact image. Tip 3: The 16x16 cell image is Blue cell.. Right-click on the image below and do a save-as to get it. Tip 4: screen.blit() is your friend for pasting images onto the screen.","title":"Write a pygame program that produces the output below:"},{"location":"Assignments/Assignment_02/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a2p1bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_03/","text":"Assignment 3 Problems Another \"pencil and paper\"* exercise on algorithmic complexity Submit your answers to the following in a text file. a. A straight selection sort algorithm,O(n2), takes 10ms (milliseconds) to sort an array of 100 elements. How long do you estimate it will take to sort an array with 2000 elements? b. An O(2n) algorithm takes 5 seconds to process a dataset with 20 entries. How long will it take it to process a dataset with 300 entries? c. A Shellsort implementation, O(n log n), takes 11 seconds to sort a list of 1,000 elements. How long do you estimate it will take to sort a list with 40,000 elements? d. An O(n!) algorithm takes 2 seconds to process a list with 10 entries. How long will it take to process a list with 100 entries? e. A binary search of a list of 2,000 items takes takes 2 microseconds. How long do you estimate it will take to search a list with 120,000 elements? \"Pencil and paper\" does not mean that it has to be done with pencil and paper, it just points out that it can be and doesn't require a program as an answer. The Python shell might provide a convenient way of doing the calculations and you could submit the Python expressions that calculate the answers, e.g. an answer for a2p2e might be print((2 12000//2 100)*4, 'microseconds'). Recursion Practice Here are a couple of problems just to give you a bit of practice with recursion and help you internalize the idea. a. Write a recursive function called list_max named that returns the largest value in a list it is passed. Note that like some of the lists in the notes the list could be recursive, e.g. [2, [[100, 7], 90], [1, 13], 8, 6]. b. Write a recursive function called is_palindrome that determines if a string it is passed is a palindrome. (A palindrome is a string that is the same forward and backward, i.e. where the first and last letters are the same and the second and second-last letters are the same etc., e.g. \"eye\", \"dad\" and \"madam\" are palindromes. Word enthusiasts also count phrases that are palindromic once you remove the spaces, capitalization and punctuation, e.g. \"Do geese see God?\" and \"Murder for a jar of red rum.\") c. Write a recursive function called power that raises a number to an exponent. The naive way is to use an explicit loop to multiply the number by itself the required number of times, e.g. computing 216 would require 15 multiplications. But we can be more efficient by noting that 2 16 = 2 8 * 2 8, and that 2 8 = 2 4 * 2 4 and that 2 4 = 2 2 * 2 2 and finally that 2 2 = 2 * 2. Putting this together we could calculate 216 as (2 2) 2) 2) 2 and do only 4 multiplications. It doesn't work out quite so well if the original number isn't an even power of two, but it's not terrible even then. The trick is to view 2 9 as 2 4 * 2 4 * 2. The general relationship is that a n = a (n//2) * a (n//2) if n is even and a n = a (n//2) * a**(n//2) * a if n is odd. Write a recursive function called power that raises a whole number to a whole power (e.g. power(2, 9) using this method. Persistent Life Modify the game of life program from assignment 1 so that it can store and retrieve states of the universe. It should be able to store in any of the three following formats: A screenshot of the universe, one row per line. Python literal of the u array. List of locations of live cells. File format: Line 1: universe_height universe_width (universe dimensions) Lines > 1: row col (indicating the coordinates of live cells) It should also be able to read files in all three formats and should autodetect which format the file is in, i.e. it shouldn't need to ask the user. You can use this snazzy object oriented version as a starting point life_v3.py . Logistics Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a3p1bob.py .","title":3},{"location":"Assignments/Assignment_03/#assignment-3","text":"","title":"Assignment 3"},{"location":"Assignments/Assignment_03/#problems","text":"","title":"Problems"},{"location":"Assignments/Assignment_03/#another-pencil-and-paper-exercise-on-algorithmic-complexity","text":"Submit your answers to the following in a text file. a. A straight selection sort algorithm,O(n2), takes 10ms (milliseconds) to sort an array of 100 elements. How long do you estimate it will take to sort an array with 2000 elements? b. An O(2n) algorithm takes 5 seconds to process a dataset with 20 entries. How long will it take it to process a dataset with 300 entries? c. A Shellsort implementation, O(n log n), takes 11 seconds to sort a list of 1,000 elements. How long do you estimate it will take to sort a list with 40,000 elements? d. An O(n!) algorithm takes 2 seconds to process a list with 10 entries. How long will it take to process a list with 100 entries? e. A binary search of a list of 2,000 items takes takes 2 microseconds. How long do you estimate it will take to search a list with 120,000 elements? \"Pencil and paper\" does not mean that it has to be done with pencil and paper, it just points out that it can be and doesn't require a program as an answer. The Python shell might provide a convenient way of doing the calculations and you could submit the Python expressions that calculate the answers, e.g. an answer for a2p2e might be print((2 12000//2 100)*4, 'microseconds').","title":"Another \"pencil and paper\"* exercise on algorithmic complexity"},{"location":"Assignments/Assignment_03/#recursion-practice","text":"Here are a couple of problems just to give you a bit of practice with recursion and help you internalize the idea. a. Write a recursive function called list_max named that returns the largest value in a list it is passed. Note that like some of the lists in the notes the list could be recursive, e.g. [2, [[100, 7], 90], [1, 13], 8, 6]. b. Write a recursive function called is_palindrome that determines if a string it is passed is a palindrome. (A palindrome is a string that is the same forward and backward, i.e. where the first and last letters are the same and the second and second-last letters are the same etc., e.g. \"eye\", \"dad\" and \"madam\" are palindromes. Word enthusiasts also count phrases that are palindromic once you remove the spaces, capitalization and punctuation, e.g. \"Do geese see God?\" and \"Murder for a jar of red rum.\") c. Write a recursive function called power that raises a number to an exponent. The naive way is to use an explicit loop to multiply the number by itself the required number of times, e.g. computing 216 would require 15 multiplications. But we can be more efficient by noting that 2 16 = 2 8 * 2 8, and that 2 8 = 2 4 * 2 4 and that 2 4 = 2 2 * 2 2 and finally that 2 2 = 2 * 2. Putting this together we could calculate 216 as (2 2) 2) 2) 2 and do only 4 multiplications. It doesn't work out quite so well if the original number isn't an even power of two, but it's not terrible even then. The trick is to view 2 9 as 2 4 * 2 4 * 2. The general relationship is that a n = a (n//2) * a (n//2) if n is even and a n = a (n//2) * a**(n//2) * a if n is odd. Write a recursive function called power that raises a whole number to a whole power (e.g. power(2, 9) using this method.","title":"Recursion Practice"},{"location":"Assignments/Assignment_03/#persistent-life","text":"Modify the game of life program from assignment 1 so that it can store and retrieve states of the universe. It should be able to store in any of the three following formats: A screenshot of the universe, one row per line. Python literal of the u array. List of locations of live cells. File format: Line 1: universe_height universe_width (universe dimensions) Lines > 1: row col (indicating the coordinates of live cells) It should also be able to read files in all three formats and should autodetect which format the file is in, i.e. it shouldn't need to ask the user. You can use this snazzy object oriented version as a starting point life_v3.py .","title":"Persistent Life"},{"location":"Assignments/Assignment_03/#logistics","text":"Use the following naming scheme for your program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a3p1bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_04/","text":"Assignment 4 Problems Modify the MVC application begun in the screencasts as follows: a. Add code to handle the retrieve action. It should prompt the user for the uid of the quote to retrieve, and then display it. b. Add code to handle the delete action. It should prompt the user for the uid of the quote to delete, and then delete it. c. Add code to handle the update action. It should prompt the user for the uid of the quote to update, display the quote, prompt the user to enter the modified version and save the modified version. (Which will need a new uid). (We will work on the search action later in the course.) Be sure to make each modification in the appropriate file so the project remains an MVC application. Animated bouncing Write a program that uses PyGame to simulate two balls moving around an onscreen window and bouncing off the walls, and off each other. Can you generalize this program so that the number of balls is input by the user? Tip: Normally we'll want the balls to begin in random positions with random velocities, but that could mean waiting a while for a collision between balls, and a very long time to see each possible collision. To enable easy testing you should offer an option to start the balls with predetermined positions and velocities chosen to cause an early collision. Persistent Life Modify a life program (yours or mine) so that it displays the life universe in a pygame window instead of to the Python Shell. A sample state of the universe might look like this: Tip: The 16x16 cell image is . Implement this first by redrawing the whole universe each time. Is this faster or slower than output to the shell terminal? By how much? One big advantage of bitmapped output is that we can output to any location we wish on the screen, i.e. we don't have to always go downward line by line as we display. One option this creates is to change the state of cells as they are born or die instead of waiting to get to the end of the loop and then redrawing the whole universe. Implement this approach. Is it slower or faster than drawing the whole universe at once? By how much? Include your answers and discussion in a comment block at the top of the program describing its version history (see e.g. the minimal version history in life_v3.py ). Logistics Since it is a single-file application Problem 2 can use our usual naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a4p2bob.py . For Problem 1 you can use the names MVC_Model_name.py and MVC_Controller_name.py where name is your name and keep using the model file test_model. For problem 3 use v1 and v2 for the two versions.","title":4},{"location":"Assignments/Assignment_04/#assignment-4","text":"","title":"Assignment 4"},{"location":"Assignments/Assignment_04/#problems","text":"","title":"Problems"},{"location":"Assignments/Assignment_04/#modify-the-mvc-application-begun-in-the-screencasts-as-follows","text":"a. Add code to handle the retrieve action. It should prompt the user for the uid of the quote to retrieve, and then display it. b. Add code to handle the delete action. It should prompt the user for the uid of the quote to delete, and then delete it. c. Add code to handle the update action. It should prompt the user for the uid of the quote to update, display the quote, prompt the user to enter the modified version and save the modified version. (Which will need a new uid). (We will work on the search action later in the course.) Be sure to make each modification in the appropriate file so the project remains an MVC application.","title":"Modify the MVC application begun in the screencasts as follows:"},{"location":"Assignments/Assignment_04/#animated-bouncing","text":"Write a program that uses PyGame to simulate two balls moving around an onscreen window and bouncing off the walls, and off each other. Can you generalize this program so that the number of balls is input by the user? Tip: Normally we'll want the balls to begin in random positions with random velocities, but that could mean waiting a while for a collision between balls, and a very long time to see each possible collision. To enable easy testing you should offer an option to start the balls with predetermined positions and velocities chosen to cause an early collision.","title":"Animated bouncing"},{"location":"Assignments/Assignment_04/#persistent-life","text":"Modify a life program (yours or mine) so that it displays the life universe in a pygame window instead of to the Python Shell. A sample state of the universe might look like this: Tip: The 16x16 cell image is . Implement this first by redrawing the whole universe each time. Is this faster or slower than output to the shell terminal? By how much? One big advantage of bitmapped output is that we can output to any location we wish on the screen, i.e. we don't have to always go downward line by line as we display. One option this creates is to change the state of cells as they are born or die instead of waiting to get to the end of the loop and then redrawing the whole universe. Implement this approach. Is it slower or faster than drawing the whole universe at once? By how much? Include your answers and discussion in a comment block at the top of the program describing its version history (see e.g. the minimal version history in life_v3.py ).","title":"Persistent Life"},{"location":"Assignments/Assignment_04/#logistics","text":"Since it is a single-file application Problem 2 can use our usual naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a4p2bob.py . For Problem 1 you can use the names MVC_Model_name.py and MVC_Controller_name.py where name is your name and keep using the model file test_model. For problem 3 use v1 and v2 for the two versions.","title":"Logistics"},{"location":"Assignments/Assignment_05/","text":"Assignment 5 Problems Translate the pseudocode for the straight selection and bubble sort algorithms into working Python programs. Include tests to ensure they are working! Create a module that imports and times all four of this week's sorting methods. Your code should time them on ascending, descending and random ordered lists of lengths 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, and 8192 and output neatly tabulated results (for easy importing into Excel or other graphing programs). You can use even longer lists if the code isn't taking too long to run (it all depends on your computer). Submit graphs of your results. Do they confirm those in the film Sorting Out Sorting? The New Hacker's Dictionary defines Bogosort as follows: Bogo-sort: Repeatedly throw a hand of cards in the air, picking them up at random, and stopping the process when examining the hand reveals the cards are in order. We can approximate the Bogosort method by taking our unsorted list, randomly swapping two values and checking to see if the list is now in order. If it is, we are done, if it isn't, we make another random swap and check again. The pseudocode might look like this: bogosort(lst) while not is_sorted(lst) swap two randomly chosen items in lst As you can see it is a blessedly brief procedure. But is it any good? Write a working bogosort function. What is the fewest swaps required to sort a list? What is the most swaps required? How would you characterize the performance of this algorithm, i.e. what order, O(), is this procedure? (including the computations within the calls to is_sorted()). Answer the questions in the comments. Speed up your simulation of Conway's Game of Life by implementing a neighbours array or universe to reduce the time spent in aging the universe. How much faster does this make the aging portion of your code? Answer in the comments. Logistics Since they are single-file applications Problems 2, 3, and 4 can use our usual naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 3 on this assignment will be named a5p3bob.py . For Problem 1 you can use the names straight_sort_name.py and bubble_sort_name.py where name is your name. Please also submit an excel spreadsheet with your graph for problem 2 called a assignment# p problem#name .xlsx .","title":5},{"location":"Assignments/Assignment_05/#assignment-5","text":"","title":"Assignment 5"},{"location":"Assignments/Assignment_05/#problems","text":"Translate the pseudocode for the straight selection and bubble sort algorithms into working Python programs. Include tests to ensure they are working! Create a module that imports and times all four of this week's sorting methods. Your code should time them on ascending, descending and random ordered lists of lengths 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, and 8192 and output neatly tabulated results (for easy importing into Excel or other graphing programs). You can use even longer lists if the code isn't taking too long to run (it all depends on your computer). Submit graphs of your results. Do they confirm those in the film Sorting Out Sorting? The New Hacker's Dictionary defines Bogosort as follows: Bogo-sort: Repeatedly throw a hand of cards in the air, picking them up at random, and stopping the process when examining the hand reveals the cards are in order. We can approximate the Bogosort method by taking our unsorted list, randomly swapping two values and checking to see if the list is now in order. If it is, we are done, if it isn't, we make another random swap and check again. The pseudocode might look like this: bogosort(lst) while not is_sorted(lst) swap two randomly chosen items in lst As you can see it is a blessedly brief procedure. But is it any good? Write a working bogosort function. What is the fewest swaps required to sort a list? What is the most swaps required? How would you characterize the performance of this algorithm, i.e. what order, O(), is this procedure? (including the computations within the calls to is_sorted()). Answer the questions in the comments. Speed up your simulation of Conway's Game of Life by implementing a neighbours array or universe to reduce the time spent in aging the universe. How much faster does this make the aging portion of your code? Answer in the comments.","title":"Problems"},{"location":"Assignments/Assignment_05/#logistics","text":"Since they are single-file applications Problems 2, 3, and 4 can use our usual naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 3 on this assignment will be named a5p3bob.py . For Problem 1 you can use the names straight_sort_name.py and bubble_sort_name.py where name is your name. Please also submit an excel spreadsheet with your graph for problem 2 called a assignment# p problem#name .xlsx .","title":"Logistics"},{"location":"Assignments/Assignment_06/","text":"Assignment 6 Problems Complete the development of the ObjectServer code begun in the notes by adding the code necessary to implement Update operations. You will find comments in each of the modules indicating where your additions should go (nice eh?). Design a new object class that can be created, stored in, updated in, and deleted from the Object Server (formerly Quote Server) developed in this module. Implement the Maze.carve method by translating the pseudocode in maze_3.py into working Python code. Implement the Maze.display method in maze_3.py to produce a pygame display similar to the sample below: Logistics Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a6p2bob.py .","title":6},{"location":"Assignments/Assignment_06/#assignment-6","text":"","title":"Assignment 6"},{"location":"Assignments/Assignment_06/#problems","text":"Complete the development of the ObjectServer code begun in the notes by adding the code necessary to implement Update operations. You will find comments in each of the modules indicating where your additions should go (nice eh?). Design a new object class that can be created, stored in, updated in, and deleted from the Object Server (formerly Quote Server) developed in this module. Implement the Maze.carve method by translating the pseudocode in maze_3.py into working Python code. Implement the Maze.display method in maze_3.py to produce a pygame display similar to the sample below:","title":"Problems"},{"location":"Assignments/Assignment_06/#logistics","text":"Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a6p2bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_07/","text":"Assignment 7 Problems Complete the quicksort_v1 function. Ensure that it will work on all lists and be sure to include your tests in the code you submit. Complete the heapsort function. Ensure that it will work on all lists and be sure to include your tests in the code you submit. Please submit a graph comparing the speed of quicksort_v1 , quicksort_v2 and heapsort and comment on the results. When we were creating our Heapsort we found a way to store a binary tree inside a list. Using that code as a building block write the following functions: is_child(index1, index2) returns True if index2 is a child of index1 . is_descendant(index1, index2) returns True if index2 is a descendant of index1 and does not use recursion. is_descendant_r(index1, index2) returns True if index2 is a descendant of index1 using recursion. is_ancestor_r(index1, index2) returns True if index2 is an ancestor of index1 using recursion. Activate the controls in the diagram below so they work as described in the notes. You may use life_gui6.py as a starting point if you wish. Logistics Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a7p2bob.py .","title":7},{"location":"Assignments/Assignment_07/#assignment-7","text":"","title":"Assignment 7"},{"location":"Assignments/Assignment_07/#problems","text":"Complete the quicksort_v1 function. Ensure that it will work on all lists and be sure to include your tests in the code you submit. Complete the heapsort function. Ensure that it will work on all lists and be sure to include your tests in the code you submit. Please submit a graph comparing the speed of quicksort_v1 , quicksort_v2 and heapsort and comment on the results. When we were creating our Heapsort we found a way to store a binary tree inside a list. Using that code as a building block write the following functions: is_child(index1, index2) returns True if index2 is a child of index1 . is_descendant(index1, index2) returns True if index2 is a descendant of index1 and does not use recursion. is_descendant_r(index1, index2) returns True if index2 is a descendant of index1 using recursion. is_ancestor_r(index1, index2) returns True if index2 is an ancestor of index1 using recursion. Activate the controls in the diagram below so they work as described in the notes. You may use life_gui6.py as a starting point if you wish.","title":"Problems"},{"location":"Assignments/Assignment_07/#logistics","text":"Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a7p2bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_08/","text":"Assignment 8 Problems ( 10 marks ) At Yukon University numerical grades are converted to letter grades using a conversion chart as follows: Numerical Grade Letter Grade 95-100 A+ 86-94 A 80-85 A- 75-79 B+ 70-74 B 65-69 B- 62-64 C+ 58-61 C 55-57 C- 50-54 D 0-49 F Write a Python cgi script that enables the user to enter their numerical grade and then displays the equivalent letter grade. For example on a first visit to the script\u2019s URL ( http://localhost:8080/cgi-bin/a8p1.py ) they might see, a8p1_input.html And after submitting that form they might see, a8p1_output.html ( 10 marks ) Write a Python cgi script that will return a quote chosen at random from a list of quotes stored in a text file. The format of the file should be one quote per line. You can use this sample file if you don\u2019t have a suitable file of quotes close to hand, and here is a sample output page you can use as a model for your output (please leave the HTML of the page alone with the exception of linking to a different style sheet if you want to alter the appearance of the page). ( 10 marks ) Write a Python cgi script that allows the user to specify a year and month and extracts and displays the weather data for that month in an HTML table. Here is the HTML for the input page and for the display page . As in 3. above you should leave the HTML as is with the exception that you\u2019re free to link to a different style sheet if you want to alter the appearance of the page. Here\u2019s the default style sheet . For weather data you can use weather.txt . ( 20 marks ) Modify maze_6.py so that the user can try to solve the maze by moving an icon through it as described in this week\u2019s notes . Logistics Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a8p1bob.py .","title":8},{"location":"Assignments/Assignment_08/#assignment-8","text":"","title":"Assignment 8"},{"location":"Assignments/Assignment_08/#problems","text":"( 10 marks ) At Yukon University numerical grades are converted to letter grades using a conversion chart as follows: Numerical Grade Letter Grade 95-100 A+ 86-94 A 80-85 A- 75-79 B+ 70-74 B 65-69 B- 62-64 C+ 58-61 C 55-57 C- 50-54 D 0-49 F Write a Python cgi script that enables the user to enter their numerical grade and then displays the equivalent letter grade. For example on a first visit to the script\u2019s URL ( http://localhost:8080/cgi-bin/a8p1.py ) they might see, a8p1_input.html And after submitting that form they might see, a8p1_output.html ( 10 marks ) Write a Python cgi script that will return a quote chosen at random from a list of quotes stored in a text file. The format of the file should be one quote per line. You can use this sample file if you don\u2019t have a suitable file of quotes close to hand, and here is a sample output page you can use as a model for your output (please leave the HTML of the page alone with the exception of linking to a different style sheet if you want to alter the appearance of the page). ( 10 marks ) Write a Python cgi script that allows the user to specify a year and month and extracts and displays the weather data for that month in an HTML table. Here is the HTML for the input page and for the display page . As in 3. above you should leave the HTML as is with the exception that you\u2019re free to link to a different style sheet if you want to alter the appearance of the page. Here\u2019s the default style sheet . For weather data you can use weather.txt . ( 20 marks ) Modify maze_6.py so that the user can try to solve the maze by moving an icon through it as described in this week\u2019s notes .","title":"Problems"},{"location":"Assignments/Assignment_08/#logistics","text":"Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a8p1bob.py .","title":"Logistics"},{"location":"Assignments/Assignment_09/","text":"Assignment 9 Problems ( 10 marks ) Complete the implementation of median_by_partn.py and median_by_bounding.py . Ensure both functions work on all lists (Hint: During development they weren\u2019t tested on lists with even numbers of entries). Be sure to include your tests in the file you submit so I can see them. Time them on random, ascending and descending lists of varying lengths. What order does each algorithm seem to be? What lists produce the best and worst case performances? Add this information to a docstring for each function so prospective users will know what to expect. ( 10 marks ) Since it doesn\u2019t move the values in the list around, the median by bounding approach can\u2019t find the median until it reaches it as it works its way through the list. We saw this in the test code where the number of values considered depended on where in the list the median occurred (i.e. near the front or near the back). Does this make the running time of median_by_bounding more variable than that of median_by_partn ? Show me some data to convince me of your answer. ( 20 marks ) Write the spelling bee administration software described in this week\u2019s notes . Try to make your code bullet proof, and use EasyGUI for user interactions. Logistics Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a9p1bob.py","title":9},{"location":"Assignments/Assignment_09/#assignment-9","text":"","title":"Assignment 9"},{"location":"Assignments/Assignment_09/#problems","text":"( 10 marks ) Complete the implementation of median_by_partn.py and median_by_bounding.py . Ensure both functions work on all lists (Hint: During development they weren\u2019t tested on lists with even numbers of entries). Be sure to include your tests in the file you submit so I can see them. Time them on random, ascending and descending lists of varying lengths. What order does each algorithm seem to be? What lists produce the best and worst case performances? Add this information to a docstring for each function so prospective users will know what to expect. ( 10 marks ) Since it doesn\u2019t move the values in the list around, the median by bounding approach can\u2019t find the median until it reaches it as it works its way through the list. We saw this in the test code where the number of values considered depended on where in the list the median occurred (i.e. near the front or near the back). Does this make the running time of median_by_bounding more variable than that of median_by_partn ? Show me some data to convince me of your answer. ( 20 marks ) Write the spelling bee administration software described in this week\u2019s notes . Try to make your code bullet proof, and use EasyGUI for user interactions.","title":"Problems"},{"location":"Assignments/Assignment_09/#logistics","text":"Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 1 on this assignment will be named a9p1bob.py","title":"Logistics"},{"location":"Assignments/Assignment_10/","text":"Assignment 10 Problems ( 20 marks ) Design a new object class that can be created, stored in, updated in, and/or deleted from the Object Server (formerly Quote Server) developed in this module. I recommend using either quote.py or hockey_player.py as a base and modifying to suit your objects\u2019 needs. You can find links to our final versions of the files at the bottom of the Summary page . You will also need to make two small additions to object_server.py to inform it of your new class\u2019 existence. Place all the files necessary into a directory (or small hierarchy if you prefer) and zip it all up so you can submit a single file: a10p1.zip . ( 10 marks ) Thresholding . Consider the two images of the Che Guevara below. The one on the left is an actual photograph. The one on the right is a manipulated image that has become iconic (even more so when it has a red background). In image processing terms the one on the right is a thresholded version of the one on the left where values above some threshold have been set to white (255 in pillow terms) and values below that threshold have been set to black (0). Thresholding is a common operation that can be used to highlight or emphasize some parts of an image, e.g. a tumour in a medical image. The question is how to choose the threshold value. For this problem you will write three thresholding functions. The first, mean_threshold(im) , will use the average pixel value in the image as the threshold. So it will set all pixels darker than the average pixel to be black, and all those brighter than average to be white. (You should write your own code to find the average pixel value.) The second, median_threshold(im) , will use the median pixel value in the image as the threshold. So it will set the lighter half of the pixels to be white and the darker half of the pixels to be black. (You should write your own code the find the median value.) (Note: If the pixel distribution is flat, or symmetric, mean_threshold and median_threshold will look the same, but if the distribution of pixel values is skewed, e.g. there are a lot more bright ones than dark ones, the results will be quite different.) The third, threshold(im, value) , thresholds the image using the value it is passed. Can you find a value that reproduces the image on the right above? (To make it easier to play around with this you can use the command im.show() in your program. This will open im in the default program your operating system uses for images of that type. If you put this in a loop that prompts for the threshold value and then displays the thresholded image you can make this thresholding into an interactive process). ( 10 marks ) Improving edge measurement . In the notes we saw two masks that could be used to calculate vertical ( dx ) and horizontal ( dy ) edge strengths. But what about edges in other orientations? For example a diagonal edge will have medium values for both horizontal and vertical measures even if it is a strong edge. a) To better measure edge strength we should combine the horizontal and vertical values to get a single measure of edge strength. The key to doing this is to realize that dx and dy measure components of edge strength. The problem of finding the \u2019true\u2019 edge strength from them is the same as the problem of finding the magnitude of a vector in physics from its horizontal and vertical components, and the solution is the same too: the magnitude is the root of the sum of the squares of the component magnitudes , i.e. d = sqrt(dx^2^ + dy^2^). \\ Write a function that is passed an image and returns an image whose pixel values are the edge strength at each location in the original image. b) This edge strength measure is objective, but it may not be perceptually accurate. There is lots of evidence that the human visual system judges things relative to their surroundings. For a dramatic example consider the optical illusion below in which squares A and B have the same pixel value and yet do not look the same to us because we judge their brightness relative to their immediate surroundings. (For more on this illusion see Checker shadow illusion in Wikipedia). In the same way it might be that we \u201csee\u201d edge strength relative to the surrounding brightness, i.e. a +10 jump in a dark region may be more significant than a +10 jump in a bright region. Write another function that divides the edge strength at each pixel location by the local average pixel value (where \u201clocal\u201d means 3x3 pixel \u201cneighbourhood\u201d). c) It\u2019s also possible that we judge edge strength relative not to the local luminance or pixel value, but to the local variation in luminance. In topographic terms this explains why a 10 meter cliff on the prairie is more striking than a 10 m cliff in the mountains: there is more variation in elevation in the mountains than on the prairie so it stands out less in them than it does on the flat (nonvarying) prairie. How can we measure variation mathematically? One common measure for the variation in a set of numbers is the root mean squared error . The name actually says it all though it takes a moment or two to parse it. It tells us to take the square root of the mean of the squares of the errors . The \u201cerrors\u201d are the differences between each value and the average of all the values. Let\u2019s look at an example: The numbers: 4, 5, 9, 8, 5, 4, 12, 4, 4 The average: (4 + 5 + 9 + 8 + 5 + 4 + 11 + 4 + 4)/9 = 54/9 = 6 The \u201cerrors\u201d: 4-6=-2, 5-6=-1, 9-6=3, 8-6=2, 5-6=-1, 4-6=-2, 11-6=5, 4-6=-2, 4-6=-2 The squares of the errors: 4, 1, 9, 4, 1, 4, 25, 4, 4. The mean of the squared errors: (4+1+9+4+1+4+25+4+4)/9=6 The root of the mean of the squared errors: \u221a6=2.4494897427831779 Write a function that divides the edge strength at each location by the local variation in the image, i.e. by the RMSE of the local 3x3 neighbourhood. Logistics Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a10p2bob.py","title":10},{"location":"Assignments/Assignment_10/#assignment-10","text":"","title":"Assignment 10"},{"location":"Assignments/Assignment_10/#problems","text":"( 20 marks ) Design a new object class that can be created, stored in, updated in, and/or deleted from the Object Server (formerly Quote Server) developed in this module. I recommend using either quote.py or hockey_player.py as a base and modifying to suit your objects\u2019 needs. You can find links to our final versions of the files at the bottom of the Summary page . You will also need to make two small additions to object_server.py to inform it of your new class\u2019 existence. Place all the files necessary into a directory (or small hierarchy if you prefer) and zip it all up so you can submit a single file: a10p1.zip . ( 10 marks ) Thresholding . Consider the two images of the Che Guevara below. The one on the left is an actual photograph. The one on the right is a manipulated image that has become iconic (even more so when it has a red background). In image processing terms the one on the right is a thresholded version of the one on the left where values above some threshold have been set to white (255 in pillow terms) and values below that threshold have been set to black (0). Thresholding is a common operation that can be used to highlight or emphasize some parts of an image, e.g. a tumour in a medical image. The question is how to choose the threshold value. For this problem you will write three thresholding functions. The first, mean_threshold(im) , will use the average pixel value in the image as the threshold. So it will set all pixels darker than the average pixel to be black, and all those brighter than average to be white. (You should write your own code to find the average pixel value.) The second, median_threshold(im) , will use the median pixel value in the image as the threshold. So it will set the lighter half of the pixels to be white and the darker half of the pixels to be black. (You should write your own code the find the median value.) (Note: If the pixel distribution is flat, or symmetric, mean_threshold and median_threshold will look the same, but if the distribution of pixel values is skewed, e.g. there are a lot more bright ones than dark ones, the results will be quite different.) The third, threshold(im, value) , thresholds the image using the value it is passed. Can you find a value that reproduces the image on the right above? (To make it easier to play around with this you can use the command im.show() in your program. This will open im in the default program your operating system uses for images of that type. If you put this in a loop that prompts for the threshold value and then displays the thresholded image you can make this thresholding into an interactive process). ( 10 marks ) Improving edge measurement . In the notes we saw two masks that could be used to calculate vertical ( dx ) and horizontal ( dy ) edge strengths. But what about edges in other orientations? For example a diagonal edge will have medium values for both horizontal and vertical measures even if it is a strong edge. a) To better measure edge strength we should combine the horizontal and vertical values to get a single measure of edge strength. The key to doing this is to realize that dx and dy measure components of edge strength. The problem of finding the \u2019true\u2019 edge strength from them is the same as the problem of finding the magnitude of a vector in physics from its horizontal and vertical components, and the solution is the same too: the magnitude is the root of the sum of the squares of the component magnitudes , i.e. d = sqrt(dx^2^ + dy^2^). \\ Write a function that is passed an image and returns an image whose pixel values are the edge strength at each location in the original image. b) This edge strength measure is objective, but it may not be perceptually accurate. There is lots of evidence that the human visual system judges things relative to their surroundings. For a dramatic example consider the optical illusion below in which squares A and B have the same pixel value and yet do not look the same to us because we judge their brightness relative to their immediate surroundings. (For more on this illusion see Checker shadow illusion in Wikipedia). In the same way it might be that we \u201csee\u201d edge strength relative to the surrounding brightness, i.e. a +10 jump in a dark region may be more significant than a +10 jump in a bright region. Write another function that divides the edge strength at each pixel location by the local average pixel value (where \u201clocal\u201d means 3x3 pixel \u201cneighbourhood\u201d). c) It\u2019s also possible that we judge edge strength relative not to the local luminance or pixel value, but to the local variation in luminance. In topographic terms this explains why a 10 meter cliff on the prairie is more striking than a 10 m cliff in the mountains: there is more variation in elevation in the mountains than on the prairie so it stands out less in them than it does on the flat (nonvarying) prairie. How can we measure variation mathematically? One common measure for the variation in a set of numbers is the root mean squared error . The name actually says it all though it takes a moment or two to parse it. It tells us to take the square root of the mean of the squares of the errors . The \u201cerrors\u201d are the differences between each value and the average of all the values. Let\u2019s look at an example: The numbers: 4, 5, 9, 8, 5, 4, 12, 4, 4 The average: (4 + 5 + 9 + 8 + 5 + 4 + 11 + 4 + 4)/9 = 54/9 = 6 The \u201cerrors\u201d: 4-6=-2, 5-6=-1, 9-6=3, 8-6=2, 5-6=-1, 4-6=-2, 11-6=5, 4-6=-2, 4-6=-2 The squares of the errors: 4, 1, 9, 4, 1, 4, 25, 4, 4. The mean of the squared errors: (4+1+9+4+1+4+25+4+4)/9=6 The root of the mean of the squared errors: \u221a6=2.4494897427831779 Write a function that divides the edge strength at each location by the local variation in the image, i.e. by the RMSE of the local 3x3 neighbourhood.","title":"Problems"},{"location":"Assignments/Assignment_10/#logistics","text":"Use the following naming scheme for program files: a assignment# p problem#name .py . So Bob's solution to problem 2 on this assignment will be named a10p2bob.py","title":"Logistics"}]}